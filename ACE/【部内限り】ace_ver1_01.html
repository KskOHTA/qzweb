<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Google Cloud Leader問題集 01</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="quiz-container">
        <div id="quiz-data" style="display: none;">
<div class='question' data-multiple='false' data-question='問題1<br>あなたはGoogle Cloudの新規顧客の課金設定を依頼されました。あなたの顧客は、共通のIAMポリシーを共有するリソースをグループ化したいと考えています。<br>この要件を満たすために、どうすればよいですか？' data-answer='0' data-explanation='解説<br>正解は「フォルダを使用して、共通のIAMポリシーを共有するリソースをグループ化します」です。<br>この問題では、課金設定とリソースのグループ化、さらにIAMポリシーの共有という要素があり、これらがどのように関連しているのか理解することが重要です。また、求められているのはリソースのグループ化なので、特定の方式でリソースをグループ化することで要件を満たす選択肢を探すことが求められています。この際、課金設定やプロジェクトの命名構造といった、リソースの直接的なグループ化とは関連性の薄い要素に惑わされないように気をつけることが大切です。<br>基本的な概念や原則：<br>フォルダ：Google Cloudのリソース階層モデルの一部で、リソースを組織化するためのコンテナです。同様のポリシーや許可を持つプロジェクトをグループ化するのに適しています。<br>IAMポリシー：Google Cloudのリソースへのアクセス制御を行うための規則を設定する仕組みです。IAMポリシーはロールとメンバーからなり、ロールが許可するアクションをメンバーが実行できるようにします。<br>ラベル：Google Cloudのリソースをグループ化し、管理するためのキーと値のペアです。リソースのフィルタリングやコストの分析などに活用できますが、IAMポリシーの共有には使用できません。<br>課金アカウント：Google Cloudのサービスの使用料金を計算し、請求するためのアカウントです。複数のプロジェクト間で課金アカウントを共有できますが、IAMポリシーの管理には直接使用できません。<br>プロジェクトの命名構造：Google Cloudのプロジェクトを効率的に管理するための命名システムです。プロジェクト名は独自である必要がありますが、IAMポリシーの管理には直接影響を及ぼしません。<br>正解についての説明：<br>（選択肢）<br>・フォルダを使用して、共通のIAMポリシーを共有するリソースをグループ化します<br>この選択肢が正解の理由は以下の通りです。<br>Google Cloudのリソース階層構造において、フォルダはリソースを意味的にまとめたり、課金、アクセス制御（IAMポリシー）などを共通で設定するために使用できます。フォルダは一つまたは複数のプロジェクトを持つことができ、これらのプロジェクトや下位のフォルダは、上位のフォルダで設定したIAMポリシーを継承します。<br>したがって、既存のリソースを共通のIAMポリシーで管理したい顧客の要件を満たすためには、関連するリソースを一つのフォルダ内にグループ化するのが最適です。これにより、関連するリソースへのアクセス管理が一元化され、運用が簡素化されます。<br>不正解の選択肢についての説明：<br>選択肢：ラベルを使用して、共通のIAMポリシーを共有するリソースをグループ化します<br>この選択肢が正しくない理由は以下の通りです。<br>ラベルはリソースを組織化および識別するための単純なテキストベースの識別子であり、直接IAMポリシーの管理には使用できません。フォルダを使用すると、共通のIAMポリシーを共有する複数のリソースを一箇所にまとめることができ、より適切な選択肢です。<br>選択肢：IAMポリシーをグループ化するために、適切な課金アカウント構造を設定します<br>この選択肢が正しくない理由は以下の通りです。<br>課金アカウント構造は、課金管理やコストを追跡、制御するためのものであり、IAMポリシーをグループ化する目的で使用されるものではありません。<br>それに対して、フォルダは複数のリソースをグループ化し、共通のIAMポリシーを適用するのに適しています。<br>選択肢：IAMポリシーをグループ化するために、適切なプロジェクトの命名構造を設定します<br>この選択肢が正しくない理由は以下の通りです。<br>IAMポリシーをグループ化するためにプロジェクトの命名構造を設定するとは全く関連しておらず、かつIAMポリシーの適用範囲を限定するものではありません。<br>それに対して、フォルダを使用することでリソースをグループ化し、共通のIAMポリシーを適用することが可能になります。'>
<div class='choice'> フォルダを使用して、共通のIAMポリシーを共有するリソースをグループ化します</div>
<div class='choice'> IAMポリシーをグループ化するために、適切なプロジェクトの命名構造を設定します</div>
<div class='choice'> ラベルを使用して、共通のIAMポリシーを共有するリソースをグループ化します</div>
<div class='choice'> IAMポリシーをグループ化するために、適切な課金アカウント構造を設定します</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題2<br>gcloud container clustersコマンドを使用して、prod-clusterとdev-clusterの2つのGoogle Cloud Kubernetes（GKE）クラスターを作成しました。<br>- prod-clusterは標準クラスターです。<br>- dev-clusterは自動パイロットクラスターです。<br>kubectl get nodesコマンドを実行すると、prod-clusterのノードしか表示されません。dev-clusterのノードステータスを確認するために、どのコマンドを実行する必要がありますか？' data-answer='3' data-explanation='解説<br>正解は「gcloud container clusters get-credentials dev-clusterkubectl get nodes」です。<br>この問題では、2つの異なるタイプのGoogle Cloud Kubernetes（GKE）クラスターのノードステータスの確認方法が問われています。prod-clusterは標準クラスターで、dev-clusterは自動パイロットクラスターという点をもとに、それぞれのクラスターのノードステータスをどのように確認するかが重要です。各クラスターのタイプを理解し、そのタイプに最適なコマンドを選びやすい問題と言えます。また、"kubectl get nodes"コマンドがprod-clusterでは機能しますが、dev-clusterでは機能しない理由も理解しておくと有利でしょう。以上の内容を考慮して適切なコマンド組み合わせを選択することが重要です。<br>基本的な概念や原則：<br>Google Kubernetes Engine（GKE）：Google CloudのマネージドKubernetesサービスで、コンテナ化されたアプリケーションをデプロイ、スケール、管理するための環境を提供します。<br>gcloud container clusters：GKEクラスターを操作するためのコマンドラインインターフェースです。クラスターの作成、更新、削除などを行うことができます。<br>kubectl：Kubernetesクラスターを操作するためのコマンドラインインターフェースです。"get nodes"はクラスター内のノードの状態を調べるコマンドです。<br>自動パイロットクラスター：GKEの運用管理をGoogleに委ねて、ユーザーはアプリケーションの開発に集中できるモードです。このモードでは基盤となるノードの管理が不要になるため"kubectl get nodes"コマンドによるノードの状態確認が出来ないことが特徴です。<br>gcloud container clusters get-credentials：クラスターの認証情報を取得するgcloudコマンドです。このコマンドで取得した認証情報を使ってkubectlコマンドからクラスターを操作することができます。<br>正解についての説明：<br>（選択肢）<br>・gcloud container clusters get-credentials dev-clusterkubectl get nodes<br>この選択肢が正解の理由は以下の通りです。<br>まず、Kubernetesクラスターのノードの情報を取得するためには、kubectl get nodesコマンドを使います。<br>しかし、このコマンドは現在クラスターのコンテキストで動作し、それがprod-clusterに設定されている場合、prod-clusterのノード情報のみが表示されます。そのため、dev-clusterのノード情報を取得するために、まずクラスターコンテキストをdev-clusterに切り替える必要があります。そのためには、gcloud container clusters get-credentials dev-clusterコマンドを使ってクラスターの認証情報を取得し、kubectlの現在のコンテキストをそれに切り替える必要があります。これにより、その後に実行されるkubectl get nodesコマンドは、dev-clusterのノード情報を表示します。<br>不正解の選択肢についての説明：<br>選択肢：gcloud container clusters update --generate-password dev-cluster kubectl get nodes<br>この選択肢が正しくない理由は以下の通りです。<br>gcloud container clusters update --generate-passwordはクラスターパスワードを生成するコマンドであり、ノードのステータスを確認するためのコマンドではありません。正解はクラスターの資格情報を取得し、その上でkubectl get nodesを使うものです。<br>選択肢：kubectl config set-context dev-cluster kubectl cluster-info<br>この選択肢が正しくない理由は以下の通りです。<br>kubectl config set-contextとkubectl cluster-infoはクラスターへのアクセス情報を設定し、クラスター情報を表示するコマンドですが、ノードの状態を確認するためのものではありません。GKEの自動パイロットモードでは、管理するノードは存在せず&#39;kubectl get nodes&#39;コマンドは利用できません。そのため、正解はgcloudコマンドを使わなければなりません。<br>選択肢：kubectl config set-credentials dev-cluster kubectl cluster-info<br>この選択肢が正しくない理由は以下の通りです。<br>まず、kubectl config set-credentialsは認証情報を設定するコマンドであり、dev-clusterのノードステータスを確認するためのコマンドではありません。<br>また、kubectl cluster-infoはクラスターの全体的な情報を提供しますが、特定のノードのステータスに関する詳細情報は提供しません。よって、この選択肢は不適切です。'>
<div class='choice'> kubectl config set-context dev-cluster kubectl cluster-info</div>
<div class='choice'> kubectl config set-credentials dev-cluster kubectl cluster-info</div>
<div class='choice'> gcloud container clusters update --generate-password dev-cluster kubectl get nodes</div>
<div class='choice'> gcloud container clusters get-credentials dev-clusterkubectl get nodes</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題3<br>あなたは、グローバルに分散されたアプリケーションをデプロイするために使用する新しいプロジェクトを作成したばかりです。データストレージにはCloud Spannerを使用します。あなたは現在、Cloud Spannerインスタンスを作成している最中です。インスタンスを作成する準備として、最初のステップを実行します。<br>あなたはこの後何をすべきですか？' data-answer='1' data-explanation='解説<br>正解は「Cloud Spanner APIを有効にします」です。<br>この問題では、Cloud Spannerのインスタンスを作成するプロセスの最初のステップについて考察しています。Cloud Spannerを使用するための基本的な要件や条件を認識しておく必要があります。インスタンスを作成するための準備、すなわち、Cloud Spannerを稼働させるために何が必要かを深く理解することが求められます。誤った選択肢を探ることによって、Cloud Spannerの適切な利用法についての理解を確認し、必要な設定や権限がどのようなものかを把握することが重要です。<br>基本的な概念や原則：<br>Cloud Spanner API：Cloud Spannerの所有するデータベーススキーマを操作または管理するために必要なAPIです。このAPIを有効にしないとCloud Spannerインスタンスを作成したり、操作したりすることができません。<br>マルチリージョン設定：Cloud Spannerインスタンスを複数のリージョンで利用するための設定です。これにより高可用性と耐障害性を向上させることが可能ですが、初期設定としては必須ではありません。<br>VPCネットワーク：仮想プライベートクラウド（VPC）ネットワークはGoogle Cloud内のリソース間のネットワーキングを提供するもので、Cloud Spannerのインスタンス作成に直接関連はありません。<br>IAMロール：Google Cloudの認証と認可を管理するためのツールです。特定のロールをユーザーに付与することで、そのユーザーがGoogle Cloudの何をどのように操作できるかを制限することができます。しかし、いきなりIAMロールを付与する必要はありません。<br>正解についての説明：<br>（選択肢）<br>・Cloud Spanner APIを有効にします<br>この選択肢が正解の理由は以下の通りです。<br>まず、Google Cloudプロジェクトを新規に作成した場合、多くのAPIはデフォルトで無効になっています。そのため、Cloud Spannerの機能を利用するためにはまずCloud Spanner APIを有効にする必要があります。APIを有効にすることで、Cloud Spannerサービスとやり取りできるようになります。<br>また、APIを有効化した後であれば、インスタンスの作成やテーブルの操作などの詳細なタスクを開始できます。<br>これがCloud Spannerインスタンスを作成する最初のステップとなるため、正解の選択肢です。そのため、特定のGoogle Cloudサービスを使用する際には、該当するAPIを有効にすることを忘れないようにしましょう。<br>不正解の選択肢についての説明：<br>選択肢：Cloud Spannerインスタンスをマルチリージョンに設定します<br>この選択肢が正しくない理由は以下の通りです。<br>インスタンスをマルチリージョンに設定するのはCloud Spannerの運用段階での設定であり、インスタンス作成の"準備"や"最初のステップ"ではありません。最初に行うべきはCloud Spanner APIの有効化で、これによりCloud Spannerが利用可能になります。<br>選択肢：希望するすべてのリージョンにサブネットワークを持つ新しいVPCネットワークを作成します<br>この選択肢が正しくない理由は以下の通りです。<br>Cloud Spannerはフルマネージドのリージョナルやマルチリージョナルのストレージサービスであり、サブネットワークの作成は必要ありません。<br>それに対して、Cloud Spanner APIを有効にすることで、Cloud Spannerインスタンスを作成・管理できるようになります。<br>選択肢：Cloud Spanner AdminのIAMロールを自分に付与します<br>この選択肢が正しくない理由は以下の通りです。<br>Cloud Spannerのインスタンスを作成するためには、まずCloud Spanner APIを有効にする必要があります。Cloud Spanner AdminのIAMロールを自分に付与するというのは、それ以降の操作に関わる設定で、最初のステップとしては最適ではありません。'>
<div class='choice'> 希望するすべてのリージョンにサブネットワークを持つ新しいVPCネットワークを作成します</div>
<div class='choice'> Cloud Spanner APIを有効にします</div>
<div class='choice'> Cloud Spanner AdminのIAMロールを自分に付与します</div>
<div class='choice'> Cloud Spannerインスタンスをマルチリージョンに設定します</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題4<br>あなたは、タスクの実行に96個のvCPUを必要とする、プロダクションクリティカルなオンプレミスアプリケーションを移行しようとしています。そのアプリケーションがGoogle Cloud上の同様の環境で動作することを確認したいと考えています。<br>あなたはこの要件を満たすために、どうすればよいですか？' data-answer='2' data-explanation='解説<br>正解は「VMを作成する際は、マシンタイプn1-standard-96を使用します」です。<br>この問題では、大規模なオンプレミスアプリケーションをGoogle Cloudに移行し、そのパフォーマンスを順調に維持する方法について問われています。96個のvCPUを必要とすることから、求められるリソースが非常に大きいことがわかります。したがって、選択肢を検討する際には、要求されるvCPU数を確実に確保できるかどうかと、クラスターコンピューティングリソースを効果的に活用できるマシンタイプかどうかを中心に判断基準とするべきです。<br>基本的な概念や原則：<br>マシンタイプ：Google Cloud上で各種仮想マシン（VM）を定義する際の設定オプションです。特定のvCPU数とメモリを持つマシンタイプを選択することができます。<br>n1-standard-96：96個のvCPUと360GBのメモリを持つマシンタイプです。リソース要件が高いタスクの実行に適しています。<br>CPUプラットフォーム：Google CloudのVMで使用可能なCPUの種類を指します。しかし、特定のCPUプラットフォームを選択するだけでは、必要なvCPU数を満たすことはできません。<br>gcloud：Google Cloudを管理するためのコマンドラインインターフェースツールです。ただし、実行中のインスタンスのvCPU数は変更できません。<br>Rightsizing Recommendations：Google Cloudが提供するパフォーマンスの最適化機能です。しかし、これは現在のワークロードに基づいてVMインスタンスのvCPUの数を最適化するものであり、特定のvCPU数を確保するものではありません。<br>正解についての説明：<br>（選択肢）<br>・VMを作成する際は、マシンタイプn1-standard-96を使用します<br>この選択肢が正解の理由は以下の通りです。<br>まず、Google CloudのCompute Engineでは、様々なマシンタイプを提供しており、稼働させるアプリケーションに応じて最適なスペックを選ぶことができます。ここで、適切なマシンタイプを選ぶことで、オンプレミスシステムと同等あるいはそれ以上のパフォーマンスを確保することができます。その中でもn1-standard-96というマシンタイプは、96個のvCPUを提供するため、問題文の要件である"タスクの実行に96個のvCPUを必要とする"というコンディションを満たします。<br>したがって、オンプレミスのアプリケーションをGoogle Cloudに移行し、同などのパフォーマンスを確保するためには、n1-standard-96といった十分なリソースを提供するマシンタイプを選択するのが最適な策です。<br>不正解の選択肢についての説明：<br>選択肢：VMを作成する際は、CPUプラットフォームとしてIntel Skylakeを使用します<br>この選択肢が正しくない理由は以下の通りです。<br>CPUプラットフォームをIntel Skylakeに指定することは可能ですが、これはCPUの種類を指定しているだけで、必要なvCPU数を確保することとは関連していません。<br>一方、マシンタイプn1-standard-96を選ぶことで、目的の96個のvCPUを確保できます。<br>選択肢：Compute Engineのデフォルト設定を使用してVMを作成します。gcloudを使用して、実行中のインスタンスを96個のvCPUを持つように変更します<br>この選択肢が正しくない理由は以下の通りです。<br>Compute Engineのデフォルト設定を使用したVMの作成後にgcloudを使用してvCPU数を変更するという手法では、実行中のインスタンスのvCPU数を増やすことは出来ません。<br>一方で、マシンタイプn1-standard-96を使用することで、一度に96個のvCPUが利用可能なVMを作成することができます。<br>選択肢：Compute Engineのデフォルト設定を使用してVMを起動し、Rightsizing Recommendationsに基づいて調整します<br>この選択肢が正しくない理由は以下の通りです。<br>タスクに96個のvCPUが必要な場合、デフォルト設定のVMではリソースが不足します。Rightsizing Recommendationsは効率的なリソース使用を推奨するものであり、特定のリソース要件を満たすためのものではありません。<br>それに対して、マシンタイプn1-standard-96を指定することで96個のvCPUを持つVMを作成できます。'>
<div class='choice'> VMを作成する際は、CPUプラットフォームとしてIntel Skylakeを使用します</div>
<div class='choice'> Compute Engineのデフォルト設定を使用してVMを作成します。gcloudを使用して、実行中のインスタンスを96個のvCPUを持つように変更します</div>
<div class='choice'> VMを作成する際は、マシンタイプn1-standard-96を使用します</div>
<div class='choice'> Compute Engineのデフォルト設定を使用してVMを起動し、Rightsizing Recommendationsに基づいて調整します</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題5<br>あなたは、新しい課金アカウントを作成し、既存のGoogle Cloudプロジェクトとリンクする必要があります。<br>この要件を満たすために、どうすればよいですか？' data-answer='1' data-explanation='解説<br>正解は「Google CloudプロジェクトのProject Billing Managerであることを確認します。新しい請求アカウントを作成し、新しい請求アカウントを既存のプロジェクトにリンクします」です。<br>この問題では、新しい課金アカウント作成と既存のGoogle Cloudプロジェクトとのリンクの仕方について問われています。ここで重要な点は、"新しく課金アカウントを作成"し、"既存のGoogle Cloudプロジェクトとリンクする"ことです。選択肢を見るとき、課金アカウントの作成とそのリンク方法だけでなく、適切なロール（Project Billing Managerや課金管理者）が与えられていることも確認する必要があります。<br>基本的な概念や原則：<br>Project Billing Manager：Google Cloudプロジェクトの課金設定を管理する権限を持つロールです。新しく課金アカウントを作成し、その課金アカウントを既存のプロジェクトにリンクすることができます。<br>Google Cloudプロジェクト：Google Cloudのリソースをグループ分けし、管理するためのものです。一つのプロジェクトは一つの課金アカウントにリンクすることができます。<br>課金アカウント管理者：Google Cloudの課金アカウント全体を管理する権限を持つロールです。新しいプロジェクトを作成し、そのプロジェクトを既存の課金アカウントにリンクすることができます。ただし、既存のプロジェクトの課金設定を変更することはできません。<br>正解についての説明：<br>（選択肢）<br>・Google CloudプロジェクトのProject Billing Managerであることを確認します。新しい請求アカウントを作成し、新しい請求アカウントを既存のプロジェクトにリンクします<br>この選択肢が正解の理由は以下の通りです。<br>まず、適切な課金アカウントをプロジェクトに関連付けるには、そのプロジェクトの課金管理者（Project Billing Manager）である必要があります。これは、リソースの使用に対する課金と課金情報の管理に関する許可を有しているためです。<br>したがって、新しい課金アカウントを作成し、それを既存のプロジェクトにリンクするためには、まず自分自身がそのプロジェクトの課金管理者であることを確認する必要があります。<br>次に、新しい課金アカウントを作成します。これにより、新しい課金ポリシーや請求情報を既存のプロジェクトに適用することができます。<br>また、それぞれのプロジェクトを別々の課金アカウントにリンクすることで、プロジェクト間の費用配分をより明確にすることが可能になります。<br>最後に、新しく作成した課金アカウントを既存のGoogle Cloudプロジェクトにリンクします。これにより、そのプロジェクトが使用するリソースの料金が、新しい課金アカウントに請求されるようになります。この手順により、新しい課金アカウントを作成し、それを既存のプロジェクトとリンクするという要件を満たすことができます。<br>不正解の選択肢についての説明：<br>選択肢：Google CloudプロジェクトのProject Billing Managerであることを確認します。既存のプロジェクトを更新して、既存の請求アカウントにリンクします<br>この選択肢が正しくない理由は以下の通りです。<br>既存のプロジェクトを更新して既存の請求アカウントにリンクするとは、新しい課金アカウントを作成し、それをプロジェクトにリンクするという要件を満たしません。正解は新しい請求アカウントを作り、それを既存のプロジェクトに適用することです。<br>選択肢：課金アカウントの課金管理者であることを確認します。新しいプロジェクトを作成し、新しいプロジェクトを既存の請求アカウントにリンクします<br>この選択肢が正しくない理由は以下の通りです。<br>要件は新しい課金アカウントを作成し、それを既存のプロジェクトにリンクすることです。<br>しかし、不正解の選択肢は新しいプロジェクトを作成し、それを既存の請求アカウントにリンクすると述べており、要件と合致していません。正解では適切に既存プロジェクトと新しい課金アカウントのリンクが述べられています。<br>選択肢：課金アカウントの課金管理者であることを確認します。既存のプロジェクトを更新して、既存の請求アカウントにリンクします<br>この選択肢が正しくない理由は以下の通りです。<br>課金アカウントの課金管理者ではなくプロジェクトの請求マネージャーとして機能する必要があります。<br>また、既存のプロジェクトを更新して既存の請求アカウントにリンクするのではなく、新しい請求アカウントを作成し既存のプロジェクトにこの新しい請求アカウントをリンクする方が正解の選択肢と一致します。'>
<div class='choice'> Google CloudプロジェクトのProject Billing Managerであることを確認します。既存のプロジェクトを更新して、既存の請求アカウントにリンクします</div>
<div class='choice'> Google CloudプロジェクトのProject Billing Managerであることを確認します。新しい請求アカウントを作成し、新しい請求アカウントを既存のプロジェクトにリンクします</div>
<div class='choice'> 課金アカウントの課金管理者であることを確認します。既存のプロジェクトを更新して、既存の請求アカウントにリンクします</div>
<div class='choice'> 課金アカウントの課金管理者であることを確認します。新しいプロジェクトを作成し、新しいプロジェクトを既存の請求アカウントにリンクします</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題6<br>あなたは、モノのインターネット（IoT）アプリケーション用にGoogle Cloud上にデータレイクを構築しています。IoTアプリケーションには何百万ものセンサーがあり、構造化データと非構造化データをクラウド上のバックエンドに常にストリーミングしています。Googleが推奨するプラクティスに基づいて、可用性と耐障害性の高いアーキテクチャを構築したいと考えています。<br>この要件を満たすために、どうすればよいですか？' data-answer='2' data-explanation='解説<br>正解は「Pub/Subにデータをストリームし、Dataflowを使ってCloud Storageにデータを送信します」です。<br>この問題では、数百万のセンサからのストリーミングデータをGoogle Cloudに安全に収集し、保存するためのアーキテクチャを設計する方法が求められています。要件は可用性と耐障害性の高さ、およびGoogleが推奨するプラクティスに基づくものである点が重要です。解答を選択する際は、ストリームデータを収集し理解するためのGoogle Cloudのサービス、その他のデータ処理や分析ツールについて考慮しなければなりません。また、構造化データと非構造化データの両方が対象となる点も忘れてはいけません。<br>基本的な概念や原則：<br>Pub/Sub：Google Cloudのリアルタイムメッセージングサービスです。大量のメッセージをリアルタイムに取り扱い、それらを分散化されたサービスやデバイスに瞬時に配信します。<br>Dataflow：Google Cloudのフルマネージドストリームとバッチデータ処理サービスです。大量のデータをリアルタイムに処理し、複雑な計算や変換を行います。<br>Cloud Storage：Google Cloudのオブジェクトストレージサービスです。データを安全に保存し、アクセスすることができます。<br>Storage Transfer Service：大規模なデータ移行を行うためのGoogle Cloudのサービスです。データセンター、Amazon S3、HTTP/HTTPS、Google Cloud Storageなどからのデータ転送を管理して自動化します。<br>BigQuery：Googleのフルマネージドで高度にスケーラブルなエンタープライズデータウェアハウスで、ビジネスインテリジェンスに活用します。<br>TrifactaのDataprep：Google Cloudのビッグデータサービスで、データ前処理を自動化します。<br>Bigtable：Google Cloudの高性能NoSQLデータベースサービスです。大規模なデータ、ミリ秒レベルでのリアルタイムアクセスを支える設計がベースになっています。<br>正解についての説明：<br>（選択肢）<br>・Pub/Subにデータをストリームし、Dataflowを使ってCloud Storageにデータを送信します<br>この選択肢が正解の理由は以下の通りです。<br>まず、IoTアプリケーションのように大量のデータをストリーミングするシチュエーションに適切なサービスがGoogle Pub/Subです。Pub/Subの主要なロールは、大量のデータを効率的にキャプチャし、順序を保持しながら即時性を維持することであり、耐障害性と可用性も非常に高いです。<br>また、Pub/Subはシステム間、サービス間でメッセージを送受信するためのグローバル、リアルタイムのメッセージングサービスであるため、IoTデバイスからのデータストリームを効率的にハンドリングできます。それからそのデータをDataflowに送ります。Dataflowはバッチおよびストリーミングデータの処理に用いられ、データパイプラインの開発と実行を効率的に行うことができます。<br>最後に、データの永続的な保存を行うために、Cloud Storageへデータを送信します。Cloud Storageはスケーラビリティ、データの耐久性、可用性が高く、大量のIoTデータを安全に保存できます。これら3つのサービスの組み合わせにより、大規模なIoTデータストリームを効率的に管理し、保存でき、Googleが推奨するプラクティスに従った解決策です。<br>不正解の選択肢についての説明：<br>選択肢：Pub/Subにデータをストリームし、Storage Transfer Serviceを使ってBigQueryにデータを送信します<br>この選択肢が正しくない理由は以下の通りです。<br>Storage Transfer Serviceはオブジェクトストレージ間の移行用であり、リアルタイムなストリーミングデータのインジェストやトランスフォームには適していません。<br>それに対して、Dataflowはストリーミングデータのリアルタイム処理に適しているため、本ケースに適切です。<br>選択肢：Dataflowにデータをストリームし、TrifactaのDataprepを使ってBigtableにデータを送信します<br>この選択肢が正しくない理由は以下の通りです。<br>まず、Dataflowはデータのストリーム先として使用されるわけではなく、データの加工や変換のために使用されます。<br>また、TrifactaのDataprepはデータクレンジングや変換に使いますが、大量のストリーミングデータの処理には適していません。<br>さらに、最終的にBigtableにデータを保存すると、格納コストが高くなる可能性があります。<br>選択肢：データをDataflowにストリーミングし、Storage Transfer Serviceを使用してデータをBigQueryに送信します<br>この選択肢が正しくない理由は以下の通りです。<br>まず、Dataflowはストリーミングデータの受信を行わず、処理や変換に使用されます。<br>また、Storage Transfer Serviceはデータ転送には適しているものの、ストリーミングデータの取り扱いには適していません。これに対して正解の選択肢では、Pub/Subがストリーミングデータを効率良く受信し、DataflowがそのデータをStorageに移送する役割を担っています。'>
<div class='choice'> Dataflowにデータをストリームし、TrifactaのDataprepを使ってBigtableにデータを送信します</div>
<div class='choice'> Pub/Subにデータをストリームし、Storage Transfer Serviceを使ってBigQueryにデータを送信します</div>
<div class='choice'> Pub/Subにデータをストリームし、Dataflowを使ってCloud Storageにデータを送信します</div>
<div class='choice'> データをDataflowにストリーミングし、Storage Transfer Serviceを使用してデータをBigQueryに送信します</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題7<br>あなたは最近、新しいGoogle Cloudプロジェクトを受け取りました。インスタンスを作成し、ファイアウォールを設定し、データをCloud Storageに保存する必要があります。また、Googleが推奨するプラクティスに従う必要があります。<br>この要件を満たすために、どうすればよいですか？' data-answer='2' data-explanation='解説<br>正解は「Compute Engineを有効にするにはgcloud services enable compute.googleapis.comコマンドを、Cloud Storage APIを有効にするにはgcloud services enable storage-api.googleapis.comコマンドを使用します」です。<br>この問題では、新しいGoogle Cloudプロジェクトを立ち上げて、そのための必要なAPIを有効化する方法が問われています。問題文からは、インスタンスを作成し、ファイアウォールを設定し、データをCloud Storageに保存する必要があることが明示されています。それに加えて、Googleが推奨するプラクティス、すなわち最良の方法に従うことにも注目が必要です。このケースでは、手動で全てのAPIを一つずつ有効化する必要はなく、問題文で提起された特定のサービスに関連するAPIの有効化に集中することが大切です。また、正確なAPIとそれを有効化するための適切なコマンドを理解していることも重要です。<br>基本的な概念や原則：<br>Compute Engine：Google CloudのIaaS（Infrastructure as a Service）で、仮想マシンの作成や運用を行うことができます。<br>Cloud Storage：Google Cloudのオブジェクトストレージサービスで、バイナリデータなどの大量のデータを保存・取得することができます。<br>gcloud CLI：Google Cloudの操作をコマンドラインから行うためのツールです。Google Cloudの各種リソース操作や設定の変更等をコマンドラインから実行することができます。<br>APIの有効化：Google Cloudの各種サービスを使用するためには、それぞれのAPIを有効化する必要があります。これは通常、Google Cloud Consoleから行いますが、gcloud CLIを使用することでコマンドラインからも行うことができます。<br>Google Cloudの推奨するプラクティス：Google Cloudでは、各種ベストプラクティスを提供しています。これらはサービスの効果的な利用やパフォーマンス向上、セキュリティ向上を実現します。<br>Cloud Shell：Google Cloud Console内で利用できる、仮想マシンベースのコマンドラインです。gcloud CLIをはじめとするGoogle Cloudの操作ツールがプリインストールされています。<br>Cloud Resource Manager：Google Cloudのリソースを一元的に管理するためのサービスです。プロジェクトや組織、フォルダなどのリソースを階層的に管理します。<br>正解についての説明：<br>（選択肢）<br>・Compute Engineを有効にするにはgcloud services enable compute.googleapis.comコマンドを、Cloud Storage APIを有効にするにはgcloud services enable storage-api.googleapis.comコマンドを使用します<br>この選択肢が正解の理由は以下の通りです。<br>Google Cloudプロジェクトを始める際には、特定のAPIを有効化することでGoogle Cloudの各サービスを使用できるようになります。ケースによっては、Compute EngineとCloud Storageを有効にする必要があるため、それぞれ適切なAPIを有効化するという手順が必要です。Google Cloudの推奨ベストプラクティスとして、Compute Engineを有効にするには&#39;gcloud services enable compute.googleapis.com&#39;コマンドを、Cloud Storage APIを有効にするには&#39;gcloud services enable storage-api.googleapis.com&#39;コマンドを使用するように指示されています。これにより、Google Cloudプロジェクトの作成者は、Compute EngineとCloud Storageを利用してインスタンスを作成したり、ファイアウォールを設定したり、データをCloud Storageに保存したりすることができます。そのため、この選択肢は要件を満たす正しい手順を示しています。<br>不正解の選択肢についての説明：<br>選択肢：すべてのリソースを有効にするために、gcloud CLI services enable cloudresourcemanager.googleapis.comコマンドを使用します<br>この選択肢が正しくない理由は以下の通りです。<br>cloudresourcemanager.googleapis.comサービスは、Compute EngineやCloud Storageに対するリソース管理を全体的に有効にするものではありません。求められているCompute EngineとCloud Storageを有効にするためには、各サービス固有のAPIを有効にするコマンドを実行する必要があります。それぞれのサービスに対応したAPIを明示的に有効化する行為がGoogle推奨のプラクティスです。<br>選択肢：Google Cloudコンソールを開き、APIダッシュボードからすべてのGoogle Cloud APIを有効にします<br>この選択肢が正しくない理由は以下の通りです。<br>全てのGoogle Cloud APIを有効にする必要はありません。使用するそれぞれのAPIだけを有効にすべきで、Googleの推奨するプラクティスもそのようになっています。不必要に全てを有効にすると、セキュリティ上のリスクや予期せぬ課金が生じる可能性があるためです。<br>選択肢：Google Cloudコンソールを開き、Cloud Shellでgcloud init --projectを実行します<br>この選択肢が正しくない理由は以下の通りです。<br>まず、gcloud init --projectでは特定のプロジェクトを指定してgcloud環境を初期化しますが、Compute EngineやCloud Storage APIを具体的に有効化する設定は含まれていません。<br>したがって、Googleが推奨するプラクティス、つまり、各サービスAPIを明示的に有効化する手順に従っていないため、要件を満たしません。'>
<div class='choice'> Google Cloudコンソールを開き、Cloud Shellでgcloud init --projectを実行します</div>
<div class='choice'> すべてのリソースを有効にするために、gcloud CLI services enable cloudresourcemanager.googleapis.comコマンドを使用します</div>
<div class='choice'> Compute Engineを有効にするにはgcloud services enable compute.googleapis.comコマンドを、Cloud Storage APIを有効にするにはgcloud services enable storage-api.googleapis.comコマンドを使用します</div>
<div class='choice'> Google Cloudコンソールを開き、APIダッシュボードからすべてのGoogle Cloud APIを有効にします</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題8<br>あなたは、Compute Engine上でWindows VMをセットアップしています。この設定において、RDP経由でVMにログインできることを確認したいと考えています。<br>この要件を満たすために、どうすればよいですか？' data-answer='1' data-explanation='解説<br>正解は「VMが作成されたら、gcloud compute reset-windows-passwordを使用してVMのログイン認証情報を取得します」です。<br>この問題では、特定の環境下で、すなわちCompute Engine上でWindows VMをセットアップし、それにRDP経由でログインする方法を問われています。問題文の内容や選択肢をよく読み取り、Compute EngineとWindows VMに関する知識、RDPによるローギングの方法についての理解を活用して最適な方法を選びましょう。選択肢を精査する際には、個々のオプションが課題の解決策として妥当なのか、またはGoogle Cloudのベストプラクティスを遵守しているかどうかを確認しましょう。この観点から見て、適切な認証情報を得るための正しい手順やコマンドを理解することが求められます。<br>基本的な概念や原則：<br>gcloud compute reset-windows-password：Google Cloud SDKのコマンドラインツールの一部です。Windows VMのログイン認証情報をリセットまたは取得するために使用します。<br>Compute Engine：Google Cloudのインフラストラクチャーとしてのサービス（IaaS）です。仮想マシン（VM）をスケーラブルな堅牢性のある方法で稼働させることができます。<br>RDP（Remote Desktop Protocol）：Microsoftが開発したリモートデスクトップ接続のプロトコルです。Windows VMにリモートでログインするために使います。<br>認証情報：システムやサービスにアクセスするための証明書やキー、パスワードなどの情報です。VMの安全な操作に必要です。<br>インスタンスのメタデータ：Compute Engine VMインスタンスに関する情報を保存し、取得するための仕組みです。アクセス許可や設定情報などを保持します。メタデータでパスワードを管理することはセキュリティ上推奨されません。<br>サービスアカウント：Google CloudのAPIやサービスにアクセスするための特別な種類のアカウントです。JSON秘密鍵を使って認証を行いますが、直接のVMログインには使いません。<br>正解についての説明：<br>（選択肢）<br>・VMが作成されたら、gcloud compute reset-windows-passwordを使用してVMのログイン認証情報を取得します<br>この選択肢が正解の理由は以下の通りです。<br>Google CloudにおけるWindows VMの設定では、RDPでのリモートアクセスによりVMの運用が可能となっています。<br>しかし、初回のアクセスにはセキュリティの観点から認証情報の設定が必要です。そのため、VMが作成されたら、gcloud compute reset-windows-passwordコマンドを使用し、新たな認証情報を設定することが求められます。このコマンドを実行すると、ユーザ名と初期パスワードが生成されます。この情報を用いてRDP経由でWindows VMにログインすることができます。<br>したがって、このコマンドを使用することで、RDP経由でのVMアクセスが可能かどうかを確認できます。<br>不正解の選択肢についての説明：<br>選択肢：VMが作成されたら、Googleアカウントの認証情報を使ってVMにログインします<br>この選択肢が正しくない理由は以下の通りです。<br>Google Cloudでは、VMにGoogleアカウントの認証情報を使って直接ログインすることはできません。VMへのアクセスはそれぞれのOSの認証方法に基づいて行われます。例えば、Windows VMの場合、gcloud compute reset-windows-passwordコマンドを使用してVMのログイン認証情報を取得する必要があります。<br>選択肢：VMの作成時に、"windows-password"をキー、パスワードを値としてインスタンスにメタデータを追加します<br>この選択肢が正しくない理由は以下の通りです。<br>VM作成時に"windows-password"をキー、パスワードを値としてメタデータを追加しても、これはCompute EngineがWindows VMのRDPログイン情報として認識しないため正しくありません。正解の選択肢であるgcloud compute reset-windows-passwordコマンドを使用すれば、適切なログイン情報を得られます。<br>選択肢：VMが作成されたら、デフォルトのCompute EngineサービスアカウントのJSON秘密鍵をダウンロードします。JSONファイルの認証情報を使用して、VMにログインします<br>この選択肢が正しくない理由は以下の通りです。<br>Compute EngineサービスアカウントのJSON秘密鍵はAPIの認証に使用されますが、それはVMへのログイン認証とは異なるものです。従って秘密鍵を使ってVMにログインすることはできません。<br>それに対し、gcloud compute reset-windows-passwordコマンドはWindows VMへのログイン用認証情報を生成するため、この場合に適しています。'>
<div class='choice'> VMが作成されたら、デフォルトのCompute EngineサービスアカウントのJSON秘密鍵をダウンロードします。JSONファイルの認証情報を使用して、VMにログインします</div>
<div class='choice'> VMが作成されたら、gcloud compute reset-windows-passwordを使用してVMのログイン認証情報を取得します</div>
<div class='choice'> VMが作成されたら、Googleアカウントの認証情報を使ってVMにログインします</div>
<div class='choice'> VMの作成時に、"windows-password"をキー、パスワードを値としてインスタンスにメタデータを追加します</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題9<br>開発環境を提供するApp Engineアプリケーションのプロジェクトがあります。必要なテストが成功したので、本番環境として使用する新しいプロジェクトを作成したいと考えています。<br>あなたはこの要件を満たすために、どうすればよいですか？' data-answer='2' data-explanation='解説<br>正解は「gcloudを使って新しいプロジェクトを作成し、アプリケーションを新しいプロジェクトにデプロイします」です。<br>この問題では、App Engineアプリケーションを開発環境から本番環境に移行する方法を尋ねています。この要件を満たすためには、どのようにして新しいプロジェクトを作成し、その新しいプロジェクトにアプリケーションをデプロイするかを考える必要があります。選択肢を見る時には、アプリケーションのコピーや移行ではなく、新しいプロジェクトへの適切なデプロイ方法を探すことが必要です。<br>基本的な概念や原則：<br>App Engine：Google Cloudが提供するフルマネージドなサーバレスアプリケーションプラットフォームです。開発者はインフラストラクチャ管理のリソースを開放し、コードに集中することができます。<br>gcloud：Google Cloudのコマンドラインツールです。Google Cloudのプロダクトとサービスの管理や開発を行うためのツールです。<br>プロジェクト：Google Cloudにおけるリソースの最小単位です。プロジェクトを作成して同じ環境を再現することができます。<br>デプロイ：アプリケーションをステージングまたは本番環境に公開するプロセスです。gcloudコマンドラインツールを使用すると、App EngineなどのGoogle Cloudに容易にデプロイすることができます。<br>Deployment Manager：Google Cloudのインフラストラクチャの操作と管理を自動化するツールです。一連のAPIを使用してリソースの作成、更新、削除をスクリプトとして記述し、それらのリソースを一緒に管理します。<br>正解についての説明：<br>（選択肢）<br>・gcloudを使って新しいプロジェクトを作成し、アプリケーションを新しいプロジェクトにデプロイします<br>この選択肢が正解の理由は以下の通りです。<br>Google Cloudは開発環境を本番環境と分離することを容易にするための機能を提供しています。それが新規プロジェクトの作成機能です。そのため、gcloudコマンドラインツールを使用して新しいプロジェクトを作成し、そのプロジェクトにアプリケーションをデプロイするというアプローチは適切です。この方法では、本番環境が開発環境から独立して設定され、運用されます。これにより、それぞれの環境で特定のサービスを有効化したり、予算を設定したりといった運用面での独立性が保証されます。<br>また、開発環境で行った試行錯誤やエラーが本番環境に影響を及ぼす可能性が低減します。<br>したがって、新しいプロジェクトを作成し、それにアプリケーションをデプロイすることはこの問題の正しい解決方法です。<br>不正解の選択肢についての説明：<br>選択肢：gcloudを使用して新しいプロジェクトを作成し、デプロイされたアプリケーションを新しいプロジェクトにコピーします<br>この選択肢が正しくない理由は以下の通りです。<br>App Engineアプリケーションはプロジェクト間で直接コピーできません。コピーではなく、新たにプロジェクトを作成し、アプリケーションをその新プロジェクトにデプロイする操作が必要です。そのため、正解はアプリケーションを新しいプロジェクトにデプロイする、という選択肢になります。<br>選択肢：現在のApp Engineデプロイメントを新しいプロジェクトにコピーするDeployment Manager設定ファイルを作成します<br>この選択肢が正しくない理由は以下の通りです。<br>Deployment Managerはリソースの管理・自動化を行うツールですが、異なるプロジェクト間でのApp Engineアプリケーションのコピーを直接的に行う機能は提供していません。したがって新しいプロジェクト作成とそのプロジェクトにアプリケーションをデプロイするgcloudを使ったアプローチが適切です。<br>選択肢：gcloudを使用してアプリケーションを再度デプロイし、projectパラメータに新しいプロジェクト名を指定して新しいプロジェクトを作成します<br>この選択肢が正しくない理由は以下の通りです。<br>gcloudを使用してアプリケーションを再度デプロイし、projectパラメータで新しいプロジェクト名を指定するとはいえ、これだけでは新しいプロジェクトは作成されません。新しいプロジェクトの作成は明示的に実行する必要があるため、正解の選択肢である新しいプロジェクトを明示的に作成し、その後でアプリケーションをデプロイする手順が必要です。'>
<div class='choice'> gcloudを使用してアプリケーションを再度デプロイし、projectパラメータに新しいプロジェクト名を指定して新しいプロジェクトを作成します</div>
<div class='choice'> gcloudを使用して新しいプロジェクトを作成し、デプロイされたアプリケーションを新しいプロジェクトにコピーします</div>
<div class='choice'> gcloudを使って新しいプロジェクトを作成し、アプリケーションを新しいプロジェクトにデプロイします</div>
<div class='choice'> 現在のApp Engineデプロイメントを新しいプロジェクトにコピーするDeployment Manager設定ファイルを作成します</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題10<br>あなたは、医療画像をオンプレミスのデータルームに保存している病院に勤務しています。この病院は、これらの画像のアーカイブ保存にCloud Storageを使用したいと考えています。病院は、新しい医用画像をCloud Storageにアップロードする自動化プロセスを望んでいるため、ソリューションを設計し、実装する必要があります。<br>この要件を満たすために、どうすればよいですか？' data-answer='1' data-explanation='解説<br>正解は「gsutilコマンドラインインターフェースを使用して、オンプレミスのストレージとCloud Storageを同期するスクリプトを作成します。スクリプトをcronジョブとしてスケジュールします」です。<br>この問題では、オンプレミスの医療画像をGoogle Cloud Storageに自動的にアーカイブする方法を問われています。要件から、新しい医用画像のアップロードを自動化する必要があることが明確に示されています。各選択肢を慎重に評価することが重要で、その中で最も適合する自動化ツールやサービスを選ぶことが問題解決の鍵です。この際、選択肢がGoogle Cloudのさまざまなサービスに関係しており、それぞれのサービスの目的と機能について理解していることが必要不可欠です。<br>基本的な概念や原則：<br>Cloud Storage：Google Cloudのオブジェクトストレージサービスです。大量のデータを安全に保存し、全世界からアクセスすることができます。<br>gsutilコマンドラインインターフェース：Google Cloud Storageとやり取りするためのコマンドラインツールです。データのアップロード、ダウンロード、管理などが可能です。<br>cronジョブ：定期的なタスクを自動化するためのUNIX系システムのツールです。指定した時間に指定したコマンドを実行します。<br>Cloud Pub/Sub：Google Cloudのリアルタイムメッセージングサービスです。大量のメッセージを処理し、離れたシステム間でデータを送受信することができます。メッセージのパブリッシュとサブスクライブが可能です。<br>Cloud Dataflow：Google Cloudのストリームとバッチデータを処理するためのフルマネージドサービスです。Dataflowはパイプラインモデルを使用し、大量のデータを効率的に処理します。<br>Cloud Console：Google Cloudのリソースとアプリケーションを管理するためのウェブベースのインターフェースです。バケットの作成やデータのアップロードなどの操作が可能です。<br>正解についての説明：<br>（選択肢）<br>・gsutilコマンドラインインターフェースを使用して、オンプレミスのストレージとCloud Storageを同期するスクリプトを作成します。スクリプトをcronジョブとしてスケジュールします<br>この選択肢が正解の理由は以下の通りです。<br>まず、gsutilはGoogle Cloud Storageのコマンドラインツールであり、オンプレミスからCloud Storageへのデータの移行を簡単に行うことができます。このツールを使用してスクリプトを作成することで、新しい医用画像を自動的にアップロードするプロセスを作成することができます。<br>また、このスクリプトをcronジョブとしてスケジュールすると、設定した間隔で一定のタスクを自動的に実行することができます。この場合、新規に追加された医療画像を定期的にアップロードするタスクを繰り返し実行するよう設定することで、オンプレミスのストレージとCloud Storageが同期されるようになります。これにより、病院の要求する、新しい医用画像のアップロードを自動化するソリューションが実現します。<br>したがって、この選択肢が最適な解答です。<br>不正解の選択肢についての説明：<br>選択肢：Pub/Subトピックを作成し、Pub/SubトピックのCloud Storageトリガーを有効にします。すべての医療画像をPub/Subトピックに送信するアプリケーションを作成します<br>この選択肢が正しくない理由は以下の通りです。<br>Pub/SubとCloud Storageトリガーを使用すると、Cloud上のストレージ変更を監視して非同期メッセージングやイベント駆動処理が可能ですが、オンプレミスの変更を監視する機能は提供していません。<br>したがって、オンプレミスの医療画像を自動的にアップロードする要件を満たすことができません。<br>一方、gsutilとcronを使用することで、オンプレミスのストレージとCloud Storageとを定期的に同期し、新しい画像のアップロードを自動化することができます。<br>選択肢：バッチテンプレート"Datastore to Cloud Storage"からDataflowジョブをデプロイします<br>この選択肢が正しくない理由は以下の通りです。<br>Datastore to Cloud Storageのバッチテンプレートは、Cloud DatastoreのエンティティをCloud Storageにエクスポートするためのもので、オンプレミスの医用画像データをCloud Storageに自動的にアップロードする目的には適していません。正解の選択肢であるgsutilとcronジョブを用いることで、自動化された定期的なファイル同期が可能です。<br>選択肢：Cloud Consoleで、Cloud Storageに移動します。該当する画像を適切なバケットにアップロードします<br>この選択肢が正しくない理由は以下の通りです。<br>ステートメントは自動化プロセスを求めていますが、この選択肢は手動でCloud Consoleを使用してアップロードする方法を提案しています。これは、大量の医用画像を継続的にアップロードするための効率的または自動化されたソリューションではありません。'>
<div class='choice'> Pub/Subトピックを作成し、Pub/SubトピックのCloud Storageトリガーを有効にします。すべての医療画像をPub/Subトピックに送信するアプリケーションを作成します</div>
<div class='choice'> gsutilコマンドラインインターフェースを使用して、オンプレミスのストレージとCloud Storageを同期するスクリプトを作成します。スクリプトをcronジョブとしてスケジュールします</div>
<div class='choice'> Cloud Consoleで、Cloud Storageに移動します。該当する画像を適切なバケットにアップロードします</div>
<div class='choice'> バッチテンプレート"Datastore to Cloud Storage"からDataflowジョブをデプロイします</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題11<br>あるアプリケーションの開発環境をプロジェクトに作成しました。このアプリケーションはCompute EngineとCloud SQLを使用します。次に、このアプリケーションの本番環境を作成する必要があります。セキュリティチームは、この2つの環境間のネットワーク経路の存在を禁止しており、Googleが推奨するプラクティスに従うように求めています。<br>この要件を満たすために、どうすればよいですか？' data-answer='1' data-explanation='解説<br>正解は「新しいプロジェクトを作成し、そのプロジェクトでCompute EngineとCloud SQL APIを有効にし、開発環境で作成したセットアップを複製します」です。<br>この問題では、開発環境と本番環境の二つの環境を作成し、それぞれが使用するCompute EngineとCloud SQL間のネットワーク経路を分離する方法が求められています。開発環境と本番環境の間にネットワーク経路が存在しないようにするために、明確に分離されたプロジェクトまたはリソースを作成することが重要です。また、Googleが推奨するプラクティスを遵守する必要があります。したがって、プロジェクトの分離をいかに効果的に実行するかが鍵です。<br>基本的な概念や原則：<br>Compute Engine：Google Cloud上で仮想マシンを動作させる基盤となるサービスです。使い方に応じたカスタマイズが可能です。<br>Cloud SQL：Google Cloud上で完全マネージドのリレーショナルデータベースサービスを提供します。MySQL、PostgreSQL、SQL Serverのインスタンスを作成・運用することができます。<br>プロジェクト：Google Cloud上でリソースを理論的にまとめる単位です。各プロジェクトは独立したネットワーキング環境を持ちます。<br>セキュリティチームの要件：セキュリティ部門が設定するITシステムのセキュリティポリシーの1つです。ネットワーク間の通信の制限など、システムのセキュリティを高めるためのガイドラインを含みます。<br>VPC（Virtual Private Cloud）：Google Cloud上で利用可能な仮想プライベートネットワークです。ユーザー自身でネットワークアドレッシングやルーティングを設定できます。<br>Shared VPC：複数のプロジェクト間でVPCを共有する機能です。ネットワークリソースの集中管理やセキュリティ強化に役立ちますが、他のプロジェクトとの通信がデフォルトで可能になるため注意が必要です。<br>プロジェクトEditorロール：Google Cloud IAMで利用可能なロールの一つで、プロジェクト内のほぼ全てのリソースに対して読み書き権限を有します。この役割を持つユーザーはプロジェクト内でほぼ全ての操作が可能です。<br>正解についての説明：<br>（選択肢）<br>・新しいプロジェクトを作成し、そのプロジェクトでCompute EngineとCloud SQL APIを有効にし、開発環境で作成したセットアップを複製します<br>この選択肢が正解の理由は以下の通りです。<br>Google Cloudでは、プロジェクトという概念を使用してリソースをグループ化し、その各グループの間でのネットワーク接続を制限することができます。プロジェクトを別々に作成することで、その中のリソースが同一のネットワークスペース内に存在する保証があり、それぞれのプロジェクト間ではデフォルトで直接的なネットワーク接続、つまりネットワーク経路の存在が許可されていません。したがってセキュリティ上の要件が満たされます。<br>また、開発環境と同じ設定を本番環境にも反映したいのであれば、開発環境で作成したセットアップを新しいプロジェクトに複製することが最も合理的なアプローチです。これにより要件を満たしつつ、開発と本番環境の構成差を最小限に保つことができます。これらの理由から、新しいプロジェクトを作成し、そのプロジェクトでCompute EngineとCloud SQL APIを有効にし、開発環境で作成したセットアップを複製することが、セキュリティチームの要求とGoogleの推奨プラクティスに従った最適な解決策です。<br>不正解の選択肢についての説明：<br>選択肢：既存のVPCに新しい本番用サブネットを作成し、既存のプロジェクトに新しい本番用Cloud SQLインスタンスを作成し、これらのリソースを使用してアプリケーションをデプロイします<br>この選択肢が正しくない理由は以下の通りです。<br>セキュリティチームが開発環境と本番環境間のネットワーク経路の存在を禁止している条件を満たすためには同じプロジェクト内に本番環境を作成するという選択肢は適切でありません。Googleの推奨するプラクティスは、開発環境と本番環境を異なるプロジェクトで分けることであり、これにより環境間でのネットワーク接続を遮断することができます。<br>選択肢：新しいプロジェクトを作成し、既存のVPCをShared VPCに変更し、そのVPCを新しいプロジェクトと共有します<br>この選択肢が正しくない理由は以下の通りです。<br>Shared VPCを使用すると、開発環境と本番環境が同じネットワークを共有することになります。<br>しかし、セキュリティチームはこの2つの環境間のネットワーク経路の存在を禁止しているので、この選択肢は要件を満たしません。<br>選択肢：セキュリティチームに、あなたの会社の別の部署で使われている既存の本番プロジェクトで、あなたにプロジェクトEditorロールを与えるよう依頼します。そのロールを許可してもらったら、開発環境でのセットアップをそのプロジェクトで再現します<br>この選択肢が正しくない理由は以下の通りです。<br>別の部署が使用する本番プロジェクトにセットアップを再現すると、ネットワーク経路が存在する可能性があり、セキュリティチームの要件を満たしません。<br>また、Googleが推奨するプラクティスは、開発環境と本番環境を異なるプロジェクトで分けることです。'>
<div class='choice'> 新しいプロジェクトを作成し、既存のVPCをShared VPCに変更し、そのVPCを新しいプロジェクトと共有します</div>
<div class='choice'> 新しいプロジェクトを作成し、そのプロジェクトでCompute EngineとCloud SQL APIを有効にし、開発環境で作成したセットアップを複製します</div>
<div class='choice'> 既存のVPCに新しい本番用サブネットを作成し、既存のプロジェクトに新しい本番用Cloud SQLインスタンスを作成し、これらのリソースを使用してアプリケーションをデプロイします</div>
<div class='choice'> セキュリティチームに、あなたの会社の別の部署で使われている既存の本番プロジェクトで、あなたにプロジェクトEditorロールを与えるよう依頼します。そのロールを許可してもらったら、開発環境でのセットアップをそのプロジェクトで再現します</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題12<br>あなたの会社では、何人かの社員がGoogle Cloudを使ってプロジェクトを作成し、その費用を個人のクレジットカードで支払っています。会社は、これらすべてのプロジェクトを単一の新しい請求アカウントに一元化したいと考えています。<br>この要件を満たすために、どうすればよいですか？' data-answer='2' data-explanation='解説<br>正解は「Google Cloud Consoleで、新しい課金アカウントを作成し、支払い方法を設定します」です。<br>この問題では、プロジェクトの課金に関する状況を理解し、その上でどのように効率的な課金管理を実現するかを理解する必要があります。個々のプロジェクトが異なる方法で支払われ、会社が一元的な課金管理を望んでいるので、これを達成するために適切なGoogle Cloudの機能や構成を選択することが求められています。選択肢が示す具体的な手順や方法の中で、安全で効率的な課金管理を可能にするものを見つけることが求められています。<br>基本的な概念や原則：<br>Google Cloud Console：Google Cloudの全サービスを管理するためのWebベースのインターフェースです。新たな課金アカウントの作成や既存のリソースの管理等が可能です。<br>課金アカウント：Google Cloud利用料などの請求を管理するためのアカウントです。特定のプロジェクトに課金アカウントを紐づけることで、請求管理を一元化することができます。<br>支払い方法の設定：Google Cloud Consoleから課金アカウントに支払い方法（クレジットカード等）を紐づけることができます。これにより課金アカウントを通してのGoogle Cloud利用料などの支払いが可能です。<br>Resource Manage：Google Cloudのリソースを管理するための機能です。しかし、課金管理に直接関わるものではありません。<br>Organization：複数のGoogle Cloudプロジェクトやリソースを組織的に管理するための単位です。Organizationは課金管理だけでなく、リソースやIAMの一元管理等にも利用されます。<br>正解についての説明：<br>（選択肢）<br>・Google Cloud Consoleで、新しい課金アカウントを作成し、支払い方法を設定します<br>この選択肢が正解の理由は以下の通りです。<br>Google Cloudでは、請求アカウントを使用してプロジェクトの費用を管理することができます。新しい請求アカウントを作成し、支払い情報を設定することで、各プロジェクトの請求情報を一元化できます。具体的には、Google Cloud Consoleにログインし、新しい請求アカウントを作成し、必要な支払い情報を設定します。<br>その後、既存の各プロジェクトをこの新しい請求アカウントに関連付けることで、すべてのプロジェクトの課金を一元管理することが可能になります。これにより、個々のプロジェクトオーナーが個々に費用管理を行う必要がなくなり、企業全体での費用管理が効率化されます。<br>不正解の選択肢についての説明：<br>選択肢：cloud-billing@google.comに銀行口座の詳細をご連絡の上、法人用の請求書発行口座をご指定ください<br>この選択肢が正しくない理由は以下の通りです。<br>Google Cloudの請求アカウントの設定はユーザー側で行います。特定のメールアドレスに銀行口座の詳細を送るという手段は提供されていません。Google Cloud Consoleで新しい課金アカウントを作成し、支払い方法を設定するのが適切な手順です。<br>選択肢：Googleサポートにチケットを作成し、電話を待ってクレジットカード情報を電話で共有します<br>この選択肢が正しくない理由は以下の通りです。<br>Googleサポートにチケットを作成し、電話でクレジットカード情報を共有することは、Google Cloudの請求アカウント設定の正規の手順ではありません。請求アカウントの一元化は、Google Cloud Consoleで直接行うべきであり、クレジットカード情報は直接コンソールに入力されます。<br>選択肢：Google Platform Consoleで、Resource Manageに移動し、すべてのプロジェクトをルートのOrganizarionに移動します<br>この選択肢が正しくない理由は以下の通りです。<br>プロジェクトをルートのOrganizationに移動するだけでは、請求アカウントの一元化は実現できません。請求の一元化を行うには、まず、新しい課金アカウントを作成し、支払い方法を設定し、そのアカウントに全プロジェクトを紐付ける必要があります。'>
<div class='choice'> cloud-billing@google.comに銀行口座の詳細をご連絡の上、法人用の請求書発行口座をご指定ください</div>
<div class='choice'> Google Platform Consoleで、Resource Manageに移動し、すべてのプロジェクトをルートのOrganizarionに移動します</div>
<div class='choice'> Google Cloud Consoleで、新しい課金アカウントを作成し、支払い方法を設定します</div>
<div class='choice'> Googleサポートにチケットを作成し、電話を待ってクレジットカード情報を電話で共有します</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題13<br>あなたは、まだ存在しない新しいプロジェクトにCompute Engineインスタンスを作成する必要があります。<br>この要件を満たすために、どうすればよいですか？' data-answer='2' data-explanation='解説<br>正解は「Cloud SDKを使用して、新しいプロジェクトを作成し、そのプロジェクトでCompute Engine APIを有効にし、新しいプロジェクトを指定してインスタンスを作成します」です。<br>この問題では、新しく作成されるプロジェクトにCompute Engineインスタンスを作成する方法を問います。まず、存在しないプロジェクトを作成する手段と、APIの有効化、そしてインスタンスの作成の手順の順序に着目することが大事です。選択肢にはCloud SDKやCloud Consoleなど異なるツールが提示されていますが、それらをどのように組み合わせて利用するかが鍵です。また、Compute Engine APIが新しいプロジェクトで有効化され、その上でインスタンスが作成されることを確認することが必要です。<br>基本的な概念や原則：<br>Cloud SDK：Google Cloudのリソースを操作するためのコマンドラインツールです。リソースの作成、更新、削除など、ほぼすべての操作を行うことができます。<br>Compute Engine：Google Cloudが提供する仮想マシンインスタンスのサービスです。計算処理に必要なインスタンスを自由な設定で作成することができます。<br>Compute Engine API：Compute Engineのインスタンスやその他のリソースを操作するためのAPIです。このAPIを有効にすることで、プログラムからCompute Engineのリソースを制御することができます。<br>Cloud Console：Google Cloudのリソースを視覚的に操作するためのウェブインターフェースです。Compute Engineのインスタンスの作成や操作など、主要な処理が行えます。<br>プロジェクト：Google Cloudでリソースを分離、管理するための単位です。各プロジェクトは独立した設定やリソースを持つことができます。<br>APIの有効化：特定のサービスを利用するために、そのサービスのAPIを有効にする必要があります。APIが有効でないと、そのサービスは利用できません。<br>正解についての説明：<br>（選択肢）<br>・Cloud SDKを使用して、新しいプロジェクトを作成し、そのプロジェクトでCompute Engine APIを有効にし、新しいプロジェクトを指定してインスタンスを作成します<br>この選択肢が正解の理由は以下の通りです。<br>Google Cloud SDKはGoogle Cloudのインフラストラクチャを操作したり、プロジェクトを管理したりするための開発ツールキットです。まず、新しいプロジェクトを作成するためにはCloud SDKを使用するのが適しています。<br>次に、Compute Engineを使うためにはそれに対応するAPIをプロジェクトで有効にする必要があります。これもCloud SDKで行うことができます。<br>そして最後に、あらかじめ指定したプロジェクトに対してCompute Engineのインスタンスを作成できます。この選択肢が正解となるのは、ここで述べたCompute Engineを使用するための手順を全て網羅しています。<br>不正解の選択肢についての説明：<br>選択肢：Cloud ConsoleでCompute Engine APIを有効にし、Cloud SDKを使用してインスタンスを作成し、-projectフラグを使用して新しいプロジェクトを指定します<br>この選択肢が正しくない理由は以下の通りです。<br>プロジェクトを作成する前にCloud ConsoleでCompute Engine APIを有効にすることはできません。存在するプロジェクトに対してのみAPIを有効にできます。<br>また、-projectフラグを使用しても既存のプロジェクトのみ指定可能であり、まだ存在しない新しいプロジェクトを指定することはできません。<br>選択肢：Cloud SDKを使用して新しいインスタンスを作成し、-projectフラグを使用して新しいプロジェクトを指定します。Cloud SDKからCompute Engine APIを有効にするようプロンプトが表示されたら、yesと答えます<br>この選択肢が正しくない理由は以下の通りです。<br>新しいプロジェクトが既に存在する前提で進めていますが、問題文には"まだ存在しない新しいプロジェクト"にCompute Engineインスタンスを作成する必要があります。そのため、新しいプロジェクトの作成を含む操作が必要で、その操作が不正解の選択肢には含まれていません。<br>選択肢：Cloud ConsoleでCompute Engine APIを有効にします。ConsoleのCompute Engineセクションに移動して新しいインスタンスを作成し、作成フォームでCreate In A New Projectオプションを探します<br>この選択肢が正しくない理由は以下の通りです。<br>Compute Engineのインスタンス作成フォームでは、新しいプロジェクトを作成するオプションは提供されていません。プロジェクトは先に作成してから、そのプロジェクト内でインスタンスを作成する必要があります。これが正解の選択肢に記載されている手順です。'>
<div class='choice'> Cloud ConsoleでCompute Engine APIを有効にします。ConsoleのCompute Engineセクションに移動して新しいインスタンスを作成し、作成フォームでCreate In A New Projectオプションを探します</div>
<div class='choice'> Cloud ConsoleでCompute Engine APIを有効にし、Cloud SDKを使用してインスタンスを作成し、-projectフラグを使用して新しいプロジェクトを指定します</div>
<div class='choice'> Cloud SDKを使用して、新しいプロジェクトを作成し、そのプロジェクトでCompute Engine APIを有効にし、新しいプロジェクトを指定してインスタンスを作成します</div>
<div class='choice'> Cloud SDKを使用して新しいインスタンスを作成し、-projectフラグを使用して新しいプロジェクトを指定します。Cloud SDKからCompute Engine APIを有効にするようプロンプトが表示されたら、yesと答えます</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題14<br>あなたは、新しい仮想プライベートクラウド（VPC）とリモートサイト間の堅牢な仮想プライベートネットワーク（VPN）接続を構築するよう求められています。主な要件には、動的ルーティング、10.19.0.1/22の共有アドレス空間、フェイルオーバー時のトンネルのオーバープロビジョニングが含まれます。あなたはGoogleが推奨するプラクティスに従って、高可用性のCloud VPNをセットアップしたいと考えています。<br>この要件を満たすために、どうすればよいですか？' data-answer='2' data-explanation='解説<br>正解は「カスタムモードのVPCネットワークを使用し、Cloud Routerのボーダーゲートウェイプロトコル（BGP）ルートを使用し、アクティブ/パッシブルーティングを使用します」です。<br>この問題では、Google CloudのVPCとVPNを用いて高可用性を持つネットワーク接続を設計する必要があります。問題文から、動的ルーティングや特定のアドレス空間の要求、フェイルオーバー時のオーバープロビジョニングなど、具体的な要件が示されています。これらの要件を満たしつつ、Googleが推奨するベストプラクティスに従うべき解決策を選択することが求められています。ネットワークの設定方法（カスタムモードまたは自動モード）、ルーティングの方式（BGPルート、スタティックルート、ポリシーベースのルーティング）、そしてルーティングのモード（アクティブ/パッシブ、アクティブ/アクティブ）などの選択肢から最適な組み合わせを選ぶことが課題です。<br>基本的な概念や原則：<br>仮想プライベートクラウド（VPC）：Google Cloudの仮想ネットワーク機能で、完全にプログラマブルなユーザ定義のネットワーク空間を提供します。<br>仮想プライベートネットワーク（VPN）：公開されたインターネットとは異なり、安全な接続を提供するプライベートなネットワークです。<br>カスタムモードVPC：Google Cloudで提供されるカスタムIP範囲を設定できるVPCモデルです。ネットワークのアドレス空間をより具体的に制御したい場合に使用します。<br>Cloud Router：Google Cloudのネットワークルーティング制御機能で、ボーダーゲートウェイプロトコル（BGP）をサポートします。<br>ボーダーゲートウェイプロトコル（BGP）：インターネットのルーティングを制御する主要なプロトコルで、動的ルーティングの一部を形成します。<br>アクティブ/パッシブルーティング：一方のルーター（アクティブ）がネットワークのすべてのトラフィックを処理し、他方のルーター（パッシブ）がフェイルオーバー時に働く方式。<br>オーバープロビジョニング：システムの過負荷や障害が発生した際に備えて、必要なトンネル以上のリソース（ここではVPN接続）をアサインすることです。<br>正解についての説明：<br>（選択肢）<br>・カスタムモードのVPCネットワークを使用し、Cloud Routerのボーダーゲートウェイプロトコル（BGP）ルートを使用し、アクティブ/パッシブルーティングを使用します<br>この選択肢が正解の理由は以下の通りです。<br>まず、最初にカスタムモードのVPCネットワークを使用するという選択は、ネットワークのアドレス空間を完全に制御したいという要件を満たすためです。カスタムモードVPCでは、任意の範囲のIPアドレスを設定可能であり、これにより要件で指定されている10.19.0.1/22の共有アドレス空間を制御できます。<br>次に、Cloud Routerのボーダーゲートウェイプロトコル（BGP）ルートを使用するという選択は、動的ルーティング要件を満たします。BGPは、VPN接続で主に使用される動的ルーティングプロトコルであり、ネットワーク上の最適なルートを自動的に判断し、パケットの転送を効率化します。<br>最後に、アクティブ/パッシブルーティングを使用すると、フェイルオーバー時にトンネルのオーバープロビジョニングを達成することができます。アクティブ/パッシブルーティングでは、1つのトンネルがアクティブで他のトンネルがパッシブ（スタンバイ）状態です。<br>したがって、アクティブなトンネルが何らかの理由で利用できなくなった場合、パッシブのトンネルが即座にアクティブとなり通信を引き継ぐことができます。<br>これらの選択により、堅牢で高可用性のVPN接続が構築でき、その結果、要件をしっかりと満たすことができます。<br>不正解の選択肢についての説明：<br>選択肢：カスタムモードのVPCネットワークを使用し、スタティックルートを設定し、アクティブ/パッシブルーティングを使用します<br>この選択肢が正しくない理由は以下の通りです。<br>スタティックルートを使用すると、動的ルーティングの要件を満たすことができません。動的ルーティングは、ネットワークの変更を自動的に検出し反映する能力を持っていますが、スタティックルートはそうした機能を持っていません。<br>選択肢：自動モードのVPCネットワークを使用し、スタティックルートを設定し、アクティブ/アクティブルーティングを使用します<br>この選択肢が正しくない理由は以下の通りです。<br>自動モードのVPCネットワークは特定の範囲のアドレス空間を自動的に設定しますが、要件は特定のアドレス空間（10.19.0.1/22）を要求しています。<br>また、スタティックルートは動的ルーティングをサポートせず、要件が動的ルーティングを求めているため誤りです。<br>さらに、アクティブ/アクティブルーティングはフェイルオーバーのオーバープロビジョニングをサポートしないため、要件を満たしません。<br>選択肢：自動モードのVPCネットワークを使用し、Cloud Routerのボーダーゲートウェイプロトコル（BGP）ルートを使用し、ポリシーベースのルーティングを設定します<br>この選択肢が正しくない理由は以下の通りです。<br>自動モードのVPCネットワークはサブネット作成を自動化しますが、必要なアドレス空間10.19.0.1/22を指定するにはカスタムモードが必要です。<br>また、ポリシーベースのルーティングでは動的ルーティングやオーバープロビジョニングがサポートされていません。対して正解では、カスタムモードのVPCとアクティブ/パッシブルーティングを用いることで要件を満たします。'>
<div class='choice'> カスタムモードのVPCネットワークを使用し、スタティックルートを設定し、アクティブ/パッシブルーティングを使用します</div>
<div class='choice'> 自動モードのVPCネットワークを使用し、Cloud Routerのボーダーゲートウェイプロトコル（BGP）ルートを使用し、ポリシーベースのルーティングを設定します</div>
<div class='choice'> カスタムモードのVPCネットワークを使用し、Cloud Routerのボーダーゲートウェイプロトコル（BGP）ルートを使用し、アクティブ/パッシブルーティングを使用します</div>
<div class='choice'> 自動モードのVPCネットワークを使用し、スタティックルートを設定し、アクティブ/アクティブルーティングを使用します</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題15<br>あなたは、Google Kubernetes Engineクラスターをセットアップしたいと考えています。クラスターには検証可能なノードのIDと整合性が必要で、ノードはインターネットからのアクセスができないようにする必要があります。また、クラスターの管理にかかる運用コストを削減したいので、Googleが推奨するプラクティスに従いたいと考えています。<br>この要件を満たすために、どうすればよいですか？' data-answer='3' data-explanation='解説<br>正解は「プライベートオートパイロットクラスターを展開します」です。<br>この問題では、GKEクラスターの設定と管理に関連する特定の要件を満たす必要があります。要件には、ノードの認証可能なIDと整合性、インターネットからのアクセスの防止、そして運用コストの削減が含まれています。また、Googleが推奨するプラクティスに従うことが求められています。これらの要素全てを考慮に入れて選択肢を評価することが重要です。選択肢の中には類似したオプションもあるので、各選択肢が問題の要件をどのように満たすか、また満たさないかを理解することが重要です。<br>基本的な概念や原則：<br>プライベートオートパイロットクラスター：Google Kubernetes Engineで提供されるモードで、Googleがクラスターコンポーネントの管理とライフサイクルを担当します。ノードは外部からのアクセスを制限し、検証可能なノードのIDと整合性を維持します。<br>Google Kubernetes Engine：Google CloudのマネージドKubernetesサービスです。Kubernetesクラスターの設定、運用、スケーリングを容易に行うことができます。<br>プラクティス：試行錯誤や経験から得られた最良の手法や原則のことです。ここでは、Google Cloudの高度な機能を活用して効率的で安全なKubernetes運用を目指すことを指します。<br>シールドノード：ノードのIDと整合性を検証可能にする設定です。ノードが改ざんされることを防ぎ、セキュリティを強化します。<br>パブリックオートパイロットクラスター：公開されているオートパイロットモードのクラスターです。しかし、ここでは不適切な選択肢とされています。ノードが外部からアクセス可能となるため、セキュリティ要件を満たすことができません。<br>正解についての説明：<br>（選択肢）<br>・プライベートオートパイロットクラスターを展開します<br>この選択肢が正解の理由は以下の通りです。<br>まず、プライベートオートパイロットクラスターを使用すると、Google Kubernetes Engine（GKE）の運用作業の大部分をGoogleに委任できます。これにより、管理作業についてのオーバーヘッドが大幅に減少し、運用コストを削減できます。これはGoogleが推奨するプラクティスに従うための一部です。<br>次に、プライベートクラスターとして展開されるため、ノードはデフォルトでインターネットに公開されないように設定されます。これにより、ノードへの不要なアクセスを防ぐことができます。<br>加えて、IDと整合性については、GKEのクラスターの整合性設定と、Google CloudのIDプロバイダーを通じて検証することができます。そのため、総合的に見ると、プライベートオートパイロットクラスターを展開する選択肢は、多くの要件を満たし、優れた選択です。<br>不正解の選択肢についての説明：<br>選択肢：パブリックオートパイロットクラスターをデプロイします<br>この選択肢が正しくない理由は以下の通りです。<br>パブリックオートパイロットクラスターはノードがインターネットからアクセスできる設定ですが、問題の要件ではクラスターのノードはインターネットからのアクセスができないようにすると指定されています。そのため、この選択肢は要件を満たしていません。<br>それに対して、プライベートオートパイロットクラスターはノードがインターネットからアクセスできない設定であるため、要件を満たす適切な選択です。<br>選択肢：標準的なパブリッククラスターをデプロイし、シールドノードを有効にします<br>この選択肢が正しくない理由は以下の通りです。<br>標準的なパブリッククラスターをデプロイすると、ノードがインターネットにアクセス可能となってしまうため、ノードへのインターネットアクセスを制限するこの設問の要件を満たしません。<br>それに対して、プライベートオートパイロットクラスターを展開すると、Googleがクラスターの運用管理を受け持つため運用コストを削減でき、クラスターノードはデフォルトでプライベート接続となるため要件を満たします。<br>選択肢：標準的なプライベートクラスターをデプロイし、シールドノードを有効にします<br>この選択肢が正しくない理由は以下の通りです。<br>標準的なプライベートクラスターをデプロイし、シールドノードを有効にする選択肢は、ノードのIDと整合性の検証を提供する一方で、クラスターの管理にかかる運用コストの削減にはつながらなりません。<br>一方で、プライベートオートパイロットクラスターを展開すると、Googleがクラスターの管理を行うことになり、要求された運用コストの削減を実現します。'>
<div class='choice'> パブリックオートパイロットクラスターをデプロイします</div>
<div class='choice'> 標準的なパブリッククラスターをデプロイし、シールドノードを有効にします</div>
<div class='choice'> 標準的なプライベートクラスターをデプロイし、シールドノードを有効にします</div>
<div class='choice'> プライベートオートパイロットクラスターを展開します</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題16<br>あなたの組織には3つの既存のGoogle Cloudプロジェクトがあります。マーケティング部門に、そのグループ内の新しいイニシアチブのためのGoogle Cloudサービスのみを請求する必要があります。<br>あなたはこの要件を満たすために、どうすればよいですか？' data-answer='1' data-explanation='解説<br>正解は「1.組織のGoogle Cloudプロジェクトで、マーケティング部門の請求管理者IAMロールが割り当てられていることを確認します<br>2.新しいプロジェクトをMarketing Billing Accountにリンクします」です。<br>この問題では、Google Cloudプロジェクトにおける請求管理について問われています。マーケティング部門の新しいイニシアチブのためのGoogle Cloudサービスの請求を分けるための最適な方法を選択することが求められており、その際にIAM（Identity and Access Management）のロールと請求アカウントのリンクについて理解していなければなりません。具体的には、どのようなIAMロールが割り当てられているか、それぞれのGoogle Cloudプロジェクトがどのように請求アカウントにリンクされているかを把握することが重要です。<br>基本的な概念や原則：<br>Google Cloudプロジェクト：Google Cloudリソースのグループ化や管理、アクセス制御、請求に使用されるエンティティです。<br>請求アカウント：Google Cloudのリソースの利用費を管理および支払うための方法です。請求アカウントは一つ以上のプロジェクトにリンクできます。<br>請求管理者IAMロール：請求アカウントに関する管理操作を実行する権限を持つロールです。請求関連の操作が可能ですが、組織全体の管理権限（組織管理者）とは異なります。<br>組織管理者IAMロール：組織全体のIAMポリシーを管理する権限を持つロールです。組織全体のリソースに対する操作が可能になりますが、特定の請求操作は制限される場合があります。<br>プロジェクトラベル：Google Cloudリソースに追加できるメタデータです。リソースの管理や請求を分析する際に役立ちますが、プロジェクトに自動的に請求を割り当てるわけではありません。<br>正解についての説明：<br>（選択肢）<br>・1.組織のGoogle Cloudプロジェクトで、マーケティング部門の請求管理者IAMロールが割り当てられていることを確認します<br>2.新しいプロジェクトをMarketing Billing Accountにリンクします<br>この選択肢が正解の理由は以下の通りです。<br>まず、Google Cloudでは、請求に対するコントロールと透明性を提供するために、IAM（Identity and Access Management）ロールを使用して特定のユーザーに請求管理権限を付与することができます。この設定によりマーケティング部門は自分たちの請求データについての全体的な管理権限を持つことができます。<br>そして、新しく開始されるイニシアチブに対するコストを隔離し、それに対してのみ請求されるようにするために、新たに開始したイニシアチブのための新しいプロジェクトを作成し、それをマーケティング部門の請求アカウントにリンクすることで実現します。これにより、マーケティング部門がそのグループ内の新しいイニシアチブのためだけに請求され、他のプロジェクトの費用と混同されることがなくなります。これらの理由から、この選択肢は最も適切な解決策を提供します。<br>不正解の選択肢についての説明：<br>選択肢：1.組織のGoogle Cloudアカウントに請求管理者IAMロールが割り当てられていることを確認します<br>2.マーケティング部門の新しいGoogle Cloudプロジェクトを作成します<br>3.このプロジェクト内のすべてのサービスについて、デフォルトのキーバリュープロジェクトラベルをdepartment:marketingに設定します<br>この選択肢が正しくない理由は以下の通りです。<br>デフォルトのキーバリュープロジェクトラベルを設定しても、請求を別々にすることは不可能です。請求の整理と管理はアカウントレベルで何を使っているかではなく、各プロジェクトがどの請求アカウントにリンクされているかによって制御されます。<br>選択肢：1.組織のGoogle Cloudアカウントに組織管理者IAMロールが割り当てられていることを確認します<br>2.マーケティング部門の新しいGoogle Cloudプロジェクトを作成します<br>3.新しいプロジェクトをMarketing Billing Accountにリンクします<br>この選択肢が正しくない理由は以下の通りです。<br>新規プロジェクトを作成すると全体の管理が複雑になり、既存プロジェクトのリソースを無駄にする可能性があるためです。<br>また、請求に関してはIAMロールでコントロールするのが一般的であり、組織管理者IAMロールの割り当ては適切な策ではありません。<br>選択肢：1.組織のGoogle Cloudアカウントに組織管理者IAMロールが割り当てられていることを確認します<br>2.マーケティング部門の新しいGoogle Cloudプロジェクトを作成します<br>3.このプロジェクト内のすべてのサービスについて、デフォルトのキーバリュープロジェクトラベルをdepartment:marketingに設定します<br>この選択肢が正しくない理由は以下の通りです。<br>プロジェクトラベルを使用しても請求を分割することはできません。そのため、マーケティング部門の請求を別々に管理するためには、新しい請求アカウントを作成し、新しいプロジェクトをその請求アカウントにリンクする必要があります。'>
<div class='choice'><br>1.組織のGoogle Cloudアカウントに組織管理者IAMロールが割り当てられていることを確認します<br>2.マーケティング部門の新しいGoogle Cloudプロジェクトを作成します<br>3.新しいプロジェクトをMarketing Billing Accountにリンクします</div>
<div class='choice'><br>1.組織のGoogle Cloudプロジェクトで、マーケティング部門の請求管理者IAMロールが割り当てられていることを確認します<br>2.新しいプロジェクトをMarketing Billing Accountにリンクします</div>
<div class='choice'><br>1.組織のGoogle Cloudアカウントに組織管理者IAMロールが割り当てられていることを確認します<br>2.マーケティング部門の新しいGoogle Cloudプロジェクトを作成します<br>3.このプロジェクト内のすべてのサービスについて、デフォルトのキーバリュープロジェクトラベルをdepartment:marketingに設定します</div>
<div class='choice'><br>1.組織のGoogle Cloudアカウントに請求管理者IAMロールが割り当てられていることを確認します<br>2.マーケティング部門の新しいGoogle Cloudプロジェクトを作成します<br>3.このプロジェクト内のすべてのサービスについて、デフォルトのキーバリュープロジェクトラベルをdepartment:marketingに設定します</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題17<br>あなたの会社には、数百のプロジェクトと請求アカウントを持つ既存のGoogle Cloudの組織があります。あなたの会社は最近、別の会社を買収しましたが、その会社も数百のプロジェクトと独自の請求アカウントを保有しています。そのため、両方のGoogle Cloudの組織のすべてのGoogle Cloudコストを1つの請求書に統合したいと考えています。また、明日の時点ですべてのコストを統合したいと考えています。<br>あなたはこの要件を満たすために、どうすればよいですか？' data-answer='2' data-explanation='解説<br>正解は「買収した企業のプロジェクトをあなたの会社の請求アカウントにリンクします」です。<br>この問題では、2つの異なるGoogle Cloudの組織間での請求の統合について考えています。目的は、すべてのGoogle Cloudコストを1つの請求書に統合し、そこに既存の組織と新規買収した組織の両方の経費を含めることです。さらに、これを即座に実行したいとのことなので、そのためには時間と管理の観点から短期・効率的な手法を選択する必要があります。それぞれの選択肢が提供する解決策とその影響を理解し、最適策を選ぶことが求められています。<br>基本的な概念や原則：<br>Google Cloudの組織：Google Cloudリソースを集約し、アクセス制御とポリシーの管理を行うための階層構造です。組織はCloud IdentityまたはG Suiteアカウントで管理されます。<br>プロジェクト：Google Cloudのリソースをグループ化し、課金を管理するための単位です。特定の課金アカウントにリンクされ、そのアカウントに関連する請求が発生します。<br>請求アカウント：Google Cloudプロジェクトの課金を管理するアカウントです。請求アカウントにはクレジットカード情報や契約情報が関連付けられ、各プロジェクトからの料金がこのアカウントに請求されます。<br>プロジェクトのリンク：プロジェクトを特定の請求アカウントにリンクすることで、そのプロジェクトの使用料金がその請求アカウントに請求されます。この操作は、プロジェクトと請求アカウントのオーナーが実行できます。<br>組織の移行：Google Cloudの組織は移行可能ですが、これには複数の手順と時間が必要です。権限の移動、リソースの移動など、移行プロセスには注意が必要です。<br>BigQueryデータセットエクスポート：請求データをBigQueryにエクスポートすることで分析や報告が可能になります。しかし、この方法では請求アカウントを統合することはできず、またリアルタイム性に欠けます。<br>正解についての説明：<br>（選択肢）<br>・買収した企業のプロジェクトをあなたの会社の請求アカウントにリンクします<br>この選択肢が正解の理由は以下の通りです。<br>Google Cloudでは、プロジェクトと請求アカウントは明確に分けられており、多数のプロジェクトを1つの請求アカウントにリンクすることができます。買収した会社のプロジェクトを自社の請求アカウントにリンクすることで、そのプロジェクトに発生するコストは自社の請求アカウントに集約され、1つの請求書で確認できます。<br>また、すべてのコストを明日の時点で統合したいという要件も、この方法ならば満たせます。Google Cloudの請求アカウントとプロジェクトのリンク作業は即時反映されるため、操作後すぐに買収した企業のプロジェクトのコストが自社の請求アカウントに反映されます。<br>以上から、各プロジェクトと請求アカウントのリンクによるコストの統合という選択肢は、要件を満たす最適な答えです。<br>不正解の選択肢についての説明：<br>選択肢：買収した企業の請求アカウントと自社の請求アカウントを設定して、請求データを同じBigQueryデータセットにエクスポートします<br>この選択肢が正しくない理由は以下の通りです。<br>BigQueryに請求データをエクスポートしても、それは請求が統合されたためではなく、請求データが集約されただけです。<br>また、すべてのコストをすぐに統合する方法は、経済的な解決策ではありません。正解の選択肢では、請求アカウントのリンクを変更することで直接的な請求統合が可能です。<br>選択肢：買収した企業のプロジェクトを自社のGoogle Cloudの組織に移行します。移行したプロジェクトをあなたの会社の請求アカウントにリンクします<br>この選択肢が正しくない理由は以下の通りです。<br>このアクションは最終的に望む結果を達成する可能性はありますが、即時性を求めるシナリオには適していません。プロジェクトの組織間移行は複雑で、即座に完了するものではなく、時間がかかる可能性があります。<br>選択肢：新しいGoogle Cloudの組織と新しい請求先アカウントを作成します。買収した企業のプロジェクトと自社のプロジェクトを新しいGoogle Cloudの組織に移行し、プロジェクトを新しい請求先アカウントにリンクします<br>この選択肢が正しくない理由は以下の通りです。<br>新しいGoogle Cloudの組織と新しい請求アカウントを作成する方法では、プロジェクトの移行に時間がかかります。<br>また、新しいアカウントの作成は必要なく、既存の請求アカウントにリンクするだけで統合コストを目指せます。そのため、すぐにすべてのコストを統合したい現状の要件を満たしません。'>
<div class='choice'> 新しいGoogle Cloudの組織と新しい請求先アカウントを作成します。買収した企業のプロジェクトと自社のプロジェクトを新しいGoogle Cloudの組織に移行し、プロジェクトを新しい請求先アカウントにリンクします</div>
<div class='choice'> 買収した企業のプロジェクトを自社のGoogle Cloudの組織に移行します。移行したプロジェクトをあなたの会社の請求アカウントにリンクします</div>
<div class='choice'> 買収した企業のプロジェクトをあなたの会社の請求アカウントにリンクします</div>
<div class='choice'> 買収した企業の請求アカウントと自社の請求アカウントを設定して、請求データを同じBigQueryデータセットにエクスポートします</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題18<br>あなたの会社はオンプレミス環境からGoogle Cloudに移行しようとしています。バックエンドデータベースとしてCassandra環境を使用する複数の開発チームがあります。会社のメンバーは皆、他のCassandraインスタンスから分離された開発環境を必要としています。Google Cloudに迅速かつ最小限のサポート作業で移行したいと考えています。<br>あなたはこの要件を満たすために、どうすればよいですか？' data-answer='0' data-explanation='解説<br>正解は「1.開発者にCloud Marketplaceに行くように勧めます<br>2.開発者に開発作業用のCassandraイメージを起動するように依頼します」です。<br>この問題では、複数の開発チームが独立した開発環境へのアクセスを必要としており、それをGoogle Cloud上で実現する最良の方法を探すことが求められています。具体的にはバックエンドデータベースとしてCassandraを使用していて移行を最小限のサポートで迅速に行いたいという要件があります。選択肢の中から、移行の迅速性とサポート作業の最小化、そして各チームの独立性を確保する方法を選ぶ必要があります。この要件を満たすためには、出来るだけ自動化された、かつ容易に繰り返し可能なプロセスを選ぶことが重要です。その中で各選択肢の手順の複雑さや、開発者が直接関与する必要がある作業の量を比較しつつ適切な選択肢を選びます。<br>基本的な概念や原則：<br>Cloud Marketplace：Google Cloudのマーケットプレイスです。多くのパートナーが提供するソリューションやサービスを見つけ、迅速にデプロイすることができます。<br>Cassandra：高度にスケーラブルな分散型NoSQLデータベースシステムです。大量のデータを複数のサーバー間で効率的に処理することができます。<br>開発環境：プログラマーがソフトウェア開発を行うための独立したスペースです。ここでは新機能の開発やバグの修正を行います。<br>Compute Engine：Google Cloudの仮想マシンインスタンスを提供するIaaS型のサービスです。高度に設定可能で、スケーラブルなソリューションを提供します。<br>インストラクションガイド：具体的な手順や方針を示すドキュメントです。ユーザーが特定のタスクを遂行できるようにするためのものです。<br>スナップショット：特定の時点でのシステムやデータの状態をキャプチャしたものです。データのバックアップや復元に使用されます。<br>Cloud Storage：Google Cloudが提供する高性能なオブジェクトストレージサービスです。データを安全に保存し、いつでもどこからでもアクセスすることができます。<br>正解についての説明：<br>（選択肢）<br>・1.開発者にCloud Marketplaceに行くように勧めます<br>2.開発者に開発作業用のCassandraイメージを起動するように依頼します<br>この選択肢が正解の理由は以下の通りです。<br>まず、Google Cloud MarketplaceはGoogle Cloudにおいて、様々なアプリケーションや開発スタックを素早く導入できるプラットフォームです。ここでは数多くのオープンソース及び有料ソフトウェアのイメージが提供されていて、それらをGoogle Cloud上で容易にデプロイすることができます。<br>Cassandraのようなデータベース環境についてもGoogle Cloud Marketplaceにて対応するイメージが提供されているため、これを利用することで迅速に開発環境を構築することができます。<br>また、開発者自身がMarketplaceから必要なCassandraイメージを選択してデプロイすることで、システム管理者側の対応が最小限で済み、開発者も自身の要件に合った環境を自分で構築することが出来ます。これにより、すべての開発者が分離された開発環境を持つことが可能になります。以上の理由により、この選択肢が最適な解答です。<br>不正解の選択肢についての説明：<br>選択肢：1.Google CloudにCassandraをインストールするためのインストラクションガイドを作成します<br>2.開発者がインストラクションガイドにアクセスできるようにします<br>この選択肢が正しくない理由は以下の通りです。<br>Cassandraのインストールとセットアップに必要なインストラクションガイドを作成すると、それが追加の支援作業を必要とし、また時間もかかります。<br>一方、マーケットプレイスからCassandraイメージを直接起動すると、最小限のサポート作業で迅速な移行が可能です。<br>選択肢：1.Cassandra Compute Engineインスタンスを構築し、そのスナップショットを取得します<br>2.スナップショットを使用して、開発者用のインスタンスを作成します<br>この選択肢が正しくない理由は以下の通りです。<br>Cassandra Compute Engineインスタンスを構築しスナップショットを取得するアプローチは、時間と労力を要します。<br>加えて、各開発者に対してスナップショットを利用したインスタンス作成を行う作業は管理作業が増加し迅速な移行を阻害します。対して正解では、Cloud Marketplaceでデプロイすることで手間が省け、迅速な移行が可能です。<br>選択肢：1.Cassandra Compute Engineインスタンスを構築し、そのスナップショットを取得します<br>2.スナップショットをCloud Storageにアップロードし、開発者がアクセスできるようにします<br>3.開発者が自分でできるように、スナップショットからCompute Engineインスタンスを作成する手順を構築します<br>この選択肢が正しくない理由は以下の通りです。<br>Cassandra Compute Engineインスタンスを作成し、スナップショットを取得してCloud Storageにアップロードするという手順は、時間と作業量が増加します。<br>また、開発者がスナップショットからインスタンスを作成するために、追加の手順が必要です。<br>これに対し、正解の選択肢では、開発者個々にCloud Marketplaceから簡単にCassandraイメージを起動することができます。これにより、手間を省き、個々の開発環境も維持されます。'>
<div class='choice'><br>1.開発者にCloud Marketplaceに行くように勧めます<br>2.開発者に開発作業用のCassandraイメージを起動するように依頼します</div>
<div class='choice'><br>1.Google CloudにCassandraをインストールするためのインストラクションガイドを作成します<br>2.開発者がインストラクションガイドにアクセスできるようにします</div>
<div class='choice'><br>1.Cassandra Compute Engineインスタンスを構築し、そのスナップショットを取得します<br>2.スナップショットを使用して、開発者用のインスタンスを作成します</div>
<div class='choice'><br>1.Cassandra Compute Engineインスタンスを構築し、そのスナップショットを取得します<br>2.スナップショットをCloud Storageにアップロードし、開発者がアクセスできるようにします<br>3.開発者が自分でできるように、スナップショットからCompute Engineインスタンスを作成する手順を構築します</div>
</div>
            <!-- 他の問題も同様に追加 -->
        </div>

        <h2 id="question"></h2>
        <ul class="choices" id="choices"></ul>
        <button onclick="checkAnswer()">採点</button>
        <button onclick="nextQuestion()" id="nextButton" style="display: none;">次の問題へ</button>
        <div class="result" id="result"></div>
    </div>

    <script>
        let currentQuestionIndex = 0;
        let correctCount = 0;
        const questions = [];

        document.addEventListener('DOMContentLoaded', () => {
            const questionElements = document.querySelectorAll('#quiz-data .question');
            questions.push(...Array.from(questionElements).map(questionElement => ({
                question: questionElement.getAttribute('data-question').replace(/\\n/g, '<br>'),
                choices: Array.from(questionElement.querySelectorAll('.choice')).map((choice, index) => ({
                    text: choice.innerHTML.replace(/\\n/g, '<br>'),  // innerHTMLに変更
                    index: index
                })),
                correctAnswer: questionElement.getAttribute('data-answer').split(',').map(Number),
                explanation: questionElement.getAttribute('data-explanation').replace(/\\n/g, '<br>'),
                multiple: questionElement.getAttribute('data-multiple') === 'true'
            })));
            showQuestion();
        });

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function showQuestion() {
            const questionElement = document.getElementById('question');
            const choicesContainer = document.getElementById('choices');
            const currentQuestion = questions[currentQuestionIndex];

            shuffleArray(currentQuestion.choices);

            questionElement.innerHTML = currentQuestion.question;
            choicesContainer.innerHTML = '';

            currentQuestion.choices.forEach((choice, i) => {
                const li = document.createElement('li');
                const input = document.createElement('input');
                const label = document.createElement('label');

                input.type = currentQuestion.multiple ? 'checkbox' : 'radio';
                input.name = 'choice';
                input.value = choice.index;
                input.id = 'choice' + i;

                label.htmlFor = 'choice' + i;
                label.innerHTML = choice.text;  // textContentをinnerHTMLに変更

                li.appendChild(input);
                li.appendChild(label);
                choicesContainer.appendChild(li);
            });

            document.getElementById('result').textContent = "";
            document.getElementById('nextButton').style.display = 'none';
        }

        function checkAnswer() {
            const currentQuestion = questions[currentQuestionIndex];
            const selectedChoices = Array.from(document.querySelectorAll('input[name="choice"]:checked'))
                                        .map(checkbox => parseInt(checkbox.value))
                                        .sort();
            const resultElement = document.getElementById('result');
            
            if (selectedChoices.length > 0) {
                const isCorrect = currentQuestion.multiple
                    ? selectedChoices.toString() === currentQuestion.correctAnswer.sort().toString()
                    : selectedChoices.length === 1 && selectedChoices[0] === currentQuestion.correctAnswer[0];
                
                if (isCorrect) {
                    resultElement.innerHTML = "正解です！<br>" + currentQuestion.explanation;
                    resultElement.style.color = "green";
                    correctCount++; // 正解数をカウント
                } else {
                    resultElement.innerHTML = "残念、不正解です。<br>" + currentQuestion.explanation;
                    resultElement.style.color = "red";
                }
                document.getElementById('nextButton').style.display = 'inline';
            } else {
                resultElement.textContent = "回答を選択してください。";
                resultElement.style.color = "orange";
            }
        }

        function nextQuestion() {
            currentQuestionIndex++;
            
            if (currentQuestionIndex < questions.length) {
                showQuestion();
            } else {
                showFinalResult();
            }
        }

        function showFinalResult() {
            const quizContainer = document.querySelector('.quiz-container');
            quizContainer.innerHTML = `
                <h2>問題終了！</h2>
                <p>あなたの正解数は ${correctCount} / ${questions.length} です。</p>
                <button onclick="restartQuiz()">再挑戦する</button>
            `;
        }

        function restartQuiz() {
            correctCount = 0;
            currentQuestionIndex = 0;

            // クイズのUI全体を初期化
            const quizContainer = document.querySelector('.quiz-container');
            quizContainer.innerHTML = `
                <h2 id="question"></h2>
                <ul class="choices" id="choices"></ul>
                <button onclick="checkAnswer()">採点</button>
                <button onclick="nextQuestion()" id="nextButton" style="display: none;">次の問題へ</button>
                <div class="result" id="result"></div>
            `;

            // 初期化後に最初の問題を表示
            showQuestion();
        }        
    </script>
</body>
</html>