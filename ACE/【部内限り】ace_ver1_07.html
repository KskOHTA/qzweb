<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Google Cloud Leader問題集 07</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="quiz-container">
        <div id="quiz-data" style="display: none;">
<div class='question' data-multiple='FALSE' data-question='問題13<br>オンプレミスのデータ分析用バイナリセットで、毎深夜約45分間、メモリ内のデータファイルを処理しています。データファイルのサイズは1GBから16GBです。このアプリケーションを最小限の労力とコストでGoogle Cloudに移行したいと考えています。<br>この要件を満たすために、どうすればよいですか？' data-answer='3' data-explanation='解説<br>正解は「Compute Engine上のVMにリフト＆シフトします。インスタンススケジュールを使用してインスタンスを開始および停止します」です。<br>この問題では、オンプレミスのデータ処理アプリケーションをGoogle Cloudに最小限の労力とコストで移行する手段が尋ねられています。ここで注意するのは、1GBから16GBのデータファイルを扱い、毎夜45分間の処理が必要という特性です。この特性が、仮想マシン、コンテナ、Cloud Functionsなど、適用可能なGoogle Cloudサービスを選ぶ上で影響を与える重要な要素になります。コスト効率と移行労力を優先する視点を持ちつつ、これらの特性を基に適したサービスを選択することが求められます。<br>基本的な概念や原則：<br>リフト＆シフト：既存のオンプレミスアプリケーションをそのままクラウド環境に移行する戦略です。最小限の変更でアプリケーションをクラウドに移行することができます。<br>Compute Engine：仮想マシン（VM）を管理するGoogle Cloudのサービスです。仮想マシンのライフサイクルを制御することができます。<br>インスタンススケジュール：Compute Engineの仮想マシンの起動や停止を自動化する機能です。特定の時間や周期に合わせて仮想マシンを管理します。<br>Cloud Run：コンテナ化されたアプリケーションをフルマネージドで実行できるGoogle Cloudのサービスです。サーバレスの利点を活かし、インフラストラクチャの管理を抑えつつスケーリングします。<br>Google Kubernetes Engine（GKE）：Google Cloudが提供するKubernetes環境のフルマネージドサービスです。コンテナ化されたアプリケーションのデプロイとスケーリングを自動化します。<br>Cloud Functions：Google CloudのFaaS（Function as a Service）で、スケーラブルなイベント駆動関数を実行するサービスです。サーバレスアーキテクチャの一部として機能します。<br>Cloud Scheduler：Google Cloudのフルマネージドなジョブスケジューリングサービスです。Cloud FunctionsやApp Engineのタスクなど、定期的に行うべきタスクを設定します。<br>正解についての説明：<br>（選択肢）<br>・Compute Engine上のVMにリフト＆シフトします。インスタンススケジュールを使用してインスタンスを開始および停止します<br>この選択肢が正解の理由は以下の通りです。<br>まず、リフト＆シフトはアプリケーションをそのままの形でクラウドに移行する戦略で、最小限の労力で移行を達成するための良い選択であり、Compute Engine上の仮想マシン（VM）はこれを支える適切な環境です。仮想マシンは物理的なハードウェアの制約から解放され、スケーリングと管理が非常に容易で、費用も使用した分だけになるため、リフト＆シフト戦略の主要なメリットを活かすことができます。<br>また、インスタンススケジュールを使用することで、深夜の45分間だけインスタンスを起動し、それ以外の時間は停止することができます。これにより、インスタンスが動作する時間を最小限に抑えてコストを節約することができます。インスタンススケジュールは、時間ベースのCompute Engineのインスタンスの起動と停止を自動的に制御します。これはこの使用パターンに最適であり、移行後も同じ期間内での実行が可能です。以上の理由により、この選択肢が適切です。<br>不正解の選択肢についての説明：<br>選択肢：バイナリのセット用にコンテナを作成します。Cloud Schedulerを使用して、コンテナのCloud Runジョブを開始します<br>この選択肢が正しくない理由は以下の通りです。<br>Cloud Runは、CPUとメモリリソースが制限され、処理能力が最大2GBまでとなっています。これは16GBのデータを扱うためには不十分です。<br>一方、Compute EngineのVMはデータファイルのサイズに対応可能なリソースを提供可能です。<br>選択肢：バイナリのセット用にコンテナを作成します。コンテナをGoogle Kubernetes Engine（GKE）にデプロイし、Kubernetesスケジューラーを使ってアプリケーションを起動します<br>この選択肢が正しくない理由は以下の通りです。<br>GKEとKubernetesスケジューラーの利用はリフト＆シフトと比べて多大な労力を必要とし、要件である"最小限の労力"を満たしていません。<br>また、"最小限のコスト"という条件も満たさず、GKEはリソース使用量に応じて課金されるため、短時間の使用でもコストが発生します。<br>選択肢：コードをCloud Functionsにアップロードします。Cloud Schedulerを使ってアプリケーションを起動します<br>この選択肢が正しくない理由は以下の通りです。<br>Cloud Functionsは短期間のステートレスなワークロードに適していますが、データ分析のような長時間かつ大容量データを処理する用途には向きません。<br>また、移行に工数がかかる可能性もあり、要件の"最小限の労力"という部分にも合致しません。'>
<div class='choice'> バイナリのセット用にコンテナを作成します。コンテナをGoogle Kubernetes Engine（GKE）にデプロイし、Kubernetesスケジューラーを使ってアプリケーションを起動します</div>
<div class='choice'> バイナリのセット用にコンテナを作成します。Cloud Schedulerを使用して、コンテナのCloud Runジョブを開始します</div>
<div class='choice'> コードをCloud Functionsにアップロードします。Cloud Schedulerを使ってアプリケーションを起動します</div>
<div class='choice'> Compute Engine上のVMにリフト＆シフトします。インスタンススケジュールを使用してインスタンスを開始および停止します</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題14<br>あなたは、us-central1-aのCompute Engine仮想マシン（VM）からアプリケーションをホストしています。単一のCompute Engineゾーンの障害をサポートし、ダウンタイムを排除し、コストを最小限に抑えるように設計を調整したいと考えています。<br>この要件を満たすために、どうすればよいですか？' data-answer='3' data-explanation='解説<br>正解は「アプリケーションの定期的なバックアップを実行します。Cloud Monitoringアラートを作成すると、アプリケーションが使用できなくなった場合に通知が届きます。通知されたらバックアップから復元します」です。<br>この問題では、Google CloudのCompute Engineにて、単一のゾーン障害を想定したアプリケーションのダウンタイム排除とコスト最小化の設計調整が求められています。問題文から、現在の状況では単一ゾーン（us-central1-a）でホストされていることが明らかになります。そのため、障害が発生した場合の回復手段としてバックアップとリストアや、負荷分散をはじめとする各種の冗長化プランを選択肢を通じて検討しています。それぞれの選択肢の対障害時の挙動、コスト影響、ダウンタイム影響を理解し、それらをトレードオフのバランスとして考慮することが重要です。<br>基本的な概念や原則：<br>Compute Engine：Google Cloudの仮想マシンを提供するサービスです。強力なコンピューティング能力とフレキシブルな設定を備えています。<br>ゾーン：Google Cloudの地理的な分割です。ゾーン内のサーバーが障害を起こすと、そのゾーンが影響を受けますが、他のゾーンは影響を受けません。<br>バックアップと復元：データの耐久性と冗長性を保つためのプロセスです。定期的なバックアップを取ることで、障害が発生してもデータを復元することができます。<br>Cloud Monitoring：Google Cloudのリソースを監視し、異常な動きを知らせるツールです。アラートの設定により、システムやアプリケーションの状態に変化があったときに通知を受け取ることができます。<br>負荷分散：複数のサーバーにトラフィックを分散することで、システムのダウンタイムを減らし、パフォーマンスを改善する手法です。<br>マネージドインスタンスグループ（MIG）：Compute Engineの機能で、インスタンスの配備、スケーリング、更新を自動化してロードバランスをとることができます。<br>HTTP(S)ロードバランサ：Google Cloudのネットワーク負荷分散の一種で、HTTP(S)プロトコルのトラフィックをバックエンドサービスに分散させるものです。<br>正解についての説明：<br>（選択肢）<br>・アプリケーションの定期的なバックアップを実行します。Cloud Monitoringアラートを作成すると、アプリケーションが使用できなくなった場合に通知が届きます。通知されたらバックアップから復元します<br>この選択肢が正解の理由は以下の通りです。<br>まず、Compute Engineの仮想マシン（VM）を使用しており、単一のCompute Engineゾーンの障害をサポートしたいと考えています。これは、特定のリージョンのデータセンターで問題が発生した場合でも、アプリケーションがダウンしないようにするという要求を表しています。そのために、アプリケーションの定期的なバックアップが必要です。これにより、障害が発生した際に、バックアップからアプリケーションをすばやく復元し、サービスを継続することができます。<br>さらにCloud Monitoringのアラートを使用すると、アプリケーションが使用できなくなった場合や異常が発生した場合にすぐに通知を受け取ることができます。そのため、障害にすぐに対応し、ダウンタイムを最小限に抑えることができます。<br>これらの組み合わせにより、単一のCompute Engineゾーンの障害でもダウンタイムを排除し、コストを最小限に抑えることができます。このため、この選択肢が最適であると言えます。<br>不正解の選択肢についての説明：<br>選択肢：Compute Engineリソースをus-central1-bに作成します。us-central1-aとus-central1-bの両方で負荷のバランスをとります<br>この選択肢が正しくない理由は以下の通りです。<br>負荷分散をus-central1-aとus-central1-bで行うと、ダウンタイムは排除できますが、コストが増えるため、コストを最小限に抑える要件を満たしません。<br>一方、定期的なバックアップとCloud Monitoringによる通知は、コスト効率が良く要件を満たす選択肢です。<br>選択肢：マネージドインスタンスグループを作成し、ゾーンとしてus-central1-aを指定します。短いヘルス間隔でヘルスチェックを構成します<br>この選択肢が正しくない理由は以下の通りです。<br>マネージドインスタンスグループで単一ゾーンを指定すると、そのゾーンの障害に対する耐性が得られません。そのため、ダウンタイムを排除する目的に反します。複数のゾーンを指定せずに単一ゾーンのみを指定すると、障害時のリスクが大きくなります。<br>選択肢：HTTP(S)ロードバランサを作成します。トラフィックをVMに転送するための1つ以上のグローバル転送ルールを作成します<br>この選択肢が正しくない理由は以下の通りです。<br>HTTP(S)ロードバランサとグローバル転送ルールは複数のインスタンス間でトラフィックを分散するためのもので、単一のゾーン内での障害から復旧する為の解決策ではありません。これらを使っても、単一ゾーンのVMの障害時にダウンタイムを防げないため、要件に合っていません。'>
<div class='choice'> マネージドインスタンスグループを作成し、ゾーンとしてus-central1-aを指定します。短いヘルス間隔でヘルスチェックを構成します</div>
<div class='choice'> Compute Engineリソースをus-central1-bに作成します。us-central1-aとus-central1-bの両方で負荷のバランスをとります</div>
<div class='choice'> HTTP(S)ロードバランサを作成します。トラフィックをVMに転送するための1つ以上のグローバル転送ルールを作成します</div>
<div class='choice'> アプリケーションの定期的なバックアップを実行します。Cloud Monitoringアラートを作成すると、アプリケーションが使用できなくなった場合に通知が届きます。通知されたらバックアップから復元します</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題15<br>あなたは、グローバルに使用される金融取引アプリケーションを開発しています。データはリレーショナル構造を使用して保存され、照会されます。世界中のクライアントが、全く同じ状態のデータを取得する必要があります。このアプリケーションは、エンドユーザーへのレイテンシを最小にするため、複数のリージョンで展開される予定です。レイテンシを最小限に抑えながら、アプリケーションデータのストレージオプションを選択する必要があります。<br>あなたはこの要件を満たすために、どうすればよいですか？' data-answer='3' data-explanation='解説<br>正解は「データの保存にはCloud Spannerを使用します」です。<br>この問題では、アプリケーションのデータ管理要件を適確に理解することが求められています。具体的には、データはリレーショナル構造を使って保存、照会され、全てのクライアントが全く同じ状態のデータを確定的に得ることが求められています。そして、このアプリケーションはグローバルに展開されるため、エンドユーザーへのレイテンシを最小限に抑える必要があります。これらの要件と結びつくストレージオプションを選択肢から探すことが求められています。<br>基本的な概念や原則：<br>Cloud Spanner：グローバルレベルでの一貫性を保証するリレーショナルデータベースです。マルチリージョンの配置と自動シャーディング機能により、高い可用性と低レイテンシを提供します。<br>リレーショナルデータベース：行と列の表形式でデータを組織化するデータベースシステム。一貫性と完全性の保証に優れています。<br>Cloud Bigtable：大規模なリード/ライトワークロードを高速で処理できるNoSQLデータベースサービス。しかし、グローバル一貫性は保証していません。<br>Cloud SQL：フルマネージドなリレーショナルデータベースサービス。しかし、マルチリージョンデプロイには限定的であり、Global consistent readは保証していません。<br>Firestore：NoSQLドキュメントデータベースで、Web、モバイル、サーバー開発に利用できます。しかし、リレーショナルデータ構造を持つアプリケーションでの使用に最適化されていません。<br>正解についての説明：<br>（選択肢）<br>・データの保存にはCloud Spannerを使用します<br>この選択肢が正解の理由は以下の通りです。<br>まず、Cloud SpannerはGoogle Cloudのフルマネージドでスケーラブルなリレーショナルデータベースサービスであり、一貫性を必要とする金融取引アプリケーションのデータを保存するのに適しています。<br>また、Cloud Spannerは地理的に分散されたデータをリアルタイムで一貫性を保ちながら管理する能力があります。これは、グローバルに展開され、全てのクライアントが同じ状態のデータを取得する必要があるアプリケーションにとって極めて重要な機能です。<br>そして、Cloud Spannerはマルチリージョン構成を提供しており、グローバルなアプリケーションをサポートするためのリージョン間ののレプリケーションが可能です。これにより、異なるリージョンのエンドユーザーが確実に最新のデータにアクセスできるようにし、レイテンシを最小限に抑えます。<br>以上の理由により、Cloud Spannerはこの問題の要件を満たす最適なストレージオプションとなります。<br>不正解の選択肢についての説明：<br>選択肢：データの保存にはCloud Bigtableを使用します<br>この選択肢が正しくない理由は以下の通りです。<br>Cloud Bigtableは高スループットと低レイテンシを提供する一方で、全体的な一貫性は保持できません。<br>しかし、問題は全く同じ状態のデータを世界中のクライアントに提供することを求めています。そういった用途にはCloud Spannerのグローバルなトランザクション一貫性が適しています。<br>選択肢：データの保存にはCloud SQLを使用します<br>この選択肢が正しくない理由は以下の通りです。<br>Cloud SQLは単一リージョン内でのデータ管理に向いていますが、世界中のクライアントが同じ状態のデータにアクセスし、複数のリージョンで展開しながらレイテンシを最小限に抑える必要性に対しては適していません。<br>一方、Cloud Spannerはリレーショナルデータ構造を備えつつ、グローバルに分散した一貫性のあるデータ構造を提供するため、要件を満たします。<br>選択肢：データの保存にはFirestoreを使用します<br>この選択肢が正しくない理由は以下の通りです。<br>Firestoreは一部のユースケースでは十分なパフォーマンスを提供しますが、金融取引アプリケーションのような全世界のクライアントが同じ状態のデータを必要とするリレーショナルデータの保存には向きません。そういったケースでは、地域的な分散性と強い一貫性を提供するCloud Spannerの使用が適切です。'>
<div class='choice'> データの保存にはFirestoreを使用します</div>
<div class='choice'> データの保存にはCloud SQLを使用します</div>
<div class='choice'> データの保存にはCloud Bigtableを使用します</div>
<div class='choice'> データの保存にはCloud Spannerを使用します</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題16<br>Google Cloud上にデータを保存し、アーカイブするためのソリューションを選択し、設定する必要があります。ある地理的ロケーションからのデータのコンプライアンス目標をサポートする必要があります。このデータは30日後にアーカイブされ、毎年アクセスする必要があります。<br>あなたはこの要件を満たすために、どうすればよいですか？' data-answer='1' data-explanation='解説<br>正解は「リージョンストレージを選択します。30日後にデータをColdlineストレージにアーカイブするバケットライフサイクルルールを追加します」です。<br>この問題では、Google Cloud上でのデータ保存とアーカイブに関する適切なソリューションを選択することが求められています。問題文に従って、まずは地理的なロケーションに基づいてデータをサポートする必要性を考慮しなければなりません。次に、30日後にアーカイブされるデータが毎年アクセスされるという要点にも注目が必要です。これらの要件を満たすためには、スペーシフィックなストレージクラスと適切なライフサイクルルールを選んでデータを管理することが必要です。<br>基本的な概念や原則：<br>リージョンストレージ：Google Cloud Storageの一部で、データを特定のリージョン内に保存する機能です。地理的なコンプライアンス要件を満たしたり、特定の地域でのパフォーマンスを向上させたりするために使用します。<br>Coldlineストレージ：Google Cloud Storageのストレージクラスの一つで、長期保存のためのデータを低コストで保存します。アクセス頻度が低いデータのアーカイブに適しています。<br>バケットライフサイクルルール：Cloud Storageバケットのオブジェクトに対する自動的なアクションを定義します。特定の条件が満たされたときに、オブジェクトを削除したり、ストレージクラスを変更したりすることができます。<br>マルチリージョンストレージ：データを複数の地理的に離れた場所に冗長的に保存します。可用性と耐久性が高いデータに対して使用します。<br>Nearlineストレージ：Coldlineストレージと比べてアクセス頻度が高く、コストはやや高いストレージクラスです。月に一度程度のアクセス頻度のデータに適しています。<br>正解についての説明：<br>（選択肢）<br>・リージョンストレージを選択します。30日後にデータをColdlineストレージにアーカイブするバケットライフサイクルルールを追加します<br>この選択肢が正解の理由は以下の通りです。<br>まず、Google Cloud Storageのリージョンストレージは、データを特定の地理的ロケーションに格納することを可能にします。これにより、特定の地理的ロケーションからのデータのコンプライアンス目標をサポートできます。<br>次に、バケットライフサイクルルールを使用すると、特定の条件に基づいてオブジェクトを自動的にアーカイブまたは削除することができます。<br>この問題では、データが30日後にColdlineストレージにアーカイブされるようにする必要があるため、バケットライフサイクルルールを追加すればこの要件を満たすことができます。<br>最後に、Coldlineストレージは、年間アクセスが必要な低頻度データのアーカイブに最適なストレージクラスです。ですから、この選択肢はすべての要件を満たしています。<br>不正解の選択肢についての説明：<br>選択肢：マルチリージョンストレージを選択します。30日後にデータをColdlineストレージにアーカイブするバケットライフサイクルルールを追加します<br>この選択肢が正しくない理由は以下の通りです。<br>マルチリージョンストレージはデータを特定の地理的ロケーションに保存することはできません。データは複数のリージョンに分散され、ロケーション固有のコンプライアンス要件に対応することが困難です。<br>一方、リージョンストレージではデータを特定の地理的ロケーションに保存でき、その地域のコンプライアンス要件を満たすことができます。<br>選択肢：マルチリージョンストレージを選択します。30日後にデータをNearlineストレージにアーカイブするバケットライフサイクルルールを追加します<br>この選択肢が正しくない理由は以下の通りです。<br>マルチリージョンストレージは高アクセス性を確保するための選択であり、コンプライアンス目標を満たすことはできません。<br>また、Nearlineストレージは、少なくとも1ヶ月ごとのアクセスを想定していますが、問題文ではデータが毎年アクセスされるとされているため、Coldlineストレージの方が適切です。<br>選択肢：リージョンストレージを選択します。30日後にデータをNearlineストレージにアーカイブするバケットライフサイクルルールを追加します<br>この選択肢が正しくない理由は以下の通りです。<br>データが30日後にアーカイブされ、約1年間アクセスされない状況では、NearlineストレージよりもColdlineストレージの方がコスト効率が良いからです。Nearlineは月に一度以上アクセスされるデータに適していますが、Coldlineは年に一度だけアクセスされるデータに最適なストレージクラスです。'>
<div class='choice'> リージョンストレージを選択します。30日後にデータをNearlineストレージにアーカイブするバケットライフサイクルルールを追加します</div>
<div class='choice'> リージョンストレージを選択します。30日後にデータをColdlineストレージにアーカイブするバケットライフサイクルルールを追加します</div>
<div class='choice'> マルチリージョンストレージを選択します。30日後にデータをNearlineストレージにアーカイブするバケットライフサイクルルールを追加します</div>
<div class='choice'> マルチリージョンストレージを選択します。30日後にデータをColdlineストレージにアーカイブするバケットライフサイクルルールを追加します</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題17<br>あなたは、ユーザーからのリレーショナルデータを保存するアプリケーションを構築しています。世界中のユーザーがこのアプリケーションを使用します。あなたの会社のCTOは、ユーザーベースのサイズが不明であるため、スケーリング要件について懸念しています。あなたは、最小限の構成変更でユーザーの増加に合わせて拡張できるデータベースソリューションを実装する必要があります。<br>どのストレージソリューションを使用すべきですか？' data-answer='0' data-explanation='解説<br>正解は「Cloud Spanner」です。<br>この問題では、アプリケーション設計とストレージ要件に関する理解が必要です。主に、リレーショナルデータの格納と、全世界のユーザーを対象としたスケーラビリティという二つの重要な要素に注目する必要があります。また、問題からCTOの懸念としてスケーリング要件が明示されており、ユーザーベースのサイズが不明であるため、スケールアップとスケールダウンの両方に対応できるソリューションが必要であるということも考慮する必要があります。<br>基本的な概念や原則：<br>Cloud Spanner：Google Cloudの水平にスケールするリレーショナルデータベースサービスです。データの一貫性を保持しつつ、高い可用性とグローバルなトランザクションを提供します。<br>Cloud SQL：Google Cloudのフルマネージドなリレーショナルデータベースサービスです。MySQL、PostgreSQL、SQL Serverなどの人気のあるデータベースエンジンをサポートしていますが、大規模なスケーリングが必要な場合には適していません。<br>Firestore：Google CloudのNoSQLドキュメントデータベースで、Web、モバイル、サーバーの開発に対応しています。リアルタイムの同期とオフライン対応を提供します。<br>Bigtable：Google CloudのマネージドNoSQLデータベースサービスです。TB規模以上のデータに対応し、ローレイテンシで読み書きを行うことができます。大量の非構造化データを迅速に分析するために設計されました。<br>正解についての説明：<br>（選択肢）<br>・Cloud Spanner<br>この選択肢が正解の理由は以下の通りです。<br>まず、Cloud Spannerは、大規模なリレーショナルデータベースに必要なスケーラビリティ、信頼性、および整合性を特徴としているGoogle Cloudのフルマネージド型リレーショナルデータベースサービスです。この問題における主な懸念点がスケーリング要件に対するものであることを考えると、Cloud Spannerは実際にスケーラビリティに優れ、自動シャーディングと高可用性リプリケーションを使ってユーザーの増加に合わせて自動的にスケールアップまたはスケールダウンできるため、適切な選択です。<br>さらに、Cloud Spannerは世界中のユーザーからのリクエストを処理でき、構成変更を最小限に抑えつつも大規模なデータベース読み取り/書き込み操作をサポートするため、この設問の要件を満たしています。<br>したがって、リレーショナルデータを保存し、ユーザーベースのサイズが不明でスケーリング要件に懸念がある場合は、Cloud Spannerが最適な解決策です。<br>不正解の選択肢についての説明：<br>選択肢：Cloud SQL<br>この選択肢が正しくない理由は以下の通りです。<br>Cloud SQLはスケーラブルなリレーショナルデータベースサービスではありますが、スケーリングの際にはマネージドサービスの大規模な更新やマルチリージョン設定の追加などの構成変更が必要です。<br>それに対し、Cloud Spannerは最初からグローバルスケールでのスケーラビリティを提供し、最小限の構成変更でユーザーの増加に対応できる特性があるため、問題要件により適しています。<br>選択肢：Firestore<br>この選択肢が正しくない理由は以下の通りです。<br>Firestoreは確かにスケーラブルなNoSQLデータベースではありますが、この問題ではリレーショナルデータを取り扱うケースが提出されており、このようなシナリオではFirestoreよりもCloud Spannerの使用が適切です。これは、Cloud Spannerはスケーラブルなリレーショナルデータベースであり、要件により近く、最小限の構成変更でユーザーの増加に対応できるためです。<br>選択肢：Bigtable<br>この選択肢が正しくない理由は以下の通りです。<br>Bigtableは優れたスケーリング能力を持っていますが、リレーショナルデータには最適ではありません。<br>一方、Cloud Spannerはリレーショナルデータと地理的に広範囲でのスケーリングに対応しているため、この設問の要件に適合しています。'>
<div class='choice'> Cloud Spanner</div>
<div class='choice'> Bigtable</div>
<div class='choice'> Cloud SQL</div>
<div class='choice'> Firestore</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題18<br>Dataprocクラスターは、172.16.20.128/25の範囲にある単一のサブネット内の単一のVirtual Private Cloud（VPC）ネットワークで動作します。VPCネットワークにはプライベートIPアドレスはありません。あなたは、最小限のステップ数を使用してクラスターと通信するために新しいVMを追加したいと考えています。<br>あなたはこの要件を満たすために、どうすればよいですか？' data-answer='0' data-explanation='解説<br>正解は「既存のサブネット範囲を172.16.20.0/24に変更します」です。<br>この問題では、既存のDataprocクラスターが存在するVPCネットワークに新たなVMを追加し、そのVMとクラスターとが通信できるようにする最善の手段を探しています。問題文からは既存のクラスターと同じVPCネットワーク内に新たなVMを作成せねばならず、プライベートIPアドレスに依存していないことが読み取れます。また、操作の手順を最小限に抑えることも重要なポイントであるため、その時最も簡単で効率的な手段を選ぶ必要があります。<br>基本的な概念や原則：<br>Virtual Private Cloud（VPC）：仮想的なプライベートネットワーク環境をGoogle Cloud上で提供するサービスです。仮想マシンやデータベースなどのリソースを安全に配置し、運用できます。<br>Dataproc：Google CloudのフルマネージドApache HadoopとApache Sparkサービスです。大量のデータの高速処理と分析を実現できます。<br>サブネット：ネットワークを小さなネットワークに分割することで、ネットワークのトラフィック管理やセキュリティの強化を図ります。<br>プライベートIPアドレス：インターネット上から直接アクセスできないIPアドレスです。プライベートIPアドレスは、特定のネットワーク内部でのみ通信できます。<br>セカンダリIP範囲：サブネットで追加のIP範囲を指定するものです。主にGKEクラスターや特定のサービスのためのIP範囲を確保するために使用されます。<br>VPCネットワークピアリング：異なるVPCネットワーク間で直接的なネットワークトラフィックを可能にする機能です。ネットワーク間の通信が高速かつ安全に行えます。<br>カスタムルート交換：特定のネットワークパスをカスタマイズする機能です。自動生成されるデフォルトのルーティングルールに合わない、特殊なケースへの対処を可能にします。<br>正解についての説明：<br>（選択肢）<br>・既存のサブネット範囲を172.16.20.0/24に変更します<br>この選択肢が正解の理由は以下の通りです。<br>まず、指定されたIP範囲172.16.20.128/25は既存のDataprocクラスターが使用しており、この範囲内には新たに追加するVMのための余裕がありません。通信を可能にする新しいVMを追加するためには、新たなIPアドレスを確保する必要があります。そのため、サブネット範囲を広くすることでより多くのIPアドレスを利用可能にし、新しいVMを追加するスペースを確保することが必要です。<br>また、変更後のサブネット範囲172.16.20.0/24は、元の範囲を包含するように設定されているため、既存のDataprocクラスターは新たな範囲内でも引き続き動作します。これにより、最小限のステップで目的を達成できます。<br>不正解の選択肢についての説明：<br>選択肢：VPC内に新しいセカンダリIP範囲を作成し、VMがそのレンジを使用するように設定します<br>この選択肢が正しくない理由は以下の通りです。<br>VPC内に新しいセカンダリIP範囲を作成しても、既存のDataprocクラスターと新しいVMの通信を許可するわけではありません。既存のサブネット範囲を広げることで、新しいVMを同じサブネット内に配置し、クラスターと通信を可能にする方が適切です。<br>選択肢：VM用に新しいVPCネットワークを作成します。VMのVPCネットワークとDataprocクラスターのVPCネットワーク間のVPCピアリングを有効にします<br>この選択肢が正しくない理由は以下の通りです。<br>新しいVPCネットワークとVPCピアリングを作成すると、設定が複雑になり、ステップ数が増えます。<br>一方、既存のサブネット範囲を変更するだけで、新しいVMとDataprocクラスター間の通信が可能です。<br>また、新しいVPCネットワークを作成することは発生コストも高くなります。<br>選択肢：サブネットを172.32.0.0/16として、VM用に新しいVPCネットワークを作成します。DataprocのVPCネットワークとVMのVPCネットワークの間でVPCネットワークのピアリングを有効にします。カスタムルート交換を設定します<br>この選択肢が正しくない理由は以下の通りです。<br>新しいVPCネットワークを作成し、VPCネットワークピアリングとカスタムルート交換を設定するのは、必要なステップ数が増えてしまい最小限ではなくなります。問題の要件は最小限のステップ数を使用することから、既存のサブネット範囲を変更することが適切です。'>
<div class='choice'> 既存のサブネット範囲を172.16.20.0/24に変更します</div>
<div class='choice'> サブネットを172.32.0.0/16として、VM用に新しいVPCネットワークを作成します。DataprocのVPCネットワークとVMのVPCネットワークの間でVPCネットワークのピアリングを有効にします。カスタムルート交換を設定します</div>
<div class='choice'> VM用に新しいVPCネットワークを作成します。VMのVPCネットワークとDataprocクラスターのVPCネットワーク間のVPCピアリングを有効にします</div>
<div class='choice'> VPC内に新しいセカンダリIP範囲を作成し、VMがそのレンジを使用するように設定します</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題19<br>あなたはCloud Storageに保存されたファイルに対して、最小限のコストで最適なデータストレージを構成する必要があります。ファイルは、継続的に使用されるミッションクリティカルな分析パイプラインで使用されます。ユーザーはカリフォルニア州のサンノゼ（米国）にいます。<br>あなたはこの要件を満たすために、どうすればよいですか？' data-answer='0' data-explanation='解説<br>正解は「ユーザーに最も近いリージョンにリージョナルストレージを構成します。Standardストレージクラスを構成します」です。<br>この問題では、Cloud Storageに保存されるデータの必要性と利便性、特に頻繁に使用される分析パイプラインでの使用と、ユーザーの地理的位置を考慮すると指示されています。また、コスト効率も重要な考慮事項とされています。問題文の要件に基づいて、それぞれの選択肢のストレージの種類やストレージクラスを伴う潜在的なパフォーマンスおよびコストの違いを理解することが重要です。<br>基本的な概念や原則：<br>リージョナルストレージ：特定のリージョン内にデータを格納するGoogle Cloud Storageのストレージタイプです。同じリージョン内のリソースからの頻繁なアクセスを最適化します。<br>Standardストレージクラス：Cloud Storageのストレージクラスの一つで、高頻度でアクセスされるデータに最適化されています。コストは比較的低く、パフォーマンスと可用性が高いです。<br>Nearlineストレージクラス：アクセス頻度が低いデータを格納するためのCloud Storageのストレージクラスです。コストは低いですが、データの取得には時間を要します。<br>デュアルリージョンストレージ：データを2つのリージョンに格納するCloud Storageのストレージタイプです。データの冗長性と可用性が高いですが、コストが高くなる可能性があります。<br>正解についての説明：<br>（選択肢）<br>・ユーザーに最も近いリージョンにリージョナルストレージを構成します。Standardストレージクラスを構成します<br>この選択肢が正解の理由は以下の通りです。<br>まず、リージョナルストレージは、ユーザーがよくアクセスするデータを近くのリージョンで保存するための選択肢であり、同じリージョン内のサービスに対して高いパフォーマンスをもたらします。そのため、サンノゼにいるユーザーにとってはカリフォルニア州のリージョンにデータを保存することが最も効率的であると言えます。これによって、データへのアクセス時間を最小限に抑えることができます。<br>また、Standardストレージクラスは、頻繁にまたは毎月のようにアクセスするデータに適しています。これは、ミッションクリティカルな分析パイプラインで必要とされるデータの利用パターンと一致します。<br>したがって、カリフォルニア州のリージョンでリージョナルストレージを構成し、Standardストレージクラスを使用することで、ファイルへのアクセス速度を最適化しながら、必要なコストを最小限に抑えることができます。<br>不正解の選択肢についての説明：<br>選択肢：ユーザーに最も近いリージョンのリージョナルストレージを構成します。Nearlineストレージクラスを構成します<br>この選択肢が正しくない理由は以下の通りです。<br>ファイルが継続的に使用されるミッションクリティカルな分析パイプラインで使用されるため、Nearlineストレージクラスではなく、Standardストレージクラスを選ぶべきです。その理由は、Nearlineストレージクラスはアクセス頻度が低いデータ向けで、データを継続的に使用する場合、費用が高くなる可能性があります。<br>選択肢：ユーザーに最も近いデュアルリージョンにデュアルリージョンストレージを構成します。Nearlineストレージクラスを構成します<br>この選択肢が正しくない理由は以下の通りです。<br>デュアルリージョンストレージとNearlineストレージクラスは冗長性と低頻度のアクセスに対するコスト効率性を提供しますが、継続的に使用されるミッションクリティカルな分析パイプラインには適していません。<br>それに対して、リージョナルストレージとStandardストレージクラスは高いパフォーマンスと低遅延を提供します。<br>選択肢：ユーザーに最も近いデュアルリージョンにデュアルリージョンストレージを構成します。Standardストレージクラスを構成します<br>この選択肢が正しくない理由は以下の通りです。<br>デュアルリージョンストレージはデータ耐久性と冗長性が最優先の場合に有効なストレージオプションですが、余計なコストを進んで払うことになります。問題の要件では最小限のコストで最適なデータストレージを構成することが求められています。<br>そこで、リージョナルストレージが最もコスト効率のよい選択です。'>
<div class='choice'> ユーザーに最も近いリージョンにリージョナルストレージを構成します。Standardストレージクラスを構成します</div>
<div class='choice'> ユーザーに最も近いデュアルリージョンにデュアルリージョンストレージを構成します。Standardストレージクラスを構成します</div>
<div class='choice'> ユーザーに最も近いデュアルリージョンにデュアルリージョンストレージを構成します。Nearlineストレージクラスを構成します</div>
<div class='choice'> ユーザーに最も近いリージョンのリージョナルストレージを構成します。Nearlineストレージクラスを構成します</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題20<br>Compute Engineにデプロイしたい本番用とテスト用のワークロードがあります。本番用VMは、テスト用VMとは異なるサブネットにある必要があります。すべてのVMは、追加のルートを作成することなく、プライベートIPを介して互いに到達できなければなりません。VPCと2つのサブネットを設定する必要があります。<br>これらの要件を満たす構成はどれですか？' data-answer='2' data-explanation='解説<br>正解は「2つのサブネットで1つのカスタムVPCを作成します。それぞれのサブネットを異なるリージョンに、異なるCIDRレンジで作成します」です。<br>この問題では、Compute Engineを使用した本番用とテスト用のワークロードのデプロイ、およびそれらのVMが異なるサブネットに位置していなければならないという状況が描かれています。また、すべてのVMは、追加のルートを作らずにプライベートIPで互いに通信可能でなければならないと明示されています。そのため、適切なVPCとサブネットの設定を理解し、それを正しく選択肢と照らし合わせることが求められます。答えを出す際は、ネットワークの範囲（CIDRレンジ）とリージョン設定も含めて注意深く考慮する必要があります。<br>基本的な概念や原則：<br>Compute Engine：Google CloudのIaaSで、仮想マシンを生成し、管理することができます。ワークロードのデプロイに利用します。<br>VPC（Virtual Private Cloud）：Google Cloud上で使われる仮想ネットワークです。カスタムVPCはユーザーが必要に応じてサブネットを設定できます。<br>サブネット：ネットワークを細かく区切った単位です。異なるサブネットに割り当てられたリソースは論理的に分離されます。<br>CIDRレンジ：ネットワークのアドレス範囲を規定する手法の一つです。異なるCIDRレンジを設定することで複数のネットワークを同一のVPC内で分離することができます。<br>リージョン：Google Cloudのリソースを物理的に配置する地理的ロケーションです。サービスの可用性やレイテンシを管理する上で重要な要素です。<br>正解についての説明：<br>（選択肢）<br>・2つのサブネットで1つのカスタムVPCを作成します。それぞれのサブネットを異なるリージョンに、異なるCIDRレンジで作成します<br>この選択肢が正解の理由は以下の通りです。<br>Google CloudのカスタムVPCネットワークでは、複数のサブネットを異なるリージョンに作成でき、それぞれのサブネットには固有のIP範囲（CIDRレンジ）を割り当てることができます。それぞれのサブネットは他のサブネットとIP範囲を重ねずに管理できるため、本番用VMとテスト用VMを別々のサブネットに隔てる完全な環境分離を確保できます。<br>さらに、Google Cloud VPCでは、同一VPC内の異なるサブネット間では、デフォルトで内部（プライベート）IPを使って全通信が可能となっています。このため、追加のルートを作成することなく、本番用VMとテスト用VMがプライベートIPを介して互いに通信することができます。以上の特性により、選択肢が要件を満たします。<br>不正解の選択肢についての説明：<br>選択肢：2つのサブネットで1つのカスタムVPCを作成します。それぞれのサブネットを同じリージョンに、同じCIDRレンジで作成します<br>この選択肢が正しくない理由は以下の通りです。<br>異なるサブネットは、異なるCIDRレンジで作成しなければなりません。これは、同じCIDRレンジを持つ複数のサブネットを作成すると、IPアドレスの衝突が生じるためです。<br>また、同じリージョン内でもサブネットは互いに通信が可能です。正解の選択肢と比べて、この選択肢はIPアドレスの管理とリソースの配置に問題があります。<br>選択肢：カスタムVPCを2つ作成し、それぞれに1つのサブネットを設定します。それぞれのサブネットを異なるリージョンに、異なるCIDRレンジで作成します<br>この選択肢が正しくない理由は以下の通りです。<br>カスタムVPCを2つ作成した場合、それぞれ独立したネットワークスペースとなり、異なるVPC間の通信はデフォルトでは許可されていません。<br>このシナリオでは、たとえ追加のルートを作成しなくてもプライベートIPを介して通信する必要があります。<br>これに対して、正解の選択肢は1つのVPC内に2つのサブネットを作成することで、追加のルート無しでの通信を可能にします。<br>選択肢：カスタムVPCを2つ作成し、それぞれに1つのサブネットを設定します。それぞれのサブネットを同じリージョンに同じCIDRレンジで作成します<br>この選択肢が正しくない理由は以下の通りです。<br>カスタムVPCを2つ作成し、それぞれに1つのサブネットを設定すると、異なるVPC間ではデフォルトでネットワーク通信は行えないため、要件の"すべてのVMはプライベートIPを介して互いに到達できる"を達成できません。<br>それに対して、一つのカスタムVPC内に複数のサブネットを作成すれば、追加のルート作成なしでも通信が可能です。'>
<div class='choice'> 2つのサブネットで1つのカスタムVPCを作成します。それぞれのサブネットを同じリージョンに、同じCIDRレンジで作成します</div>
<div class='choice'> カスタムVPCを2つ作成し、それぞれに1つのサブネットを設定します。それぞれのサブネットを同じリージョンに同じCIDRレンジで作成します</div>
<div class='choice'> 2つのサブネットで1つのカスタムVPCを作成します。それぞれのサブネットを異なるリージョンに、異なるCIDRレンジで作成します</div>
<div class='choice'> カスタムVPCを2つ作成し、それぞれに1つのサブネットを設定します。それぞれのサブネットを異なるリージョンに、異なるCIDRレンジで作成します</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題21<br>Kubernetes用のGoogle Cloud Pricing Calculatorを使用して、Kubernetesクラスターのコスト見積もりを提供する必要があります。ワークロードには高いIOPが必要であり、ディスクスナップショットも使用することになります。まず、ノード数、平均時間、平均日数を入力します。<br>次に何をすべきですか？' data-answer='0' data-explanation='解説<br>正解は「ローカルSSDを記入します。永続ディスクストレージとスナップショットストレージを記入します」です。<br>この問題では、Kubernetesクラスターのコスト見積もりを提供するために必要な手順について問われています。特にワークロードに高いIOPが必要であり、ディスクスナップショットも使用するという要求があるため、これらの要素を包含する見積もりの作成が求められます。そのため、選択肢を見る際には、これらの要求を映し出すものを見つける必要があります。<br>基本的な概念や原則：<br>Google Cloud Pricing Calculator：Google Cloudの製品とサービスのコストを見積もるためのツールです。ユーザーが使用するリソースに基づいて、コストを試算できます。<br>Kubernetes：開放的なコンテナオーケストレーションシステムで、自動化されたアプリケーションのデプロイ、スケーリング、管理を可能にします。<br>ローカルSSD：高性能な局所的なボリュームで、Google Cloudのコンピューティングインスタンスに直接接続されます。高いIOPS（Input/Output Operations Per Second）と低い遅延時間を提供します。<br>永続ディスクストレージ：Google Cloudで提供されるブロックストレージサービスです。高い耐久性とスケーラビリティを提供し、バックアップやスナップショットなどの機能も含まれています。<br>スナップショットストレージ：データのサーバー間での移動やデータのバックアップなど、特定の瞬間のデータのコピーを保存するためのストレージ形式です。<br>正解についての説明：<br>（選択肢）<br>・ローカルSSDを記入します。永続ディスクストレージとスナップショットストレージを記入します<br>この選択肢が正解の理由は以下の通りです。<br>Google CloudのPricing Calculatorは、Google Cloudのリソース使用コストを見積もるためのツールで、さまざまなパラメータを入力して処理することが求められます。ユーザーが高いIOPSが必要であると指定しているため、パフォーマンスの観点から考えると、入力するべきリソースとしてローカルSSDが最適な選択肢です。ローカルSSDは非常に高速なディスクタイプであり、IOPS（入力/出力オペレーション/秒）が非常に高いためです。<br>また、ディスクスナップショットの使用が指定されているため、スナップショットストレージのコストも考慮する必要があります。これは、スナップショットが保存データのバックアップを提供し、いざという時のリカバリーや過去のデータ状態への戻りを可能にする一方で、保存されるデータ量に対するコストが発生するためです。<br>また、これらのデータを使用するアプリケーションやワークロードが常に稼働しているわけではないため、平均稼働時間と日数も重要なパラメータとなります。これらの情報を考慮に入れることで、より正確で実用的なコスト見積もりを得ることができます。<br>不正解の選択肢についての説明：<br>選択肢：ローカルSSDを記入します。クラスター管理の推定コストを追加します<br>この選択肢が正しくない理由は以下の通りです。<br>クラスター管理の推定コストを加えることは重要ですが、問題は高いIOPSとディスクスナップショットの使用に焦点を当てているため、永続ディスクストレージとスナップショットストレージの記入が重要です。これを無視してしまうとコスト見積もりが正確ではなくなります。<br>選択肢：Add GPUsを選択します。永続ディスクストレージとスナップショットストレージを入力します<br>この選択肢が正しくない理由は以下の通りです。<br>問題文中ではワークロードに高いIOPが必要であることが指定されており、GPUは主に計算能力を向上させることに関連しているため、これはIOP向上に対して直接的な影響を与えません。<br>それに対して、ローカルSSDはIOPを大幅に向上させるため、要件を満たす適切な選択肢です。<br>選択肢：Add GPUsを選択します。クラスター管理の推定コストを追加します<br>この選択肢が正しくない理由は以下の通りです。<br>問題文はIOPが高くディスクスナップショットが必要なワークロードのコスト見積もりを求めています。GPUの追加やクラスター管理の推定コストはIOPやスナップショットに直接関係ないため、関係のあるローカルSSD、永続ディスクストレージ、スナップショットストレージを記入する方が適切です。'>
<div class='choice'> ローカルSSDを記入します。永続ディスクストレージとスナップショットストレージを記入します</div>
<div class='choice'> Add GPUsを選択します。クラスター管理の推定コストを追加します</div>
<div class='choice'> Add GPUsを選択します。永続ディスクストレージとスナップショットストレージを入力します</div>
<div class='choice'> ローカルSSDを記入します。クラスター管理の推定コストを追加します</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題22<br>データウェアハウスのアーカイブソリューションを構築中で、データのアーカイブにCloud Storageを選択しました。ユーザは、いくつかの規制要件のために、四半期に一度、このアーカイブされたデータにアクセスできる必要があります。コスト効率の良いオプションを選択したいと考えています。どのストレージオプションを使用すべきですか？' data-answer='1' data-explanation='解説<br>正解は「Nearlineストレージ」です。<br>この問題では、データアクセスの頻度とコスト効率を考慮したストレージオプションの選択が求められています。四半期に一度のアクセスフォーマットでアーカイブデータにアクセスする必要があることは、オプションを比較検討時の重要な指標です。また、選択肢が全てCloud Storageの異なるストレージクラスであることから、各ストレージクラスの特性とコストを理解していることが求められます。<br>基本的な概念や原則：<br>Nearlineストレージ：Google Cloud Storageのストレージクラスの一つで、月に一度程度のアクセスが予想されるデータに適しています。ストレージコストは低い一方で、データへのアクセス時には少額の料金が発生します。<br>Coldlineストレージ：Google Cloud Storageのストレージクラスの一つで、年に一度かそれ以下の頻度でアクセスの予定があるデータに適しています。ストレージコストは非常に低いが、データアクセス時の料金はそれなりに発生します。<br>リージョンストレージ：Google Cloud Storageのデータが特定のデータセンターリージョン内でのみ保存されるストレージクラスです。このストレージクラスのデータに対するアクセスはそのリージョン内から最も速く、また安価に行うことができます。<br>マルチリージョンストレージ：Google Cloud Storageのデータが複数のデータセンターリージョンに複製されるストレージクラスです。このストレージクラスは、データの可用性と耐久性を最大化するための選択肢です。<br>正解についての説明：<br>（選択肢）<br>・Nearlineストレージ<br>この選択肢が正解の理由は以下の通りです。<br>Google Cloud Storageは様々なストレージクラスを提供していますが、アクセス頻度とコストのバランスを考えると、Nearlineストレージが最適です。Standard、Nearline、Coldline、Archiveの4つのストレージクラスがありますが、Nearlineは月に一度程度のデータアクセスに最適で、コストも比較的低いです。<br>一方、ColdlineやArchiveはそれぞれアクセスが年に1回あるいはそれ以下の場合に適しており、頻繁にデータにアクセスするとコストが上がります。<br>したがって、四半期に一度のアクセスにはNearlineストレージが最適で、コスト効率の観点からも妥当です。<br>また、規制要件の観点からも、Nearlineはデータの耐久性を維持する能力が高く、規制遵守の観点からも適しています。<br>不正解の選択肢についての説明：<br>選択肢：Coldストレージ<br>この選択肢が正しくない理由は以下の通りです。<br>Google Cloud StorageのオプションであるColdストレージは実際には存在せず、そのためこの選択肢は適切ではありません。正しい選択肢であるNearlineストレージは、月に一度かそれ以上のデータアクセスが必要な場合に適したストレージクラスです。<br>選択肢：リージョンストレージ<br>この選択肢が正しくない理由は以下の通りです。<br>リージョンストレージは、データの頻繁なアクセスが必要な場合に適したオプションですが、四半期に一度のアクセスだけ必要なケースにはコスト効率が良くない選択です。<br>一方、Nearlineストレージは月に一度のアクセスが予想されるデータに適し、コスト効率も良いためこちらが適切です。<br>選択肢：マルチリージョンストレージ<br>この選択肢が正しくない理由は以下の通りです。<br>マルチリージョンストレージは高可用性と高耐久性を提供しますが、頻繁にアクセスするデータに適しており、四半期に一度しかアクセスしないようなアーカイブデータに対してはコスト効率が良くありません。<br>それに対して、Nearlineストレージは月に一度までのアクセスに対してコスト効率が高く、四半期に一度のアクセスには適しています。'>
<div class='choice'> マルチリージョンストレージ</div>
<div class='choice'> Nearlineストレージ</div>
<div class='choice'> リージョンストレージ</div>
<div class='choice'> Coldストレージ</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題23<br>BigQueryで重要なクエリを実行する必要がありますが、大量のレコードを返すことが予想されます。そのためあなたは、クエリの実行にかかるコストを知りたいです。なお、現在BigQueryではオンデマンド料金を使用しています。<br>あなたはこの要件を満たすために、どうすればよいですか？' data-answer='1' data-explanation='解説<br>正解は「コマンドラインを使用してドライランクエリを実行し、読み取りバイト数を推定します。次に、Pricing Calculatorを使用して、その推定バイト数をドルに変換します」です。<br>この問題では、大量のレコードを扱うクエリのコストの見積もりを求め、特にオンデマンド料金モデルを使用しているBigQueryが問われています。見積もりの仕方としては、読み取りバイト数に注目し、これを価格に換算することが求められています。ただのレコード数ではなく、読み取りバイト数を根拠にすること、それをドルに換算するためにPricing Calculatorを使うこと、そしてオンデマンド料金モデルが採用されていることを考慮することが重要です。<br>基本的な概念や原則：<br>ドライランクエリ：実際にクエリを実行することなく、そのクエリが使用するデータの量を見積もるための手法です。コストと性能の見積もりに役立ちます。<br>読み取りバイト数：クエリが実行されるときに、読み取られるデータの総量です。BigQueryの課金は読み取ったデータの量に基づいて行われます。<br>Pricing Calculator：Google Cloudのサービスの利用コストを見積もるツールです。必要なリソースと利用時間に基づいて料金を計算します。<br>オンデマンド料金：リソースの実際の使用量に基づいて課金されるGoogle Cloudの料金体系です。利用量が不確定な場合や急激なスケーリングが必要な場合に適しています。<br>定額料金：固定の月額料金で一定のリソースを使用できるGoogle Cloudの料金体系です。一貫した使用量が想定される場合に適しています。<br>正解についての説明：<br>（選択肢）<br>・コマンドラインを使用してドライランクエリを実行し、読み取りバイト数を推定します。次に、Pricing Calculatorを使用して、その推定バイト数をドルに変換します<br>この選択肢が正解の理由は以下の通りです。<br>BigQueryでは、データ分析クエリの処理コストが大いに左右される主要な要素はスキャンしたデータのバイト数です。そのため、クエリの実行にかかるコストを事前に知るためには、予想される読み取りバイト数を知ることが重要です。コマンドラインからドライラン（Dry Run）クエリを実行することで、実際にクエリを実行することなく読み取りバイト数を推定することができます。<br>さらに、推定されたバイト数をGoogle Cloud Pricing Calculatorに入力することで、そのデータ操作によるコストを試算することができます。この方法により、予期せぬ高額な料金を発生させることなく、大量のレコードを返すクエリを実行するための準備をすることができます。<br>不正解の選択肢についての説明：<br>選択肢：このクエリを定額料金に切り替え、その後オンデマンドに戻します<br>この選択肢が正しくない理由は以下の通りです。<br>料金体系を一時的に切り替える行為は、クエリの実行コストを予測するための適切な解決策ではありません。これは料金体制の変更が計画や予算に関わる大掛かりな操作であり、さらに掛ける時間や手間も無視できません。<br>それに対して、正解の選択肢ではドライランクエリとPricing Calculatorを用いてコスト推定が可能で、手間や時間をかけることなくコストを予測することができます。<br>選択肢：コマンドラインを使用してドライランクエリを実行し、返されるバイト数を推定します。次に、Pricing Calculatorを使用して、その推定バイト数をドルに変換します<br>この選択肢が正しくない理由は以下の通りです。<br>ドライランクエリを実行しても返されるバイト数の推定は可能ではありません。ドライランクエリは実行すると必要となる読み取りバイト数を提供しますが、これは結果の行数や返されるデータ量には直接関連しません。そのため、正確なコスト推定のためには読み取りバイト数を使用するべきです。<br>選択肢：select count (*) を実行し、クエリで調べるレコードの数を把握します。次に、Pricing Calculatorを使用して、その行数をドルに変換します<br>この選択肢が正しくない理由は以下の通りです。<br>BigQueryの料金は返すレコードの数ではなく、実際にスキャンされるデータの量（バイト数）に基づきます。そのため、"select count (*)"を実行して行数を取得するだけでは、クエリの実行にかかるコストを正確に予測することは難しいです。<br>正解の選択肢のように、ドライランクエリを実行し、読み取りバイト数を推定することで実行コストを正確に推定出来ます。'>
<div class='choice'> コマンドラインを使用してドライランクエリを実行し、返されるバイト数を推定します。次に、Pricing Calculatorを使用して、その推定バイト数をドルに変換します</div>
<div class='choice'> コマンドラインを使用してドライランクエリを実行し、読み取りバイト数を推定します。次に、Pricing Calculatorを使用して、その推定バイト数をドルに変換します</div>
<div class='choice'> このクエリを定額料金に切り替え、その後オンデマンドに戻します</div>
<div class='choice'> select count (*) を実行し、クエリで調べるレコードの数を把握します。次に、Pricing Calculatorを使用して、その行数をドルに変換します</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題24<br>あなたは以下のオンプレミスのデータ管理ソリューションをGoogle Cloudに移行する予定です：<br>- メインデータベース用のMySQLクラスター<br>- イベントストリーミングプラットフォーム用のApache Kafka<br>- 分析およびレポーティングニーズ用のPostgreSQLデータベース用の1つのCloud SQL<br>移行にあたっては、Googleが推奨するソリューションを導入したいと考えています。また、新しいソリューションがグローバルなスケーラビリティを提供し、最小限の運用とインフラ管理が必要であることを確認する必要があります。<br>あなたはこの要件を満たすために、どうすればよいですか？' data-answer='0' data-explanation='解説<br>正解は「MySQLからCloud Spannerに移行します、KafkaからPub/Subに移行します、Cloud SQL for PostgreSQLからBigQueryに移行します」です。<br>この問題では、オンプレミスのデータ管理ソリューションをGoogle Cloudに移行する上でのベストなアプローチについて問われています。ここで重要な要素は、Googleが推奨しているソリューションの選択、新しいソリューションが提供するスケーラビリティ、そして最小限の運用とインフラ管理の必要性です。これらに照らすと、MySQL、Apache Kafka、PostgreSQLをそれぞれ何に移行するのが最良となるかを選択肢から選び出す問題になります。各サービスの特性と、要件を満たすための適切なGoogle Cloudのサービスを理解することが必須です。<br>基本的な概念や原則：<br>Cloud Spanner：Google Cloudのフルマネージド、リレーショナルデータベースで、水平方向スケーリングと強力なトランザクション一貫性を提供します。MySQLクラスターからの移行先として優れています。<br>Cloud Pub/Sub：Google Cloudのリアルタイムメッセージングサービスで、一貫性と信頼性が高く、グローバルなスケーリングが可能です。Kafkaからの移行先として適切です。<br>BigQuery：Google Cloudの高速な完全マネージドエンタープライズデータウェアハウスで、大量のデータに対するSQLクエリが可能です。PostgreSQLデータベースからの移行先として適切です。<br>Cloud SQL：Google CloudのフルマネージドSQLデータベースサービスで、MySQLとPostgreSQLが利用可能です。しかし、グローバルスケーラビリティや大量のデータへのクエリには限界があります。<br>Memorystore：RedisとMemcachedを使用したフルマネージド型インメモリデータストアサービスです。イベントストリーミングよりもキャッシュやセッションデータのホスティングに適しています。<br>正解についての説明：<br>（選択肢）<br>・MySQLからCloud Spannerに移行します、KafkaからPub/Subに移行します、Cloud SQL for PostgreSQLからBigQueryに移行します<br>この選択肢が正解の理由は以下の通りです。<br>最初に、Cloud SpannerはGoogle Cloudが提供するスケーラブルでグローバルに分散されたデータベースサービスで、MySQLのデータ管理システムを置き換えるために適しています。その優れたスケーラビリティと自動的なインフラ管理が求められています。<br>次に、Apache Kafkaの代替としてCloud Pub/Subが適切です。これは、プロジェクトがイベントストリーミングプラットフォームを求めていて、Pub/Subがその大規模なメッセージングやイベントストリームのニーズに応えています。<br>加えて、Pub/Subはフルマネージドサービスであるため、インフラ管理の手間を大幅に減らすことができます。<br>最後に、PostgreSQLデータベースをBigQueryに移行するのは妥当です。BigQueryは、インフラ管理の手間が少なく、また高度にスケーラブルな分析データウェアハウスサービスで、レポーティングと分析ニーズに対応しています。これら全てがGoogleの推奨するソリューションであるため、この選択肢が正しいです。<br>不正解の選択肢についての説明：<br>選択肢：MySQLからCloud SQLに移行し、KafkaからPub/Subに移行し、Cloud SQL for PostgreSQLからBigQueryに移行します<br>この選択肢が正しくない理由は以下の通りです。<br>メインデータベース用のサービスとしてCloud SQLを使用すると、グローバルなスケーラビリティが提供されず、インフラ管理も必要です。<br>一方、Cloud Spannerはグローバルなスケーラビリティを提供し、インフラ管理も最小限に抑えられるため、要件を満たします。<br>選択肢：MySQLからCloud Spannerに移行し、KafkaからMemorystoreに移行し、Cloud SQL for PostgreSQLからCloud SQLに移行します<br>この選択肢が正しくない理由は以下の通りです。<br>まず、Apache Kafkaの代替品としてMemorystoreを使用することは適切ではありません。Memorystoreはプライマリにキャッシュとして使用され、イベントストリーミングの用途には適していません。<br>また、Cloud SQL for PostgreSQLの代替としてCloud SQLを使用するのも誤りです。Cloud SQLは管理が必要でグローバルスケールにはならず、BigQueryのような分析用途には最適ではありません。<br>選択肢：MySQLからCloud SQLに移行し、KafkaからMemorystoreに移行し、Cloud SQL for PostgreSQLからCloud SQLに移行します<br>この選択肢が正しくない理由は以下の通りです。<br>まず、列指向データベースのBigQueryは、PostgreSQLを超える分析とレポーティング能力を提供します。<br>さらに、Memorystoreはイベントストリーミングのためのソリューションではなく、インメモリデータストアサービスで、Kafkaの代わりには適していません。<br>そして、Cloud SQLはグローバルスケーリングを提供するわけではないため、MySQLからCloud Spannerへの移行が推奨されます。'>
<div class='choice'> MySQLからCloud Spannerに移行します、KafkaからPub/Subに移行します、Cloud SQL for PostgreSQLからBigQueryに移行します</div>
<div class='choice'> MySQLからCloud SQLに移行し、KafkaからPub/Subに移行し、Cloud SQL for PostgreSQLからBigQueryに移行します</div>
<div class='choice'> MySQLからCloud SQLに移行し、KafkaからMemorystoreに移行し、Cloud SQL for PostgreSQLからCloud SQLに移行します</div>
<div class='choice'> MySQLからCloud Spannerに移行し、KafkaからMemorystoreに移行し、Cloud SQL for PostgreSQLからCloud SQLに移行します</div>
</div>
            <!-- 他の問題も同様に追加 -->
        </div>

        <h2 id="question"></h2>
        <ul class="choices" id="choices"></ul>
        <button onclick="checkAnswer()">採点</button>
        <button onclick="nextQuestion()" id="nextButton" style="display: none;">次の問題へ</button>
        <div class="result" id="result"></div>
    </div>

    <script>
        let currentQuestionIndex = 0;
        let correctCount = 0;
        const questions = [];

        document.addEventListener('DOMContentLoaded', () => {
            const questionElements = document.querySelectorAll('#quiz-data .question');
            questions.push(...Array.from(questionElements).map(questionElement => ({
                question: questionElement.getAttribute('data-question').replace(/\\n/g, '<br>'),
                choices: Array.from(questionElement.querySelectorAll('.choice')).map((choice, index) => ({
                    text: choice.innerHTML.replace(/\\n/g, '<br>'),  // innerHTMLに変更
                    index: index
                })),
                correctAnswer: questionElement.getAttribute('data-answer').split(',').map(Number),
                explanation: questionElement.getAttribute('data-explanation').replace(/\\n/g, '<br>'),
                multiple: questionElement.getAttribute('data-multiple') === 'true'
            })));
            showQuestion();
        });

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function showQuestion() {
            const questionElement = document.getElementById('question');
            const choicesContainer = document.getElementById('choices');
            const currentQuestion = questions[currentQuestionIndex];

            shuffleArray(currentQuestion.choices);

            questionElement.innerHTML = currentQuestion.question;
            choicesContainer.innerHTML = '';

            currentQuestion.choices.forEach((choice, i) => {
                const li = document.createElement('li');
                const input = document.createElement('input');
                const label = document.createElement('label');

                input.type = currentQuestion.multiple ? 'checkbox' : 'radio';
                input.name = 'choice';
                input.value = choice.index;
                input.id = 'choice' + i;

                label.htmlFor = 'choice' + i;
                label.innerHTML = choice.text;  // textContentをinnerHTMLに変更

                li.appendChild(input);
                li.appendChild(label);
                choicesContainer.appendChild(li);
            });

            document.getElementById('result').textContent = "";
            document.getElementById('nextButton').style.display = 'none';
        }

        function checkAnswer() {
            const currentQuestion = questions[currentQuestionIndex];
            const selectedChoices = Array.from(document.querySelectorAll('input[name="choice"]:checked'))
                                        .map(checkbox => parseInt(checkbox.value))
                                        .sort();
            const resultElement = document.getElementById('result');
            
            if (selectedChoices.length > 0) {
                const isCorrect = currentQuestion.multiple
                    ? selectedChoices.toString() === currentQuestion.correctAnswer.sort().toString()
                    : selectedChoices.length === 1 && selectedChoices[0] === currentQuestion.correctAnswer[0];
                
                if (isCorrect) {
                    resultElement.innerHTML = "正解です！<br>" + currentQuestion.explanation;
                    resultElement.style.color = "green";
                    correctCount++; // 正解数をカウント
                } else {
                    resultElement.innerHTML = "残念、不正解です。<br>" + currentQuestion.explanation;
                    resultElement.style.color = "red";
                }
                document.getElementById('nextButton').style.display = 'inline';
            } else {
                resultElement.textContent = "回答を選択してください。";
                resultElement.style.color = "orange";
            }
        }

        function nextQuestion() {
            currentQuestionIndex++;
            
            if (currentQuestionIndex < questions.length) {
                showQuestion();
            } else {
                showFinalResult();
            }
        }

        function showFinalResult() {
            const quizContainer = document.querySelector('.quiz-container');
            quizContainer.innerHTML = `
                <h2>問題終了！</h2>
                <p>あなたの正解数は ${correctCount} / ${questions.length} です。</p>
                <button onclick="restartQuiz()">再挑戦する</button>
            `;
        }

        function restartQuiz() {
            correctCount = 0;
            currentQuestionIndex = 0;

            // クイズのUI全体を初期化
            const quizContainer = document.querySelector('.quiz-container');
            quizContainer.innerHTML = `
                <h2 id="question"></h2>
                <ul class="choices" id="choices"></ul>
                <button onclick="checkAnswer()">採点</button>
                <button onclick="nextQuestion()" id="nextButton" style="display: none;">次の問題へ</button>
                <div class="result" id="result"></div>
            `;

            // 初期化後に最初の問題を表示
            showQuestion();
        }        
    </script>
</body>
</html>