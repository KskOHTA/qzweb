<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Google Cloud Leader問題集 15</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="quiz-container">
        <div id="quiz-data" style="display: none;">
<div class='question' data-multiple='FALSE' data-question='問題55<br>適切なIAMロールが定義された開発プロジェクトがあります。本番プロジェクトを作成し、できるだけ少ない手順で、新しいプロジェクトで同じIAMロールを使用したいと考えています。<br>あなたはこの要件を満たすために、どうすればよいですか？' data-answer='1' data-explanation='解説<br>正解は「gcloud iamロールコピーを使用し、本番プロジェクトをコピー先プロジェクトとして指定します」です。<br>この問題では、IAMロールを効率的に別のプロジェクトに適用する方法について問われています。ここでは、IAMロールの複製を少ない手順で行いたいという要件に注目すべきです。これらの選択肢を見るときには、操作のシンプルさや効率性を優先する解決策を探すことが重要になります。また、Google Cloudのツールやコマンドに捉われず、ご自身が抱えているニーズにフォーカスすることも大切です。<br>基本的な概念や原則：<br>gcloud iamロールコピー：gcloudコマンドラインツールの一部で、IAMロールを1つのプロジェクトから別のプロジェクトにコピーするために使用します。このコマンドにより、ロールの設定を迅速かつ容易に複製することができます。<br>IAMロール：Google Cloud IdentityとAccess Managementの一部で、一連の許可をまとめたものです。これらのロールをユーザー、サービスアカウント、グループに付与することで、特定のGoogle Cloudリソースに対するアクセスを管理します。<br>Google Cloud Console：Google Cloudリソースをビジュアルに管理するためのウェブインターフェースです。一部の機能（&#39;create role from role&#39;など）は、コマンドラインツールとは異なる操作が必要です。<br>プロジェクト：Google Cloud上でリソースを組織化する基本的な単位です。一つのプロジェクト内で設定されたIAMロールやネットワークは他のプロジェクトとは分離されています。<br>正解についての説明：<br>（選択肢）<br>・gcloud iamロールコピーを使用し、本番プロジェクトをコピー先プロジェクトとして指定します<br>この選択肢が正解の理由は以下の通りです。<br>まず、gcloudのiamロールコピーは、特定のプロジェクトに定義されたカスタムIAMロールを別のプロジェクトにコピーするためのコマンドです。これにより、既存のIAMロールがそのまま新しいプロジェクトに引き継がれ、手動で1つ1つの権限を再設定する必要がなくなります。これは、新しいプロジェクトで同様のIAMロールを使用するために求められる手順を大幅に減少させます。このコマンドは非常にパワフルであり、開発プロジェクトから本番プロジェクトへの移行、またはプロジェクト間でのIAMロールの一貫性確保など、さまざまなシチュエーションで有用性を発揮します。<br>したがって、既存のIAMロールを新しいプロジェクトに素早く適用したい場合、この選択肢が最適解です。<br>不正解の選択肢についての説明：<br>選択肢：gcloud iamロールコピーを使用し、コピー先の組織を指定します<br>この選択肢が正しくない理由は以下の通りです。<br>gcloud iamロールコピーは組織をコピー先として指定することはできません。このコマンドはプロジェクト間でのIAMロールの複製に用いられるため、あくまでコピー先には新しいプロジェクトを指定する必要があります。<br>選択肢：Google Cloud Consoleで、&#39;create role from role&#39;機能を使います<br>この選択肢が正しくない理由は以下の通りです。<br>Google Cloud Consoleには、&#39;create role from role&#39;という機能は存在しません。正確な操作を選択することが重要であり、この選択肢は実際の手順や機能を正しく反映していません。<br>一方、gcloud iamロールコピーはIAMロールを他のプロジェクトに簡単にコピーできます。<br>選択肢：Google Cloud Consoleで、&#39;create role&#39;機能を使用し、該当するすべての権限を選択します<br>この選択肢が正しくない理由は以下の通りです。<br>Google Cloud Consoleで&#39;create role&#39;機能を使用し、該当するすべての権限を選択する方法は、ロールをコピーする方法ではなく、新たに設定を行う手順です。<br>また、&#39;create role&#39;機能を用いると、開発プロジェクトのロールの設定を全て正確に覚えていなければならず、手間と時間がかかります。<br>しかし、gcloud iamロールコピー機能を用いると、一度定義されたIAMロールを新しいプロジェクトにコピーすることが可能となり、より少ない手順で新しいプロジェクトで既存のIAMロールを利用することができます。'>
<div class='choice'> gcloud iamロールコピーを使用し、コピー先の組織を指定します</div>
<div class='choice'> gcloud iamロールコピーを使用し、本番プロジェクトをコピー先プロジェクトとして指定します</div>
<div class='choice'> Google Cloud Consoleで、&#39;create role&#39;機能を使用し、該当するすべての権限を選択します</div>
<div class='choice'> Google Cloud Consoleで、&#39;create role from role&#39;機能を使います</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題56<br>あなたは、Compute Engineインスタンス上で実行されるサードパーティーアプリケーションを管理する必要があります。他のCompute Engineインスタンスは、デフォルト設定ですでに実行されています。アプリケーションのインストールファイルはCloud Storage上にホストされています。他の仮想マシン（VM）にこれらのファイルへのアクセスを許可せずに、新しいインスタンスからこれらのファイルにアクセスする必要があります。<br>あなたはこの要件を満たすために、どうすればよいですか？' data-answer='2' data-explanation='解説<br>正解は「新しいサービスアカウントを作成し、このサービスアカウントを新しいインスタンスに割り当てます。サービスアカウントにCloud Storageの権限を付与します」です。<br>この問題では、Compute Engineインスタンス上で実行されるアプリケーションの管理方法が求められています。特に、アプリケーションのインストールファイルに新しいインスタンスからだけアクセスし、他のVMからはアクセスできないようにする必要があります。この要求を満たすために重要な点は、適切なサービスアカウントの作成と、そのサービスアカウントに適切なアクセス権を付与することです。そして、そのアクセス権を用いて新しいインスタンスからファイルにアクセスできるようにすることが求められています。<br>基本的な概念や原則：<br>サービスアカウント：Google Cloudの認証と権限管理を行うための特殊なアカウントです。サービスアカウントを使用して、アプリケーションを代表して認証し、そのアプリケーションがリソースにアクセスできるようにすることができます。<br>Compute Engine：Google Cloudのインフラストラクチャーとしてのサービス（IaaS）で、仮想マシンを実行することができます。このサービスを使用して、大規模なデータ処理やデータ分析、機械学習のワークロードをクラウドで実行できます。<br>Cloud Storage：Google Cloudのオブジェクトストレージサービスです。データを安全に保存し、グローバル規模でのデータ配信やビッグデータの分析などに使用できます。<br>アクセス制御：Google Cloudでリソースに対するアクセスを管理するための制御機能です。IAMポリシーやサービスアカウントを通じて、特定のユーザーやアプリケーションに対して、必要なリソースへのアクセス権限だけを付与できます。<br>メタデータ：データに関するデータのことで、ファイルやオブジェクトの内容、構造、場所、作成日時などを示す情報です。<br>オブジェクトストレージ：ファイルをデータとメタデータの組み合わせとして保存し、HTTPベースのAPIでアクセスするストレージタイプです。スケーラビリティと耐久性に優れ、大量の静的なデータを低コストで保存するのに適しています。<br>権限の付与：サービスアカウントやIAMポリシーを使用して、Google Cloudでリソースへのアクセス権限を付与する行為です。必要最低限の権限を付与することで、セキュリティリスクを最小化します。<br>正解についての説明：<br>（選択肢）<br>・新しいサービスアカウントを作成し、このサービスアカウントを新しいインスタンスに割り当てます。サービスアカウントにCloud Storageの権限を付与します<br>この選択肢が正解の理由は以下の通りです。<br>サービスアカウントを使用することで、特定のVMからのみCloud Storageへのアクセスを制御することができます。新しいサービスアカウントを作成し、それを新しいインスタンスに割り当てることで、そのインスタンスからのみアクセスを許可することができます。<br>また、この新規サービスアカウントにCloud Storageへのアクセス権限を付与することで、新規インスタンスからCloud Storage上のファイルにアクセスすることができます。この流れは、他のVMからのアクセスを制限し、特定のインスタンスからのみアクセスを許可するという要件を満たします。<br>また、サービスアカウントを用いることで、安全性も確保できます。これは、アプリケーションやサービスがGoogle Cloudのリソースにアクセスするための特定のアイデンティティを提供します。<br>不正解の選択肢についての説明：<br>選択肢：デフォルトのCompute Engineサービスアカウントでインスタンスを作成します。サービスアカウントにCloud Storageの権限を付与します<br>この選択肢が正しくない理由は以下の通りです。<br>デフォルトのCompute Engineサービスアカウントを使用すると、他のCompute Engineインスタンスにも引き続きファイルへのアクセスが許可されてしまいます。<br>したがって、新しいインスタンスのみにアクセスを制限するという要件を満たしません。これに対して新しいサービスアカウントを作成すると、特定のインスタンスのみにアクセスを限定することができます。<br>選択肢：デフォルトのCompute Engineサービスアカウントでインスタンスを作成します。新しいインスタンスのメタデータと一致するメタデータをCloud Storage上のオブジェクトに追加します<br>この選択肢が正しくない理由は以下の通りです。<br>デフォルトのCompute Engineサービスアカウントは他のCompute Engineインスタンスと共有されているため、他のVMからのアクセスを避けることができません。<br>また、メタデータによる制御はアクセス制御に必要な細かさを提供していません。新しいサービスアカウントを作成することで、特定のアクセスのみを許可でき、要件を満たせます。<br>選択肢：新しいサービスアカウントを作成し、このサービスアカウントを新しいインスタンスに割り当てます。新しいインスタンスのメタデータと一致するメタデータをCloud Storage上のオブジェクトに追加します<br>この選択肢が正しくない理由は以下の通りです。<br>メタデータをCloud Storageのオブジェクトに追加しても、これが新しいインスタンスからのアクセス制御を確保するわけではありません。<br>また、新しいインスタンスからのアクセスを許可するために、サービスアカウントにCloud Storageの適切な権限を付与する必要があります。この選択肢ではその手順が欠けています。'>
<div class='choice'> デフォルトのCompute Engineサービスアカウントでインスタンスを作成します。新しいインスタンスのメタデータと一致するメタデータをCloud Storage上のオブジェクトに追加します</div>
<div class='choice'> デフォルトのCompute Engineサービスアカウントでインスタンスを作成します。サービスアカウントにCloud Storageの権限を付与します</div>
<div class='choice'> 新しいサービスアカウントを作成し、このサービスアカウントを新しいインスタンスに割り当てます。サービスアカウントにCloud Storageの権限を付与します</div>
<div class='choice'> 新しいサービスアカウントを作成し、このサービスアカウントを新しいインスタンスに割り当てます。新しいインスタンスのメタデータと一致するメタデータをCloud Storage上のオブジェクトに追加します</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題57<br>あなたは、他のチームと共有するプロジェクトで、Compute Engineインスタンス上にアプリケーションをホストする必要があります。他のチームが誤ってそのアプリケーションにダウンタイムを発生させないようにしたいと考えています。<br>この要件を満たすために、どの機能を使用すべきですか？' data-answer='3' data-explanation='解説<br>正解は「インスタンスの削除保護を有効にします」です。<br>この問題では、あなたがCompute Engineインスタンスとその上でホストされているアプリケーションを保護する方法について問われています。具体的には、他のチームによる誤っての削除によるダウンタイムを防ぐ手段について求められています。選択肢の中から、誤削除に対する保護機能を提供するものを探さなければなりません。これには、Google CloudのCompute Engine特有の設定や機能について理解している必要があります。<br>基本的な概念や原則：<br>インスタンスの削除保護：Compute Engineインスタンスの機能で、誤ってインスタンスを削除することを防ぎます。ダウンタイムの発生を予防します。<br>Shielded VM：Google Cloudの仮想マシンに対するセキュリティ強化機能です。脅威や攻撃に対する保護を提供します。<br>プリエンプティブVM：時間単位のレートが低価格のCompute Engineインスタンスで、Compute Engineが必要に応じてこれらのインスタンスを終了できます。<br>単一テナントノード：Google Cloudの物理サーバで、特定のユーザが専有します。リソースの共有を排除して、一貫性とパフォーマンスを保証します。<br>正解についての説明：<br>（選択肢）<br>・インスタンスの削除保護を有効にします<br>この選択肢が正解の理由は以下の通りです。<br>Google Cloudでは、Compute Engineインスタンスに対する変更を行うことは一部のユーザーに誤操作のリスクをもたらす可能性があります。そのような事態を防ぐために、Google Cloudは"インスタンスの削除保護"という機能を提供しています。この機能を有効にすると、誤ってインスタンスが削除されてしまう事態を防ぐことができます。つまり、これにより他のチームが誤ってアプリケーションにダウンタイムを発生させるのを防止することができます。<br>したがって、アプリケーションの稼働に重要なCompute Engineインスタンスを保護するためには、削除保護を有効にするのが適切な選択です。<br>不正解の選択肢についての説明：<br>選択肢：Shielded VMを使用します<br>この選択肢が正しくない理由は以下の通りです。<br>Shielded VMは、インターネットからの攻撃を防ぐための機能であり、他のチームによる誤操作でアプリケーションにダウンタイムを発生させないための保護を提供していません。<br>それに対して、インスタンスの削除保護を有効にすると、誤ってインスタンスを削除することで発生するダウンタイムを防止できます。<br>選択肢：プリエンプティブVMを使用します<br>この選択肢が正しくない理由は以下の通りです。<br>プリエンプティブVMは低コストで利用可能な一方で、最大24時間後やリソースが必要な場合に強制的に終了する特性を持つため、ダウンタイムを防ぐという目的には適していません。<br>それに対して、インスタンスの削除保護を有効にすると、誤ってインスタンスが削除されるのを防ぎダウンタイムを最小化できます。<br>選択肢：単一テナントノードを使用します<br>この選択肢が正しくない理由は以下の通りです。<br>単一テナントノードは特定の仮想マシンが専用の物理的ハードウェアに配置されるようにする機能です。この機能は主にライセンスや規制の制約を満たすために用いられますが、誤ってアプリケーションにダウンタイムを発生させることを防ぐものではありません。この目的にはインスタンスの削除保護機能を使うべきです。'>
<div class='choice'> 単一テナントノードを使用します</div>
<div class='choice'> Shielded VMを使用します</div>
<div class='choice'> プリエンプティブVMを使用します</div>
<div class='choice'> インスタンスの削除保護を有効にします</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題58<br>あなたは、自社のデータセンター内のベアメタルサーバーでアプリケーションをホスティングしています。そのアプリケーションはCloud Storageにアクセスする必要があります。しかし、セキュリティポリシーにより、アプリケーションをホストするサーバーがパブリックIPアドレスを持つことやインターネットにアクセスすることはできません。Googleが推奨するプラクティスに従って、アプリケーションにCloud Storageへのアクセスを提供したいと考えています。<br>あなたはこの要件を満たすために、どうすればよいですか？' data-answer='3' data-explanation='解説<br>正解は「1.Cloud VPNまたはInterconnectを使用して、Google CloudのVPCへのトンネルを作成します<br>2.Cloud Routerを使って、199.36.153.4/30のカスタムルートアドバタイズを作成します。そのネットワークをVPNトンネルを通してオンプレミスのネットワークにアドバタイズします<br>3.オンプレミスネットワークで、*.googleapis.comをCNAMEとしてrestricted.googleapis.comに解決するようにDNSサーバーを設定します」です。<br>この問題では、Google Cloud Storageにアクセスする必要がありますが、パブリックIPアドレスやインターネットへのアクセスが制限されたベアメタルサーバーの処理を求められています。つまり、限定された接続環境から安全にCloud Storageに接続する方法を選び出すことが求められています。そのためには、Googleが提供する様々なネットワーキングとセキュリティオプション、それらを適切に組み合わせて使用することで制限を超える独自のソリューションを理解することが不可欠です。<br>基本的な概念や原則：<br>ベアメタルサーバー：物理的なハードウェア上で直接動作するコンピューターシステムやサーバーのことを指します。仮想化された環境ではなく、ハードウェアに直接インストールされたオペレーティングシステム上で動作します。<br>Cloud Storage：Google Cloudのオブジェクトストレージサービスで、大量のデータを安全に保存し、世界中からアクセスすることができます。<br>Cloud VPN：オンプレミスネットワークとGoogle CloudのVPCネットワークを安全に接続するサービスです。IPsecとSSLを使用してデータを暗号化し、セキュリティを確保します。<br>Interconnect：Google Cloudへの専用の物理接続を提供します。高容量、低遅延、高信頼性の接続を可能にする特徴があります。<br>Cloud Router：BGPルーティングを使用して、Google CloudのVPCネットワークとオンプレミスネットワークの間で動的ルートを交換します。トラフィックの増減に応じて自動的にルートを調整します。<br>DNS設定：ドメイン名をIPアドレスに変換するサービスの設定です。この設定を変更することで、特定のドメイン名の解決先を制御できます。<br>正解についての説明：<br>（選択肢）<br>・1.Cloud VPNまたはInterconnectを使用して、Google CloudのVPCへのトンネルを作成します<br>2.Cloud Routerを使って、199.36.153.4/30のカスタムルートアドバタイズを作成します。そのネットワークをVPNトンネルを通してオンプレミスのネットワークにアドバタイズします<br>3.オンプレミスネットワークで、*.googleapis.comをCNAMEとしてrestricted.googleapis.comに解決するようにDNSサーバーを設定します<br>この選択肢が正解の理由は以下の通りです。<br>まず、Cloud VPNまたはInterconnectを使用してGoogle CloudのVPCへのトンネルを作成することで、自社のデータセンターとGoogle Cloud間のセキュアな通信チャネルを確立します。これは、公開IPアドレスやインターネットにアクセスすることが制限されているため非常に重要です。このトンネルを使用すると、アプリケーションからCloud Storageへのデータ転送が可能になります。<br>次に、Cloud Routerを使ってカスタムルートアドバタイズを作成します。指定されたネットワーク199.36.153.4/30はGoogleの限定公開IP範囲で、このルートをVPNトンネルを通じてオンプレミスのネットワークにアドバタイズすることで、オンプレミスのサーバーがこのIP範囲にあるCloud Storageに直接アクセスできるようになります。<br>最後に、オンプレミスネットワークではDNS解決を通じて共有する自社のDNSサーバを設定します。ここで*.googleapis.comがrestricted.googleapis.comにマッピングされるようにDNSを設定することで、限定公開のGoogleサービスに安全にアクセスすることができます。この組み合わせにより、ベアメタルサーバー上のアプリケーションは安全にCloud Storageにアクセスすることができます。<br>不正解の選択肢についての説明：<br>選択肢：1.nslookupを使ってstorage.googleapis.comのIPアドレスを取得します<br>2.セキュリティチームと交渉して、サーバーにパブリックIPアドレスを与えることができるようにします<br>3.これらのサーバーからstorage.googleapis.comのIPアドレスへのegressトラフィックのみを許可します<br>この選択肢が正しくない理由は以下の通りです。<br>まず、GoogleのIPアドレスは動的であり、事前にnslookupで取得したIPアドレスは変わる可能性があるため、安定した接続を保証できません。<br>また、セキュリティーポリシーではパブリックIPアドレスの使用やインターネットへのアクセスを禁止しています。<br>これに対し、正解の選択肢では、既存のセキュリティポリシーを尊重しつつ、安全なトンネル経由でCloud Storageにアクセスします。<br>選択肢：1.Cloud VPNを使用して、Google Cloudの仮想プライベートクラウド（VPC）へのVPNトンネルを作成します<br>2.このVPCで、Compute Engineインスタンスを作成し、このインスタンスにSquidプロキシサーバーをインストールします<br>3.そのインスタンスをプロキシとして使用してCloud Storageにアクセスするようにサーバーを設定します<br>この選択肢が正しくない理由は以下の通りです。<br>Compute Engineインスタンスを使用してSquidプロキシサーバーをインストールしたり、それをプロキシとして使用する手順は複雑で時間も費用もかかります。<br>それに対し、正解の選択肢はGoogleが推奨する安全で効率的なプラクティスで、これによりアプリケーションはCloud Storageに直接アクセスできます。<br>選択肢：1.Migrate for Compute Engine（旧Velostrata）を使用して、これらのサーバーをCompute Engineに移行します<br>2.storage.googleapis.comをバックエンドとする内部ロードバランサ（ILB）を作成します<br>3.新しいインスタンスがこのILBをプロキシとして使用するように設定します<br>この選択肢が正しくない理由は以下の通りです。<br>Migrate for Compute Engineを使用してサーバーをCompute Engineに移行すると、オンプレミスのセキュリティポリシーに違反する可能性があります。<br>また、ILBは特定のCompute Engineインスタンスをバックエンドとして使用し通信を分散するもので、Cloud Storageへのアクセスを直接提供しません。正解の選択肢では、オンプレミスのネットワークとGoogle CloudのVPCとの間にプライベート接続を作成し、オンプレミスネットワークからCloud Storageに直接アクセスします。'>
<div class='choice'><br>1.nslookupを使ってstorage.googleapis.comのIPアドレスを取得します<br>2.セキュリティチームと交渉して、サーバーにパブリックIPアドレスを与えることができるようにします<br>3.これらのサーバーからstorage.googleapis.comのIPアドレスへのegressトラフィックのみを許可します</div>
<div class='choice'><br>1.Cloud VPNを使用して、Google Cloudの仮想プライベートクラウド（VPC）へのVPNトンネルを作成します<br>2.このVPCで、Compute Engineインスタンスを作成し、このインスタンスにSquidプロキシサーバーをインストールします<br>3.そのインスタンスをプロキシとして使用してCloud Storageにアクセスするようにサーバーを設定します</div>
<div class='choice'><br>1.Migrate for Compute Engine（旧Velostrata）を使用して、これらのサーバーをCompute Engineに移行します<br>2.storage.googleapis.comをバックエンドとする内部ロードバランサ（ILB）を作成します<br>3.新しいインスタンスがこのILBをプロキシとして使用するように設定します</div>
<div class='choice'><br>1.Cloud VPNまたはInterconnectを使用して、Google CloudのVPCへのトンネルを作成します<br>2.Cloud Routerを使って、199.36.153.4/30のカスタムルートアドバタイズを作成します。そのネットワークをVPNトンネルを通してオンプレミスのネットワークにアドバタイズします<br>3.オンプレミスネットワークで、*.googleapis.comをCNAMEとしてrestricted.googleapis.comに解決するようにDNSサーバーを設定します</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題59<br>あなたの会社では、Google Cloudのプロジェクトに関係なく、すべての開発者が同じ権限を持つことを要求しています。また、会社のセキュリティポリシーでは、開発者の権限をCompute Engine、Cloud Functions、Cloud SQLに制限しています。さらに、最小限の労力でセキュリティポリシーを実装したいと考えています。<br>あなたはこの要件を満たすために、どうすればよいですか？' data-answer='3' data-explanation='解説<br>正解は「- Cloud IdentityのGoogleグループにすべての開発者を追加します<br>- Google Cloudの組織レベルで、Compute Engine、Cloud Functions、およびCloud SQL権限を持つカスタムロールを作成します」です。<br>この問題では、開発者全員がGoogle Cloudのプロジェクトに関わらず同じ権限を持ち、その権限が特定のサービスに限定され、またセキュリティポリシーを最小の労力で実装することが求められています。この要件を見ると、要件を満たすためには組織全体で権限を一元管理する方法が必要で、ロールの再利用やロールの範囲の制限も考えるべきポイントです。したがって、個々のプロジェクトよりも組織全体での権限管理を重視しなければならず、また、一度設定した権限の適用範囲を広くすることで労力を最小限に抑える方法を探すことが重要です。<br>基本的な概念や原則：<br>Cloud Identity：Google Cloudユーザーおよびグループのアイデンティティ管理サービスです。ユーザーアクセスの管理とセキュリティを強化するために使用されます。<br>Googleグループ：特定のメールリストに基づいてユーザーのグループを作成・管理するツールです。権限管理や共同作業を容易に行えます。<br>カスタムロール：特定のサービスへのアクセスに必要な権限をカスタマイズしたロールです。必要最低限の権限を付与することでセキュリティを確保します。<br>組織レベルのIAMポリシー：Google Cloudの最上位で設定されるIAMポリシーです。全てのプロジェクトに適用され、一元的に権限管理ができます。<br>Compute Engine：Google CloudのIaaS（Infrastructure as a Service）です。仮想マシンを提供し、コンピューティングリソースの計算作業を実行するのに使用されます。<br>Cloud Functions：Google CloudのFaaS（Functions as a Service）です。単一の関数の実行をクラウドで管理します。<br>Cloud SQL：Google CloudのRDBMSサービスです。MySQL, PostgreSQL, SQL Serverのインスタンスをフルマネージドで実行できます。<br>正解についての説明：<br>（選択肢）<br>・- Cloud IdentityのGoogleグループにすべての開発者を追加します<br>- Google Cloudの組織レベルで、Compute Engine、Cloud Functions、およびCloud SQL権限を持つカスタムロールを作成します<br>この選択肢が正解の理由は以下の通りです。<br>まず、Cloud IdentityのGoogleグループを作成し、すべての開発者をそのグループに追加することで、すべての開発者に対して一元的に権限管理を行うことが可能になります。一つのGoogleグループの中にすべての開発者をまとめることで、彼らがどのプロジェクトに関与するかに関係なく、同じ権限を保証することができます。<br>また、Google Cloudの組織レベルでカスタムロールを作成することで、必要なCompute Engine、Cloud Functions、およびCloud SQLの権限を持つ特定のロールを設定することができます。これにより、開発者の権限を会社が定めたセキュリティポリシーに合わせて制限することができます。このカスタムロールをGoogleグループに適用することで、最小限の労力でセキュリティポリシーを実装することが可能になります。<br>不正解の選択肢についての説明：<br>選択肢：- Google Cloudの組織内の1つのプロジェクトで、Compute Engine、Cloud Functions、およびCloud SQLの権限を持つカスタムロールを作成します<br>- gcloud iam roles copyコマンドを使用して、組織内に作成されたすべてのプロジェクトにロールをコピーします<br>この選択肢が正しくない理由は以下の通りです。<br>まず、各プロジェクトでカスタムロールを作成すると管理が煩雑になるため、セキュリティポリシーを最小限の労力で実装するという要件を満たすことができません。<br>また、gcloud iam roles copyコマンドを利用してロールをコピーすることは可能ですが、この選択肢は全ての開発者が同じ権限を持つという要件を考慮していないため、相応しくありません。<br>選択肢：- Google Groups for WorkspaceのGoogleグループにすべての開発者を追加します<br>- Google Cloudの組織レベルで、GoogleグループにCompute Adminの定義済みのロールを割り当てます<br>この選択肢が正しくない理由は以下の通りです。<br>まず、Google Groups for Workspaceを用いても開発者の管理は可能ですが、問題の要求は特定のサービスへのアクセスを制限したいということであり、これはCloud IdentityのGoogleグループでしか実現できません。<br>また、Compute Adminの定義済みのロールを割り当てると、所望のサービスに加えて余分な権限が付与される可能性があり、セキュリティポリシーに違反する恐れがあります。<br>選択肢：- すべての開発者をCloud IdentityのGoogleグループに追加します<br>- Google Cloudの組織内の各プロジェクトのGoogleグループに、Compute Engine、Cloud Functions、およびCloud SQL権限の定義済みロールを割り当てます<br>この選択肢が正しくない理由は以下の通りです。<br>この方法では、新たなプロジェクトが作成されるたびにそれぞれのプロジェクトで権限を設定しなければならず、管理労力が増えます。<br>一方、組織レベルでのカスタムロール作成は、一度設定すれば全プロジェクトに適用されるため、最小限の労力で要件を満たすことができます。'>
<div class='choice'><br>- Google Groups for WorkspaceのGoogleグループにすべての開発者を追加します<br>- Google Cloudの組織レベルで、GoogleグループにCompute Adminの定義済みのロールを割り当てます</div>
<div class='choice'><br>- すべての開発者をCloud IdentityのGoogleグループに追加します<br>- Google Cloudの組織内の各プロジェクトのGoogleグループに、Compute Engine、Cloud Functions、およびCloud SQL権限の定義済みロールを割り当てます</div>
<div class='choice'><br>- Google Cloudの組織内の1つのプロジェクトで、Compute Engine、Cloud Functions、およびCloud SQLの権限を持つカスタムロールを作成します<br>- gcloud iam roles copyコマンドを使用して、組織内に作成されたすべてのプロジェクトにロールをコピーします</div>
<div class='choice'><br>- Cloud IdentityのGoogleグループにすべての開発者を追加します<br>- Google Cloudの組織レベルで、Compute Engine、Cloud Functions、およびCloud SQL権限を持つカスタムロールを作成します</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題60<br>組織内のDevOpsグループは、開発プロジェクト内のCompute Engineリソースを完全に制御する必要があります。しかし、プロジェクト内の他のリソースを作成したり更新したりする権限を持ってはいけません。また、Googleの推奨するDevOpsグループの権限設定に従う必要があります。<br>あなたはこの要件を満たすために、どうすればよいですか？' data-answer='3' data-explanation='解説<br>正解は「基本ロールroles/viewerと定義済みロールroles/compute.adminをDevOpsグループに付与します」です。<br>この問題では、特定の要件に適したGoogle Cloudの権限設定を理解することが求められています。DevOpsグループはCompute Engineリソースに対する全制御権を必要としていますが、他のリソースに対する作成や更新権限は持ってはいけません。また、Googleの推奨する権限設定に従わなければならないという条件もあります。従って、選択肢を評価する際には、これらの要件を満たすとともに、Googleの推奨する権限設定に適合するものを選ぶことが重要です。<br>基本的な概念や原則：<br>基本ロール（Primitive roles）：Owner、Editor、Viewerといった基本的な権限設定で、IAMポリシーに付与することができます。一部のリソースに対するアクセス制御はこれらの基本ロールだけでなく、より具体的なロールも組み合わせる必要があります。<br>定義済みロール（Predefined roles）：特定のサービスやリソースに対する詳細なアクセス権限を付与するための役割です。Compute Engineのリソース管理のためのロールが存在します。<br>roles/viewer：Google Cloudリソースの閲覧権限を付与する基本ロールです。<br>roles/compute.admin：Compute Engineリソースに対する管理権限（作成、変更、削除など）を付与する定義済みロールです。<br>IAMポリシー：Google Cloudリソースへのアクセス権を管理するためのルールセットです。特定のユーザーグループやサービスアカウントに対して、特定の権限を付与するために使用します。<br>カスタムロール：特定のリソースに対する独自のアクセスルールを定義するための役割です。特定のニーズに合わせてカスタマイズすることができます。<br>正解についての説明：<br>（選択肢）<br>・基本ロールroles/viewerと定義済みロールroles/compute.adminをDevOpsグループに付与します<br>この選択肢が正解の理由は以下の通りです。<br>まず、Compute Engineリソースを制御するために、&#39;roles/compute.admin&#39;という定義済みロールが必要です。このロールはCompute Engineリソースに関するほぼすべての権限を持つため、DevOpsグループがCompute Engineリソースの完全な制御を適切に行えるようになります。<br>次に、&#39;roles/viewer&#39;という基本ロールは、プロジェクト内の他のリソースを参照（閲覧）するための権限を提供します。これにより、DevOpsグループはCompute Engine以外のリソースについても情報を見ることができ、しかしリソースの作成や更新は行えません。つまり、他のリソースの制御ができないようにする要件を満たせます。<br>したがって、Googleの推奨するDevOpsグループの権限設定に基づき、開発プロジェクト内のCompute Engineリソースを制御し、他のリソースは閲覧のみ可能にするために、基本ロールの&#39;roles/viewer&#39;と定義済みロールの&#39;roles/compute.admin&#39;をDevOpsグループに付与するのが適切です。<br>不正解の選択肢についての説明：<br>選択肢：IAMポリシーを作成し、そのポリシーにすべてのcompute.instanceAdmin.*権限を付与します。ポリシーをDevOpsグループにアタッチします<br>この選択肢が正しくない理由は以下の通りです。<br>IAMポリシーを作成し、compute.instanceAdmin.*権限を全て付与すると、DevOpsグループはCompute Engineリソースを制御することができますが、Googleの推奨する権限設定である基本ロールのroles/viewerと定義済みロールのroles/compute.adminとは異なります。ここで求められているのはGoogleの推奨する権限設定への従い方であり、不正解の選択肢はその要件を満たしていません。<br>選択肢：フォルダレベルでカスタムロールを作成し、そのロールにすべてのcompute.instanceAdmin.*権限を付与します。カスタムロールをDevOpsグループに付与します<br>この選択肢が正しくない理由は以下の通りです。<br>フォルダレベルでカスタムロールを作成し、そのロールにすべてのcompute.instanceAdmin.*権限を付与する方法では、Googleの推奨するDevOpsグループの権限設定に従っていない可能性があります。<br>一方で、基本ロールのroles/viewerと定義済みロールのroles/compute.adminを付与する方法は、Googleが推奨するロールと権限設定により一致しているため、この選択肢が正解です。<br>選択肢：DevOpsグループに基本ロールroles/editorを付与します<br>この選択肢が正しくない理由は以下の通りです。<br>基本ロールのroles/editorをDevOpsグループに付与すると、プロジェクト内の全てのリソースに対し作成や更新などの権限を与えてしまい、要件に反します。逆に正解の選択肢は、Compute Engineリソースに対するフル権限とその他のリソースに対する閲覧のみの権限を付与し、要件を満たすものとなっています。'>
<div class='choice'> フォルダレベルでカスタムロールを作成し、そのロールにすべてのcompute.instanceAdmin.*権限を付与します。カスタムロールをDevOpsグループに付与します</div>
<div class='choice'> IAMポリシーを作成し、そのポリシーにすべてのcompute.instanceAdmin.*権限を付与します。ポリシーをDevOpsグループにアタッチします</div>
<div class='choice'> DevOpsグループに基本ロールroles/editorを付与します</div>
<div class='choice'> 基本ロールroles/viewerと定義済みロールroles/compute.adminをDevOpsグループに付与します</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題61<br>組織内のすべての開発チームは東京にあります。各開発チームは独自のGoogle Cloudプロジェクトを持っています。各開発チームが東京内のクラウドリソースしか作成できないように、アクセスを制限したいと考えています。<br>あなたはこの要件を満たすために、どうすればよいですか？' data-answer='3' data-explanation='解説<br>正解は「すべての開発プロジェクトを格納するフォルダを作成します。東京内のリソースを制限する組織ポリシーを作成します」です。<br>この問題では、全ての開発チームが東京内のGoogle Cloudリソースのみを使えるように制限する方法を問われています。Google Cloudでは基本的にIAMでアクセス制御を行いますが、ソリューションとして考えられるのがIAMの活用でなく組織ポリシーの利用です。その際の注意点として、正解選択肢に挙げられているように、リソースのリージョン制限はIAMポリシーを作成することではなく組織ポリシーを使って適用することが求められている点です。また、全ての開発プロジェクトが具体的な制限を受ける対象ということからも、フォルダーレベルで組織ポリシーを設定することが適切です。<br>基本的な概念や原則：<br>Google Cloudプロジェクト：Google Cloudで作成する最小の作業単位です。各プロジェクトは独立した管理、リソース、設定を持ちます。<br>フォルダ：Google Cloudのリソース階層構造の一部で、プロジェクトや他のフォルダを保持できます。親子関係を持つ複数のリソースを一元的に管理するのに便利です。<br>組織ポリシー：Google Cloudの特定の設定や制限を一元的に管理するためのツールです。リソースの存在場所や利用できるサービスなどを制御できます。<br>IAM（Identity and Access Management）：Google Cloudのアクセス制御機能です。ユーザーやサービスアカウントのアクセス権限を定義・管理できます。<br>リージョンとゾーン：Google Cloudの地理的なインフラストラクチャの位置を表すための用語です。東京などの地域を指定してリソースの位置を制限することができます。<br>正解についての説明：<br>（選択肢）<br>・すべての開発プロジェクトを格納するフォルダを作成します。東京内のリソースを制限する組織ポリシーを作成します<br>この選択肢が正解の理由は以下の通りです。<br>まず、Google Cloudは階層型のリソース管理を提供しています。それは組織、フォルダ、プロジェクトという形で表現されており、組織全体や個々のフォルダ、プロジェクトに特定のポリシーを適用することができます。<br>この問題では、すべての開発チームが独自のGoogle Cloudプロジェクトを持っており、それらのリソースの作成を東京に限定したいという要求があります。<br>したがって、すべての開発プロジェクトを一つのフォルダに格納するというアプローチは理にかなっています。<br>次に、この新しいフォルダに、東京内のリソースのみを許可する組織ポリシーを適用します。これにより、フォルダに含まれるすべてのプロジェクトのリソース作成が東京に限定され、他のリージョンでリソースを作成しようとするとアクセスが拒否されます。<br>したがって、この方法は組織内のすべての開発チームが東京内のクラウドリソースしか作成できないという要件を満たします。<br>不正解の選択肢についての説明：<br>選択肢：すべての開発プロジェクトを含む組織を作成します。IAM（Identity and Access Management）ポリシーを作成し、東京リージョンのリソースを制限します<br>この選択肢が正しくない理由は以下の通りです。<br>IAMポリシーはリソースの位置を制限するためのものではなく、あくまでアクセスレベルの制御を行うためのものです。そのため、IAMで地理的なリソースの制限を行うことはできません。<br>選択肢：IAM（Identity and Access Management）ポリシーを作成して、リソースの場所を東京内に制限します。このポリシーをすべての開発プロジェクトに適用します<br>この選択肢が正しくない理由は以下の通りです。<br>IAMポリシーではリソースの地理的場所に対する制限設定はできません。IAMポリシーはユーザーやサービスアカウントに対するリソースへのアクセス権限を管理するためのもので、リソース作成の地理的制限は組織ポリシーを使用します。<br>選択肢：IAM（Identity and Access Management）ポリシーを作成して、すべての開発プロジェクトのリソースの場所を制限します。ポリシーをすべての開発ロールに適用します<br>この選択肢が正しくない理由は以下の通りです。<br>IAMポリシーは認証と認可を管理するためのものであり、特定の地理的なリソースの制限といったリソースの場所に関する方針を設定することはできません。そのため、リソースの場所を制限するためには組織ポリシーを使用するのが適切です。'>
<div class='choice'> IAM（Identity and Access Management）ポリシーを作成して、すべての開発プロジェクトのリソースの場所を制限します。ポリシーをすべての開発ロールに適用します</div>
<div class='choice'> IAM（Identity and Access Management）ポリシーを作成して、リソースの場所を東京内に制限します。このポリシーをすべての開発プロジェクトに適用します</div>
<div class='choice'> すべての開発プロジェクトを含む組織を作成します。IAM（Identity and Access Management）ポリシーを作成し、東京リージョンのリソースを制限します</div>
<div class='choice'> すべての開発プロジェクトを格納するフォルダを作成します。東京内のリソースを制限する組織ポリシーを作成します</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題62<br>あなたは、Google Kubernetes Engine（GKE）の上に製品を構築しています。あなたは1つのGKEクラスターを持っています。顧客ごとにそのクラスター内でポッドが実行され、顧客はそのポッド内で任意のコードを実行できます。あなたは顧客のポッド間の分離を最大化したいと考えています。<br>この要件を満たすためには、どうすればよいですか？' data-answer='3' data-explanation='解説<br>正解は「サンドボックスタイプがgvisorに設定されたGKEノードプールを作成します。顧客のポッドの仕様にruntimeClassName: gvisorというパラメータを追加します」です。<br>この問題では、Google Kubernetes Engine（GKE）を使用し、顧客のポッド間の分離を最大限にしたいという要求が出されています。顧客は任意のコードをポッド内で実行可能なため、不正なアクセスや攻撃を防ぐためには分離が必要です。したがって、各顧客のワークロードを適切に分離するための最善のGKEの機能や設定法を選択することが求められます。最適化、セキュリティ、分離技術等についての理解を深めることが重要です。<br>基本的な概念や原則：<br>Google Kubernetes Engine（GKE）：Google CloudのマネージドKubernetesサービスです。GKEは、コンテナ化されたアプリケーションのデプロイ、スケーリング、および管理を容易にします。<br>gVisor：Googleが開発したオープンソースのサンドボックスランタイムです。gVisorは、コンテナとホストカーネルとの間のアイソレーションを強化し、各コンテナ内のアプリケーションがシステム全体に影響を与えることを防ぐために使用されます。<br>Node pool：GKEクラスター内のノード（VMインスタンス）のグループです。Node poolは共通の設定、例えば、マシンタイプ、ディスクタイプ、ネットワークポリシー等を共有します。<br>Binary Authorization：Google Cloudのサービスで、コンテナイメージが特定の基準を満たしているかどうかを確認するために使用します。これにより、不適切なイメージがデプロイされるのを防ぐことができます。<br>Container Analysis API：ソフトウェアアーティファクトのメタデータを取得、分析、報告するためのGoogle Cloudのサービスです。これは、脆弱性評価やコンプライアンスをチェックして、コンテナのセキュリティを向上させるのに役立ちます。<br>Node selector：Kubernetesの機能で、特定のノード上でポッドをスケジュールするために使われます。これにより、ポッドが特定のリソース、ハードウェア、OS等を持つノード上で動作することを確保できます。<br>正解についての説明：<br>（選択肢）<br>・サンドボックスタイプがgvisorに設定されたGKEノードプールを作成します。顧客のポッドの仕様にruntimeClassName: gvisorというパラメータを追加します<br>この選択肢が正解の理由は以下の通りです。<br>まず、GKEのgvisorという機能を活用します。gvisorは、Googleが開発した軽量なコンテナランタイムで、それ自体がハードウェアに対する抽象レイヤーを提供することでアプリケーションからカーネルへのシステムコールを直接処理します。つまり、gvisorを使うことにより、カーネルの脆弱性からコンテナを守る新たなレイヤーが追加され、顧客が実行できるコードの範囲が制限されます。これにより、顧客間の分離をさらに強化することができます。<br>次に、具体的な手法として、GKEノードプールを作成する際に、サンドボックスタイプにgvisorを指定します。<br>その後、顧客のポッドの仕様に：&#39;runtimeClassName: gvisor&#39;というパラメータを追加します。これにより、顧客ごとのポッドがgvisorによって提供される隔離レイヤーで動作するようになり、またgvisorを使用することにより顧客が実行することができるコードに制約を加えることで、顧客間の分離を最大化できます。<br>不正解の選択肢についての説明：<br>選択肢：Binary Authorizationを使用して、顧客のポッドで使用されるコンテナイメージのみをホワイトリストに登録します<br>この選択肢が正しくない理由は以下の通りです。<br>問題の主要な要件は"顧客のポッド間の分離を最大化"することですが、Binary Authorizationはコンテナイメージの保証とホワイトリスト化を提供するためのもので、ポッド間の分離に対する具体的な解決策とはなりません。<br>一方、gvisorはコンテナのランタイムであり、あるコンテナが他のコンテナやホストシステムに影響を与えるのを防ぐための独立性とセキュリティを提供します。<br>選択肢：Container Analysis APIを使用して、顧客のポッドで使用されるコンテナの脆弱性を検出します<br>この選択肢が正しくない理由は以下の通りです。<br>Container Analysis APIはコンテナの脆弱性を検出するためのものであり、プロセス同士の分離を行うものではありません。これは顧客間のポッド分離という要件に寄与しません。<br>一方、gVisorはカーネルを分離するランタイムであり、顧客の間でアプリケーションを隔離することができます。<br>選択肢：GKEノードにはcos_containerdイメージを使用します。cloud.google.com/gke-os-distribution: cos_containerdという値を持つnodeSelectorを顧客のポッドの仕様に追加します<br>この選択肢が正しくない理由は以下の通りです。<br>cos_containerdイメージを使用するだけでは、顧客のポッド間の分離を最大化することができません。新たにnodeSelectorを追加しても、任意のコードを実行できる顧客のポッド間で相互に影響を与える可能性があります。<br>一方、gvisorによって生成されるサンドボックスでは、各ポッドが独立した実行環境を持つため、分離が最大化されます。'>
<div class='choice'> Binary Authorizationを使用して、顧客のポッドで使用されるコンテナイメージのみをホワイトリストに登録します</div>
<div class='choice'> Container Analysis APIを使用して、顧客のポッドで使用されるコンテナの脆弱性を検出します</div>
<div class='choice'> GKEノードにはcos_containerdイメージを使用します。cloud.google.com/gke-os-distribution: cos_containerdという値を持つnodeSelectorを顧客のポッドの仕様に追加します</div>
<div class='choice'> サンドボックスタイプがgvisorに設定されたGKEノードプールを作成します。顧客のポッドの仕様にruntimeClassName: gvisorというパラメータを追加します</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題63<br>以下のYAMLファイルを使って、cjpapp1というマイクロサービスをGoogle Kubernetes Engineクラスターにデプロイしました：<br>apiVersion: apps/v1<br>kind: Deployment<br>metadata:<br>name: cjpapp1-deployment<br>spec:<br>selector:<br>matchLabels:<br>app: cjpapp1<br>replicas: 2<br>template:<br>metadata:<br>labels:<br>app: cjpapp1<br>spec:<br>containers:<br>- name: main-container<br>image: gcr.io/cloud-jp-repo/cjpapp1:1.4<br>env:<br>- name: DB_PASSWORD<br>value: "c0mplicatedpassword!"<br>ports:<br>- containerPort: 8080<br>データベースのパスワードがプレーンテキストで保存されないように、この設定をリファクタリングする必要があります。あなたは、Googleが推奨するプラクティスに従う必要があります。<br>この要件を満たすために、どうすればよいですか？' data-answer='2' data-explanation='解説<br>正解は「データベースのパスワードをSecretオブジェクトに格納します。シークレットからDB_PASSWORD環境変数を入力するようにYAMLファイルを修正します」です。<br>この問題では、マイクロサービスの構成情報がYAMLファイルに保存され、特にデータベースのパスワードが平文で保存されている状況を解決する必要があります。ここで大切な点は、Google Cloudのセキュリティ慣行と、Kubernetesのオブジェクトモデルに関する理解です。各選択肢がこの目的を達成するために、どのように機能し、どの程度それが安全なのかを考えてみてください。データセキュリティと利便性のバランスをとるための解決策を探ることが重要です。<br>基本的な概念や原則：<br>Google Kubernetes Engine（GKE）：Google CloudのマネージドKubernetesサービスです。コンテナ化されたアプリケーションの運用負荷を軽減し、セキュリティと信頼性を維持しながら効果的にスケーリングします。<br>YAMLファイル：デプロイメント設定やキューブネットリソース設定を記述するためのファイル形式です。多くのDevOpsツールで広く使用されています。<br>Secretオブジェクト：Kubernetesでは、機密情報（パスワード、APIキーなど）を安全に保存し、Podから参照できるようにするためのAPIオブジェクトです。<br>ConfigMap：Kubernetesにおいて、設定情報を管理するためのAPIオブジェクトです。ただし、機密情報はSecretを使用すべきです。<br>Dockerイメージ：ソフトウェアを実行するために必要な全ての依存関係を含むパッケージです。しかし、パスワードやAPIキーなどの機密情報は含めるべきではありません。<br>正解についての説明：<br>（選択肢）<br>・データベースのパスワードをSecretオブジェクトに格納します。シークレットからDB_PASSWORD環境変数を入力するようにYAMLファイルを修正します<br>この選択肢が正解の理由は以下の通りです。<br>まず、パスワードやその他の機密性のある情報はプレーンテキストで保存するべきではありません。SecretオブジェクトはKubernetesがこのタイプの情報を保存するために提供しているリソースです。それはプレーンテキストによる情報漏洩を防ぐために、セキュアに情報を保存し、必要となるコンテナやポッドへと渡すことができます。<br>次に、環境変数をデバッグやログ出力のミスで露出する可能性があるため、パスワードなどの機密性の高い情報を格納するために使用するべきではありません。そのため、Secretオブジェクトを利用して機密情報を保持し、それを容器に注入することで、データの安全性を担保しつつ、アプリケーションが必要とする情報を提供することができます。<br>以上の点から、機密性のある情報を保護するためには、Secretオブジェクトに格納し、それを使って環境変数を設定することが最善の方法です。<br>不正解の選択肢についての説明：<br>選択肢：データベースのパスワードは、YAMLファイルではなく、コンテナのDockerイメージ内に保存します<br>この選択肢が正しくない理由は以下の通りです。<br>Dockerイメージ内にパスワードを保存すると、イメージが共有されたときにセキュリティリスクが生じます。Googleは、秘密情報をSecretオブジェクトに格納することを推奨しています。これにより、クラスター内の複数のアプリケーションで秘密情報が安全に共有され、秘密情報の暴露リスクが軽減されます。<br>選択肢：データベースのパスワードをConfigMapオブジェクトに格納します。YAMLファイルを修正して、ConfigMapからDB_PASSWORD環境変数を投入します<br>この選択肢が正しくない理由は以下の通りです。<br>ConfigMapは構成データを保存するために使用されますが、これはセキュリティを重視せず、プレーンテキストで保存されます。<br>一方、Secretオブジェクトはセンシティブな情報（例えばパスワード）を保存および管理するために設計されており、データは暗号化されて保存されます。<br>従って、パスワード保存にはSecretオブジェクトが適しています。<br>選択肢：データベースのパスワードをKubernetesの永続ボリューム内のファイルに格納し、永続ボリュームクレームを使用してボリュームをコンテナにマウントします<br>この選択肢が正しくない理由は以下の通りです。<br>永続ボリュームはデータの永続性や容量確保などを主に目的としたストレージであり、機密情報を安全に保管するためには設計されていません。機密情報管理にはSecretオブジェクトを使用することが推奨されます。これは、パスワードなどの機密情報を暗号化し、アクセスを制限する能力を持っています。'>
<div class='choice'> データベースのパスワードをKubernetesの永続ボリューム内のファイルに格納し、永続ボリュームクレームを使用してボリュームをコンテナにマウントします</div>
<div class='choice'> データベースのパスワードをConfigMapオブジェクトに格納します。YAMLファイルを修正して、ConfigMapからDB_PASSWORD環境変数を投入します</div>
<div class='choice'> データベースのパスワードをSecretオブジェクトに格納します。シークレットからDB_PASSWORD環境変数を入力するようにYAMLファイルを修正します</div>
<div class='choice'> データベースのパスワードは、YAMLファイルではなく、コンテナのDockerイメージ内に保存します</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題64<br>あなたは最近、開発者が開発プロセスで多くのサービスアカウントキーを使用していることを発見しました。長期的な改善に取り組む一方で、社内で短期間のサービスアカウント認証情報を強制するプロセスを迅速に実装する必要があります。以下の要件があります：<br>- キーを必要とするすべてのサービスアカウントは、pj-saという一元化されたプロジェクトで作成します。<br>- サービスアカウントキーは1日のみ有効である必要があります。<br>コストを最小限に抑えるGoogle推奨のソリューションが必要です。<br>この要件を満たすために、どうすればよいですか？' data-answer='2' data-explanation='解説<br>正解は「サービスアカウントキーの有効期間を24時間とすることを許可する組織ポリシー制約を強制します。pj-saの例外を除いて、サービスアカウントキーの作成を拒否する組織ポリシー制約を強制します」です。<br>この問題では、Google Cloud内で開発者によって使われている多数のサービスアカウントキーの寿命を短期間に強制する解決策を探しています。問題文が強調している要点は、サービスアカウントキーの寿命を1日にし、それらのサービスアカウントは特定のプロジェクトであるpj-saで生成されなければならない、ということです。また、コストを抑える必要があるという制約もあります。これらの要点を基に、問題の解決策を探すためには、Google Cloudの機能やサービスの中から、サービスアカウントキーの生成や寿命を制御できるもの、特定のプロジェクトでの生成を強制できるものを選び出す必要があります。<br>基本的な概念や原則：<br>サービスアカウント：Google Cloudにおいて、アプリケーションや仮想マシン、管理用APIなどがGoogle Cloudのリソースにアクセスするための特殊なGoogleアカウントです。<br>サービスアカウントキー：サービスアカウントを認証するための鍵です。このキーを持つ者はサービスアカウントの全権限を持つことも可能です。<br>一元化プロジェクト：特定の種類のリソースを管理するために設けられたGoogle Cloudのプロジェクトです。ここでは、サービスアカウントの作成に使用されます。<br>組織ポリシー：Google Cloudのリソースに対する制約や設定を定義するためのポリシーです。<br>組織ポリシー制約：組織全体、あるいは特定のプロジェクトやフォルダに対する設定の制限や制約です。<br>サービスアカウントキーのローテーション：セキュリティを高めるために、定期的に新しい鍵を発行し、古い鍵を無効にすることです。<br>正解についての説明：<br>（選択肢）<br>・サービスアカウントキーの有効期間を24時間とすることを許可する組織ポリシー制約を強制します。pj-saの例外を除いて、サービスアカウントキーの作成を拒否する組織ポリシー制約を強制します<br>この選択肢が正解の理由は以下の通りです。<br>まず、Google Cloudの組織ポリシーサービスを用いて、サービスアカウントキーの有効期間を24時間に設定するポリシーを強制することで、サービスアカウントキーが1日以上持続することは防げます。これはすべての開発者がキーの取り扱いを安全に管理するための一時的な応急処置として有効です。<br>次に、同じ組織ポリシーサービスを用いて、一元化されたプロジェクト"pj-sa"以外でのサービスアカウントキーの作成を拒否するポリシーも強制します。これにより、開発者がキーを必要とするすべてのサービスアカウントを"pj-sa"プロジェクトで一元的に管理することが強制されます。これらのポリシーは指定した組織全体に適用されるため、全てのプロジェクトで一貫した管理が可能になります。以上の取り組みにより、定められた要件を満たすことができます。<br>不正解の選択肢についての説明：<br>選択肢：pj-saですべてのサービスアカウントキーを定期的にローテーションするCloud Runジョブを実装します。pj-saを例外として、サービスアカウントキーの作成を拒否する組織ポリシーを実施します<br>この選択肢が正しくない理由は以下の通りです。<br>Cloud Runジョブによるサービスアカウントキーの定期ローテーションを実装すると追加のコストが発生し、問題文で求められている"コストを最小限に抑える"という要件を満たすことができません。<br>一方、正解の選択肢は組織ポリシーを用いてサービスアカウントキーの作成と有効期間を管理するため、追加費用なく要件を満たします。<br>選択肢：KubernetesのCronJobを実装して、すべてのサービスアカウントキーを定期的にローテーションします。pj-saを除くすべてのプロジェクトで、サービスアカウントをリソースにアタッチできないようにします<br>この選択肢が正しくない理由は以下の通りです。<br>まず、KubernetesのCronJobを使用してサービスアカウントキーを定期的にローテーションするための処理は、比較的高い運用負荷とコストがかかります。<br>また、それらの手段では認証情報が1日のみ有効であるという要件を厳密に強制することが難しいです。<br>したがって、この選択肢はコストを最小限に抑えるという要件に対して最適な解決策ではありません。<br>選択肢：サービスアカウントキーの有効期間を24時間とすることを拒否する組織ポリシーで制限します。pj-saを除くすべてのプロジェクトで、サービスアカウントのリソースへのアタッチメントを無効にします<br>この選択肢が正しくない理由は以下の通りです。<br>サービスアカウントキーの有効期間を24時間とすることを拒否する組織ポリシーは、キーの有効期間が1日のみであるという要件を満たしますが、このポリシーだけではサービスアカウントがキーを作成することを制限できません。<br>また、サービスアカウントのリソースへのアタッチメントを無効にすると、サービスアカウント自体が使用できなくなります。'>
<div class='choice'> KubernetesのCronJobを実装して、すべてのサービスアカウントキーを定期的にローテーションします。pj-saを除くすべてのプロジェクトで、サービスアカウントをリソースにアタッチできないようにします</div>
<div class='choice'> サービスアカウントキーの有効期間を24時間とすることを拒否する組織ポリシーで制限します。pj-saを除くすべてのプロジェクトで、サービスアカウントのリソースへのアタッチメントを無効にします</div>
<div class='choice'> サービスアカウントキーの有効期間を24時間とすることを許可する組織ポリシー制約を強制します。pj-saの例外を除いて、サービスアカウントキーの作成を拒否する組織ポリシー制約を強制します</div>
<div class='choice'> pj-saですべてのサービスアカウントキーを定期的にローテーションするCloud Runジョブを実装します。pj-saを例外として、サービスアカウントキーの作成を拒否する組織ポリシーを実施します</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題65<br>あなたは、Container Registryを使用して、会社のコンテナイメージを別のプロジェクトに一元的に保存しています。別のプロジェクトで、Google Kubernetes Engine（GKE）クラスターを作成したいと考えています。また、KubernetesがContainer Registryからイメージをダウンロードできることを確認したいと考えています。<br>この要件を満たすために、どうすればよいですか？' data-answer='2' data-explanation='解説<br>正解は「イメージが保存されているプロジェクトで、Kubernetesノードが使用するサービスアカウントにStorage Object Viewer IAMロールを付与します」です。<br>この問題では、あるプロジェクトに保存されたContainer Registryのコンテナイメージに、Google Kubernetes Engine（GKE）クラスターがアクセスできるよう設定する方法が問われています。ここで重要なポイントは、その際に"サービスアカウントの設定"や"IAMロールの付与"が必要だと捉えることです。また、選択肢には異なるアクセス制御方法が提示されているので、Container Registryへのアクセスに必要な最適なものを選ぶ視点が求められます。アクセス制御の範囲、権限、粒度管理などの要素を考慮しつつ解答に向かうべきでしょう。<br>基本的な概念や原則：<br>Container Registry：Dockerイメージを安全にホストし、管理するためのプライベートArtifact Registryです。Docker CLIやDockerイメージの作業フローとシームレスに統合することができます。<br>Google Kubernetes Engine（GKE）：Google Cloudが提供するフルマネージドなKubernetesサービスです。アプリケーションをリリースしたり、スケーリングしたりするのを助けてくれます。<br>IAMロール：Cloud IAM（Identity and Access Management）におけるパーミッションのセットです。ユーザーやサービスアカウントにロールを付与して、リソースに対する特定の操作を許可します。<br>Storage Object Viewer：Cloud Storageに格納されたオブジェクトの読み取りアクセスを許可するIAMロールです。<br>Access scopes：Google Cloudのサービスに対するAPIアクセスレベルを設定します。サービスアカウントにアクセス範囲を定義して、特定のAPIに対するリクエストを制限します。<br>Service Account：IAMで保護されたアプリケーション間の認証と認可に使用されます。特定の権限を持つサービスアカウントを作成すると、そのサービスアカウントがその権限を持つユーザーまたはサービスとして認証されます。<br>Access Control List（ACL）：特定のユーザーやサービスアカウントがデータに対してどのような操作を行えるかを制御するためのルールのリストです。ACLを使用して、リソースへの細かなアクセス制御を行うことができます。<br>正解についての説明：<br>（選択肢）<br>・イメージが保存されているプロジェクトで、Kubernetesノードが使用するサービスアカウントにStorage Object Viewer IAMロールを付与します<br>この選択肢が正解の理由は以下の通りです。<br>まず、Google CloudのIAMロールはリソースに対するアクセス権限を制御します。そのため、異なるプロジェクトのGKEクラスターがContainer Registryからイメージを取得するためには、読み取り権限を持つロールが必要です。そのロールが"Storage Object Viewer"です。これは、Google Cloud Storageオブジェクトの読み取り権限を提供します。このロールをGKEクラスターのノードで動作するサービスアカウントに割り当てることで、クラスターが別のプロジェクトのContainer Registryからイメージをダウンロードできるようになります。GKEクラスターのノードはサービスアカウントの権限で操作を行うため、この方法でアクセス許可を与えることができます。これにより、要件を満たすことができます。<br>不正解の選択肢についての説明：<br>選択肢：GKEクラスターを作成する際、&#39;Access scopes&#39;でAllow full access to all Cloud APIsオプションを選択します<br>この選択肢が正しくない理由は以下の通りです。<br>&#39;Access scopes&#39;の&#39;Allow full access to all Cloud APIs&#39;オプションは、全てのGoogle Cloud APIに対して全アクセス権を付与します。<br>しかし、最小権限の原則に反し、セキュリティリスクが高まります。なので、特定のサービスアカウントに必要なロールだけを付与するのが望ましいです。<br>選択肢：サービスアカウントを作成し、Cloud Storageへのアクセス権を与えます。このサービスアカウントのP12キーを作成し、KubernetesのimagePullSecretsとして使用します<br>この選択肢が正しくない理由は以下の通りです。<br>P12キーを生成しimagePullSecretsとして使用することが役立つ場合もありますが、Google Cloudではサービスアカウントに適切なIAMロールを付与するだけでアクセスの制御が可能です。サービスアカウントにStorage Object Viewer IAMロールを付与する、という純粋で洗練された解決策があるため、この選択肢は複雑で必要以上と言えます。<br>選択肢：デフォルトのCompute Engineサービスアカウントに読み取り専用アクセスを与えるように、Cloud Storageの各イメージのACLを設定します<br>この選択肢が正しくない理由は以下の通りです。<br>Google Cloudでは、Cloud Storageの個々のイメージの読み取り専用アクセスをデフォルトのCompute Engineサービスアカウントに与えるACL設定は推奨されていません。その理由は、不必要に広範囲のアクセス権を付与し、セキュリティのリスクを増やす可能性があります。逆に正解の選択肢では、必要なリソースのみに限定した権限を付与することでセキュリティを確保しています。'>
<div class='choice'> デフォルトのCompute Engineサービスアカウントに読み取り専用アクセスを与えるように、Cloud Storageの各イメージのACLを設定します</div>
<div class='choice'> サービスアカウントを作成し、Cloud Storageへのアクセス権を与えます。このサービスアカウントのP12キーを作成し、KubernetesのimagePullSecretsとして使用します</div>
<div class='choice'> イメージが保存されているプロジェクトで、Kubernetesノードが使用するサービスアカウントにStorage Object Viewer IAMロールを付与します</div>
<div class='choice'> GKEクラスターを作成する際、&#39;Access scopes&#39;でAllow full access to all Cloud APIsオプションを選択します</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題66<br>Compute Engineに本番アプリケーションをデプロイしています。間違ってボタンをクリックしてインスタンスを削除してしまうことを防ぎたいと考えています。<br>あなたはこの要件を満たすために、どうすればよいですか？' data-answer='1' data-explanation='解説<br>正解は「インスタンスの削除保護を有効にします」です。<br>この問題では、誤ってCompute Engineのインスタンスを削除することを防ぐ手段について問われています。要件に直接対応する適切な仕組みを選択肢から見つけ出すことが重要です。選択肢を見る際には、インスタンスの破壊を防ぐ手段として、それぞれの選択肢がどのように機能するかを評価する必要があります。本番環境でのアプリケーションデプロイメントの安全性を保証するための範囲で考えることが求められます。<br>基本的な概念や原則：<br>インスタンスの削除保護：Compute Engineのインスタンスを意図せず削除されることから保護する設定です。間違ってインスタンスを削除することを防ぐために使用します。<br>ブートディスク：Compute Engineのインスタンスの起動に用いられるディスクです。インスタンスが削除された場合でも、ブートディスクは別途管理・削除することができます。<br>自動再起動：Compute Engineのインスタンスが停止した場合に自動的に再起動される設定です。予期せぬ停止からインスタンスを保護しますが、間違って削除されることを防ぐ機能ではありません。<br>プリエンプティブルインスタンス：Compute Engineの低料金なスポットインスタンスです。最大24時間しか稼働しませんし、必要に応じて削除される可能性があります。この設定はインスタンスの保護とは逆で、間違って削除されるリスクを増やします。<br>正解についての説明：<br>（選択肢）<br>・インスタンスの削除保護を有効にします<br>この選択肢が正解の理由は以下の通りです。<br>まず、Compute Engineのインスタンス削除保護を使用することで、誤ってインスタンスを削除するリスクを大幅に減らすことができます。インスタンス削除保護を有効にすると、そのインスタンスは誤って削除されることなく、安全に保護されます。この機能は、誤ったクリックや操作ミスからインスタンスを保護します。削除保護が有効なインスタンスを削除しようとすると、削除がブロックされてエラーが返されます。その結果、誤って重要なインスタンスを削除してしまうことを防ぐことができます。<br>したがって、この機能は誤った操作による潜在的なリスクを軽減し、本番アプリケーションの安全を確保する適切な手段です。<br>不正解の選択肢についての説明：<br>選択肢：インスタンス削除時にブートディスクを削除するフラグを無効にします<br>この選択肢が正しくない理由は以下の通りです。<br>インスタンス削除時にブートディスクを削除するフラグを無効にしても、それはインスタンス自体の削除を防ぐものではありません。そのため、間違ってボタンをクリックしてインスタンスが削除される問題に対する解決策とはなりません。これに対して適切な方法は、インスタンスの削除保護を有効にすることで、インスタンスの誤削除を防ぐことができます。<br>選択肢：インスタンスの自動再起動を無効にします<br>この選択肢が正しくない理由は以下の通りです。<br>インスタンスの自動再起動を無効にすると、インスタンスの予期しないダウンタイムを防ぐことができますが、インスタンスの誤っての削除を防ぐことはできません。<br>それに対して、正解の選択肢であるインスタンスの削除保護を有効にすると、ユーザーが間違ってインスタンスを削除することを防ぐことができます。<br>選択肢：インスタンスのプリエンプティを有効にします<br>この選択肢が正しくない理由は以下の通りです。<br>プリエンプティブルインスタンスは、予告なしに削除される可能性があるインスタンスです。<br>逆に、削除保護を有効にすると、インスタンスが意図せず削除されるのを防ぐことができます。よって、間違ってインスタンスを削除したくない場合、プリエンプティブではなく削除保護を利用します。'>
<div class='choice'> インスタンスのプリエンプティを有効にします</div>
<div class='choice'> インスタンスの削除保護を有効にします</div>
<div class='choice'> インスタンスの自動再起動を無効にします</div>
<div class='choice'> インスタンス削除時にブートディスクを削除するフラグを無効にします</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題67<br>gcloudコマンドラインインターフェイス（CLI）をダウンロードしてインストールし、Googleアカウントで認証しました。プロジェクト内のほとんどのCompute Engineインスタンスは、europe-west1-dゾーンで実行されています。これらのインスタンスを管理する際に、CLIコマンドごとにこのゾーンを指定する手間を省きたいと考えています。<br>あなたはこの要件を満たすために、どうすればよいですか？' data-answer='0' data-explanation='解説<br>正解は「gcloud configサブコマンドを使用して、デフォルトゾーンとしてeurope-west1-dゾーンを設定します」です。<br>この問題では、Compute EngineのCLIコマンドを用いて操作する際に、デフォルトのゾーン設定をどのように行うべきかが問われています。指定するゾーンが一定である場合、その都度ゾーンを指定するのは効率が良くないので、デフォルト値として設定する方法を求めています。gcloud CLIの構成に関する知識を基に、特定のゾーンをデフォルト値として設定する最適な手段を選ぶ必要があります。選択肢を見る際には、それぞれの選択肢が実際にCLIの設定を正しく行えるか、効率を妨げることなく解決策になるかを評価する必要があります。<br>基本的な概念や原則：<br>gcloudコマンドラインインターフェイス（CLI）：Google Cloudのサービスを操作するためのツールキットです。ローカルマシンからも管理作業が可能になります。<br>デフォルトゾーン：gcloud CLIでの操作において、明示的にゾーンを指定しなかった場合に適用されるゾーンの設定です。一度設定すると、その後の操作で都度ゾーンを指定する手間を省くことができます。<br>gcloud configサブコマンド：gcloud CLIの設定を管理するためのサブコマンドです。デフォルトのプロジェクトやゾーンなど、CLIの動作をカスタマイズするための設定を行うことができます。<br>Compute Engine：Google Cloudの仮想マシンを提供するサービスです。各種設定やリソース管理は、Console, RESTful API, gcloud CLIなどから行うことができます。<br>Metadataエントリー：Compute Engineのインスタンスやプロジェクトレベルでの設定情報です。しかし、デフォルトゾーンの設定はMetadataエントリーではなく、gcloud configコマンドで設定します。<br>default.confというファイル：これはgcloud CLIの設定方法としては不適切です。正しくはgcloud configコマンドを使用します。<br>正解についての説明：<br>（選択肢）<br>・gcloud configサブコマンドを使用して、デフォルトゾーンとしてeurope-west1-dゾーンを設定します<br>この選択肢が正解の理由は以下の通りです。<br>まず、gcloud CLIは広範囲のGoogle Cloudサービスを操作するためのツールで、その操作をシンプルに、かつ、効率的に行うために多くの設定をカスタマイズできます。その中でも`gcloud config`サブコマンドを利用してデフォルトの設定を管理することができます。今回の問題ではCompute Engineインスタンスが主に`europe-west1-d`ゾーンで実行されているため、このゾーンをデフォルトゾーンに設定すれば各CLIコマンドで都度ゾーンを指定する手間を省くことができます。これにより、手動でコマンド行数の減少をもたらし、エラーの可能性を減らします。<br>したがって、`gcloud config`を使用してデフォルトゾーンを設定することは、CLI操作の効率性を向上させ、管理作業を単純化するための適切な方法です。<br>不正解の選択肢についての説明：<br>選択肢：Compute Engineの設定ページのデフォルトロケーションで、ゾーンをeurope-west1-dに設定します<br>この選択肢が正しくない理由は以下の通りです。<br>Compute Engineの設定ページではデフォルトロケーションの設定ができません。gcloud CLIを最適化するために、`gcloud config`サブコマンドを使用してデフォルトゾーンを設定する必要があります。<br>選択肢：CLIをインストールしたディレクトリに、zone=europe-west1-dを含むdefault.confというファイルを作成します<br>この選択肢が正しくない理由は以下の通りです。<br>gcloud CLIの設定はdefault.confファイルで行われるものではありません。設定の値はgcloud configコマンドを利用して行うのが適切です。つまり、CLIの使用ガイドラインに沿っていないため、期待通りの動作が保証されません。<br>選択肢：Compute Engineページに、key compute/zone、value europe-west1-dのMetadataエントリーを作成します<br>この選択肢が正しくない理由は以下の通りです。<br>Compute EngineページのMetadataエントリーは、インスタンスのメタデータや構成を管理するためのものであり、gcloud CLIのデフォルトの動作を変更するためのものではありません。要件はCLIの操作を変えたいため、この選択肢は適切ではありません。'>
<div class='choice'> gcloud configサブコマンドを使用して、デフォルトゾーンとしてeurope-west1-dゾーンを設定します</div>
<div class='choice'> Compute Engineページに、key compute/zone、value europe-west1-dのMetadataエントリーを作成します</div>
<div class='choice'> Compute Engineの設定ページのデフォルトロケーションで、ゾーンをeurope-west1-dに設定します</div>
<div class='choice'> CLIをインストールしたディレクトリに、zone=europe-west1-dを含むdefault.confというファイルを作成します</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題68<br>Compute Engineインスタンスが特定のCloud Storageバケットにデータを書き込めるように、そのインスタンスに権限を設定する必要があります。そのためにはGoogleが推奨するプラクティスに従う必要があります。<br>この要件を満たすために、どうすればよいですか？' data-answer='0' data-explanation='解説<br>正解は「サービスアカウントを作成し、そのバケットのIAMロール "storage.objectCreator" に追加します」です。<br>この問題では、Google Cloudの権限設定に関して問われています。特にCompute Engineインスタンスにどのように権限を設定してCloud Storageバケットにデータを書き込めるようにするか、そしてそれがGoogleの推奨するプラクティスに従っているかが問題の焦点です。各選択肢が提案するアクションやアクセススコープの詳細を評価する際には、アクセスの範囲や権限の最小化、セキュリティのベストプラクティスに注意を払う必要があります。<br>基本的な概念や原則：<br>サービスアカウント：Google Cloudのアプリケーションが他のGoogle Cloudサービスに認証された形でアクセスするために使用される特殊なアカウントです。特定の権限を持つことができます。<br>IAMロール：一連の権限を組み合わせたもので、リソースへのアクセスレベルを決定します。ロールはサービスアカウントに割り当てることができます。<br>storage.objectCreatorロール：オブジェクトの作成のみを許可するCloud StorageのIAMロールです。データの書き込み権限がありますが、既存のデータの読み取りや削除はできません。<br>最小権限の原則：最小限の権限で任務を達成できるように設計すべきセキュリティの原則です。例えば、書き込みだけが必要な場合は、読み取りや削除の権限は不要です。<br>正解についての説明：<br>（選択肢）<br>・サービスアカウントを作成し、そのバケットのIAMロール "storage.objectCreator" に追加します<br>この選択肢が正解の理由は以下の通りです。<br>まず、Google Cloudでは、リソースへのアクセス制御のためにIAM（Identity and Access Management）を使用します。IAMロールを使用することで、特定のリソースへのアクセス権を制御することができます。特に、"storage.objectCreator" ロールは、特定のバケットにオブジェクトを作成する権限を提供します。<br>また、Googleのベストプラクティスに従うと、Compute EngineインスタンスがCloud Storageへのアクセスを必要とする場合、そのインスタンスに直接権限を付与するのではなく、サービスアカウントを介してそれを実行することが推奨されています。これは最小権限の原則に基づいており、不必要なアクセス権限の付与を避けることができます。<br>従って、サービスアカウントを作成し、そのバケットのIAMロール "storage.objectCreator" に追加することで、Compute Engineインスタンスが特定のCloud Storageバケットにデータを書き込む権限を設定することが、Googleが推奨するプラクティスに従っています。<br>不正解の選択肢についての説明：<br>選択肢：アクセススコープを持つサービスアカウントを作成します。アクセススコープ"https://www.googleapis.com/auth/devstorage.write_only"を使用します<br>この選択肢が正しくない理由は以下の通りです。<br>アクセススコープ"https://www.googleapis.com/auth/devstorage.write_only"を使用する方法は古い方法であり、GoogleはIAMロールでの権限管理を推奨しています。<br>また、アクセススコープでは特定のバケットへのアクセス制限ができません。<br>それに対して、IAMロール "storage.objectCreator" を使用すれば特定のバケットへの書き込み権限を明示的に設定できます。<br>選択肢：アクセススコープを持つサービスアカウントを作成します。アクセススコープ"https://www.googleapis.com/auth/cloud-platform"を使用します<br>この選択肢が正しくない理由は以下の通りです。<br>アクセススコープ"https://www.googleapis.com/auth/cloud-platform"を使用するアプローチは、全Google Cloudへの広範な権限を付与してしまうため、不適切です。<br>対照的に、サービスアカウントを作成してIAMロール "storage.objectCreator" に追加すると、必要な特定のバケットへの書き込み権限のみを制御でき、セキュリティはより強固なものとなります。<br>選択肢：サービスアカウントを作成し、そのバケットのIAMロール "storage.objectAdmin" に追加します<br>この選択肢が正しくない理由は以下の通りです。<br>Googleの推奨するプラクティスとして、最小権限の原則に従い、必要な操作に対して最も制限の強いロールを設定すべきです。この場合、インスタンスはバケットにデータを書き込むだけなので、"storage.objectCreator" ロールが適当です。"storage.objectAdmin" ロールでは不必要な管理権限が付与されてしまいます。'>
<div class='choice'> サービスアカウントを作成し、そのバケットのIAMロール "storage.objectCreator" に追加します</div>
<div class='choice'> アクセススコープを持つサービスアカウントを作成します。アクセススコープ"https://www.googleapis.com/auth/cloud-platform"を使用します</div>
<div class='choice'> アクセススコープを持つサービスアカウントを作成します。アクセススコープ"https://www.googleapis.com/auth/devstorage.write_only"を使用します</div>
<div class='choice'> サービスアカウントを作成し、そのバケットのIAMロール "storage.objectAdmin" に追加します</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題69<br>デフォルトVPCに2つのサブネット（Subnet-aとSubnet-b）があります。データベースサーバーはSubnet-aで稼働しています。アプリケーションサーバーとウェブサーバーはSubnet-bで稼働しています。アプリケーションサーバーからデータベースサーバーへのデータベーストラフィックのみを許可するファイアウォールのルールを設定したいと考えています。<br>この要件を満たすために、どうすればよいですか？' data-answer='2' data-explanation='解説<br>正解は「- サービスアカウントsa-appとsa-dbを作成します<br>- サービスアカウントsa-appをアプリケーションサーバーと関連付け、サービスアカウントsa-dbをデータベースサーバーと関連付けます<br>- 送信元サービスアカウントsa-appから送信先サービスアカウントsa-dbへのネットワークトラフィックを許可するインバウンドファイアウォールのルールを作成します」です。<br>この問題では、Google CloudのVPCとファイアウォールのルールを使用して、特定のサーバー間の通信のみを許可する設定を行う方法を問われています。また、サーバーはそれぞれ異なるSubnetに存在しますが、同一のVPC内に存在するため、前提として通信が可能になっています。しかし、問題文要件からはアプリケーションサーバーからデータベースサーバーへのトラフィックのみを許可したいとあります。その理解に基づいて、正しいファイアウォールのルールやサービスアカウントの設定を選択することが求められます。<br>基本的な概念や原則：<br>VPC（Virtual Private Cloud）：Google Cloudで提供される仮想ネットワークです。自分だけのプライベートネットワーク環境を構築し、自由にネットワーク設定を管理することができます。<br>サブネット：VPC内の複数のネットワーク領域です。異なるサービスやロールのために分けて使用され、それぞれが固有のネットワークアドレス範囲を持ちます。<br>サービスアカウント：Google Cloudリソースに関連付けられた特殊なアカウントです。アプリケーションが認証や認可を行い、Google Cloud APIを呼び出すために使用します。<br>ファイアウォールのルール：ネットワークトラフィックのフィルタリングを管理するためのルールです。特定のIPアドレス範囲、プロトコル、ポートからのトラフィックを許可または拒否することができます。<br>ネットワークタグ：Google Cloudのリソースに関連付けられる識別子です。特定のリソース群をファイアウォールのルールなどで操作する際に使用します。<br>アウトバウンドファイアウォールのルール：ネットワークからのアウトバウンド（出力）トラフィックを制御するためのファイアウォールのルールです。特定の送信元からのトラフィックを許可または拒否することができます。<br>正解についての説明：<br>（選択肢）<br>・- サービスアカウントsa-appとsa-dbを作成します<br>- サービスアカウントsa-appをアプリケーションサーバーと関連付け、サービスアカウントsa-dbをデータベースサーバーと関連付けます<br>- 送信元サービスアカウントsa-appから送信先サービスアカウントsa-dbへのネットワークトラフィックを許可するインバウンドファイアウォールのルールを作成します<br>この選択肢が正解の理由は以下の通りです。<br>まず、このステップバイステップの方法は、Google Cloudのファイアウォールのルールにより、特定のトラフィックの制御を可能にします。サービスアカウントsa-appとsa-dbの作成は、アプリケーションサーバとデータベースサーバを個別に識別するためのものです。<br>次に、サービスアカウントを対応するサーバと関連付けることにより、特定のサーバのトラフィックを調整することが可能になります。これにより、アプリケーションサーバがデータベースサーバと通信するためのトラフィックのみが許可されます。<br>そして、最後のステップであるインバウンドファイアウォールのルールの作成では、このトラフィックを正確に制御することができます。これにより、送信元がsa-appであるトラフィックのみが、送信先がsa-dbであるサーバーに届くようになります。<br>これらのステップを踏むことにより、アプリケーションサーバからデータベースサーバへのデータベーストラフィックのみを許可するファイアウォールのルールを正確に設定することができます。<br>不正解の選択肢についての説明：<br>選択肢：- app-serverタグをアプリケーションサーバーに追加し、db-serverタグをデータベースサーバーに追加します<br>- 送信元ネットワークタグapp-serverから送信先ネットワークタグdb-serverへのネットワークトラフィックを許可する、アウトバウンドファイアウォールのルールを作成します<br>この選択肢が正しくない理由は以下の通りです。<br>ファイアウォールのルールでネットワークタグを使用すると、特定のインスタンスではなく、タグが付けられたすべてのインスタンスへのアクセスが許可されます。これは適切な制御ができないリスクをもたらします。<br>一方、サービスアカウントは特定のインスタンスに紐付けられるため、適切な制御が可能です。そのため、サービスアカウントを使用する選択肢が正解であり、ネットワークタグを使用する選択肢が不正解です。<br>選択肢：- サービスアカウントsa-appとネットワークタグdb-serverを作成します<br>- サービスアカウントsa-appをアプリケーションサーバーに、ネットワークタグdb-serverをデータベースサーバーに関連付けます<br>この選択肢が正しくない理由は以下の通りです。<br>ネットワークタグを利用すればファイアウォールのルールでトラフィックを制御することができますが、このシナリオではサービスアカウントとして制御するのが課題の要件に適しています。ネットワークタグで制御するよりもサービスアカウントで制御する方が、よりセキュアで柔軟な制御が可能です。<br>選択肢：- タグをアプリケーションサーバーに追加し、サービスアカウントをデータベースサーバーに関連付けます<br>この選択肢が正しくない理由は以下の通りです。<br>サービスアカウントはデータベースサーバーだけでなく、アプリケーションサーバーにも対応していなければならず、その上で適切にファイアウォールのルールを設定する必要があります。この選択肢ではアプリケーションサーバーに対してサービスアカウントが適用されていないため、必要な連携が構築できません。'>
<div class='choice'> <br>- タグをアプリケーションサーバーに追加し、サービスアカウントをデータベースサーバーに関連付けます</div>
<div class='choice'><br>- サービスアカウントsa-appとネットワークタグdb-serverを作成します<br>- サービスアカウントsa-appをアプリケーションサーバーに、ネットワークタグdb-serverをデータベースサーバーに関連付けます</div>
<div class='choice'><br>- サービスアカウントsa-appとsa-dbを作成します<br>- サービスアカウントsa-appをアプリケーションサーバーと関連付け、サービスアカウントsa-dbをデータベースサーバーと関連付けます<br>- 送信元サービスアカウントsa-appから送信先サービスアカウントsa-dbへのネットワークトラフィックを許可するインバウンドファイアウォールのルールを作成します</div>
<div class='choice'><br>- app-serverタグをアプリケーションサーバーに追加し、db-serverタグをデータベースサーバーに追加します<br>- 送信元ネットワークタグapp-serverから送信先ネットワークタグdb-serverへのネットワークトラフィックを許可する、アウトバウンドファイアウォールのルールを作成します</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題70<br>チームの外部メンバーが、あるプロジェクトのコンピュートイメージとディスクへのリストアクセスを必要としています。このユーザーに必要な権限を付与する際には、Googleが推奨するプラクティスに従う必要があります。<br>あなたはこの要件を満たすために、どうすればよいですか？' data-answer='0' data-explanation='解説<br>正解は「カスタムロールを作成し、必要なcompute.disk.listとcompute.images.list権限をincludedPermissionsとして追加します。プロジェクトレベルのユーザにカスタムロールを付与します」です。<br>この問題では、Googleが推奨するプラクティスに基づき、外部メンバーに特定のリソースへのアクセス権を付与するアプローチが求められています。課題は、特定のリソースであるコンピュートイメージとディスクへのリストアクセスの管理方法です。Googleのプラクティスは、最少権限の原則に基づいており、ユーザーが必要とする最小限の権限のみを付与することを推奨しています。そのため、ユーザーに適切な権限を付与するためには、特定の操作に対する権限を厳密に制御する方法を考える必要があります。また、ロールの作成や管理、権限の付与に関連するGoogle Cloudのサービスの理解が問われます。<br>基本的な概念や原則：<br>IAMポリシー：Google Cloudリソースへのアクセスを制御するためのルールを設定します。特定のユーザーが特定の操作を行うことができるかどうかを決定します。<br>カスタムロール：特定のニーズに合わせてカスタマイズされたIAMロールです。特定の権限を付与することで、ユーザーが操作できるリソースと操作を細かく制御できます。<br>Compute Image Userロール：Compute Engineのイメージを読み取ることができるロールです。ただし、他の操作は許可されていません。<br>Compute Storage Adminロール：Compute Engineのストレージに必要な全ての権限を持つロールです。<br>Least Privilege Principle：必要最小権限の原則です。ユーザー、アカウント、アプリケーションが必要とする最小限の権限のみを付与することで、誤操作や悪意のある行動からシステムを守ります。<br>includedPermissions：カスタムロールの特定の権限を指定するフィールドです。<br>プロジェクトレベルのユーザー：特定のプロジェクトにアクセスできるユーザーのことです。<br>正解についての説明：<br>（選択肢）<br>・カスタムロールを作成し、必要なcompute.disk.listとcompute.images.list権限をincludedPermissionsとして追加します。プロジェクトレベルのユーザにカスタムロールを付与します<br>この選択肢が正解の理由は以下の通りです。<br>まず、Google Cloudでは最小権限の原則、つまりユーザーには必要最小限の権限のみを付与するという方針が推奨されています。これはセキュリティの観点から、ユーザーが本来必要としない操作を行えてしまうリスクを軽減するためです。そのため、具体的にどの操作を行う必要があるのかが明確に定義されている場合にはカスタムロールを作成し、必要最小限の権限のみを付与することが推奨されます。<br>この問題では、外部メンバーに対してcompute.disk.listとcompute.images.listという特定の権限のみが必要となっています。<br>したがって、これらの権限を持ったカスタムロールを作成し、そのロールをユーザーに付与することで、セキュリティを維持するのと同時に必要な操作を可能とする正しいアクセス設定が可能です。これが正解の選択肢である理由です。<br>不正解の選択肢についての説明：<br>選択肢：Compute Image Userロールに基づいて、カスタムロールを作成します。includedPermissionsフィールドにcompute.disks.listを追加します。プロジェクトレベルでユーザにカスタムロールを付与します<br>この選択肢が正しくない理由は以下の通りです。<br>Compute Image Userロールは元から存在するロールであり、これに基づいてカスタムロールを作成することは意味がありません。<br>また、このロールは特にcompute.images.listの権限も含まれていませんので、ユーザーがイメージにリストアクセスを持つためには、この権限を明示的に追加する必要があります。<br>それに対し、正答の選択肢は適切なcompute.disk.listとcompute.images.list権限を含むカスタムロールを新規作成しています。<br>選択肢：Compute Storage Adminロールに基づいてカスタムロールを作成します。カスタムロールから不要な権限を除外します。プロジェクトレベルのユーザーにカスタムロールを付与します<br>この選択肢が正しくない理由は以下の通りです。<br>Compute Storage Adminロールはオーバーパーミッションとなり、ユーザーが必要な機能以上の権限を得てしまいます。特に、Googleが推奨するのは最小権限の原則ですから、必要なcompute.disk.listとcompute.images.listのみを含むカスタムロールを作るのが適切です。<br>選択肢：プロジェクトレベルでCompute Storage Adminロールを付与します<br>この選択肢が正しくない理由は以下の通りです。<br>Compute Storage Adminロールを付与すると、ユーザーはリストアクセス以上の権限を得るため、Googleの推奨する最小限の権限の原則に適合しません。そのため、カスタムロールを作成し、必要な権限だけを付与する選択肢が適切です。'>
<div class='choice'> カスタムロールを作成し、必要なcompute.disk.listとcompute.images.list権限をincludedPermissionsとして追加します。プロジェクトレベルのユーザにカスタムロールを付与します</div>
<div class='choice'> プロジェクトレベルでCompute Storage Adminロールを付与します</div>
<div class='choice'> Compute Storage Adminロールに基づいてカスタムロールを作成します。カスタムロールから不要な権限を除外します。プロジェクトレベルのユーザーにカスタムロールを付与します</div>
<div class='choice'> Compute Image Userロールに基づいて、カスタムロールを作成します。includedPermissionsフィールドにcompute.disks.listを追加します。プロジェクトレベルでユーザにカスタムロールを付与します</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題71<br>外部監査人にCloud IAM（Identity and Access Management）ロールを割り当てる必要があります。監査人はあなたの内容をレビューする権限を持っている必要があります。<br>Google Cloudの監査ログとデータアクセスログを確認する権限が必要です。<br>あなたはこの要件を満たすために、どうすればよいですか？' data-answer='3' data-explanation='解説<br>正解は「監査人にIAMロールroles/logging.privateLogViewerを割り当てます。監査人に、Cloud IAMポリシーの変更についてもログを確認するように指示します」です。<br>この問題では、外部監査人がGoogle Cloudの監査ログとデータアクセスログを確認できるように設定することが求められています。求められている事項は、Cloud IAMの設定と、ログの確認方法です。この問題に取り組む際は、IAMロールや権限の範囲、ロールや権限がどのように動作するかに関する知識が重要です。また、不適切な設定によりセキュリティリスクが生じないことと、ログが外部監査人に適切に閲覧可能であることを確認することが求められています。<br>基本的な概念や原則：<br>Cloud IAM（Identity and Access Management）：Google Cloudの認証・認可の管理サービスです。ユーザーやサービスアカウントに対して、特定のリソースへのアクセス権を付与・削除することができます。<br>IAMロール：Google Cloudの特定のリソースに対する許可セットです。これによりユーザーやサービスアカウントがリソースに対してどのような操作を行うことができるかが定義されます。<br>roles/logging.privateLogViewer：プライベートログエントリを調査するためのIAMロールです。ログデータに対する読み取りアクセス権を付与します。<br>監査ログとデータアクセスログ：Google Cloudの各サービスや操作についてのログ情報です。監査ログはAPI呼び出しや管理活動などについて記録されます。データアクセスログではリソースへの読み書き操作が記録されます。<br>Cloud IAMポリシー：IAMで管理されるリソースへのアクセス制御を管理するためのポリシーです。ロールとメンバーを関連付け、どのメンバーがどのリソースに対してどの操作を許可されるかを定義します。<br>Cloud Storage：Google Cloudのオブジェクトストレージサービスです。大規模なデータを保存したり、ログのエクスポートなどに利用可能です。<br>カスタムロール：特定のプロジェクトや組織に対してカスタマイズされたIAMロールです。特定の権限のみを持つロールを作成できるため、原則として最小限の権限の原則に基づくアクセス制御が可能です。<br>正解についての説明：<br>（選択肢）<br>・監査人にIAMロールroles/logging.privateLogViewerを割り当てます。監査人に、Cloud IAMポリシーの変更についてもログを確認するように指示します<br>この選択肢が正解の理由は以下の通りです。<br>監査の目的は、適切な操作が行われているかを確認し、不適切な操作がないかを特定することです。そのため、監査人はシステムのログを確認する能力が必要で、データアクセスやIAMポリシーの変更などの重要な操作に関するログも確認できる必要があります。<br>IAMロールroles/logging.privateLogViewerは、監査ログとデータアクセスログを調査する権限を与えます。これにより、監査人は他のユーザーやサービスによる行動を追跡し、レビューすることが可能になります。<br>また、Cloud IAMポリシーの変更ログも監査ログに含まれているため、このロールが付与されれば監査人はIAMポリシーの変更を確認することができます。これにより、監査人は予期しないあるいは不適切なIAMポリシー変更が無いか確認することができ、より厳密な監査を行うことができます。<br>不正解の選択肢についての説明：<br>選択肢：監査人にIAMロールroles/logging.privateLogViewerを割り当てます。Cloud Storageへのログのエクスポートを実行します<br>この選択肢が正しくない理由は以下の通りです。<br>Cloud Storageへのログのエクスポートは、監査人がCloud IAMポリシーの変更についてログを確認する要件を満たさない可能性があります。<br>一方で、Cloud IAMポリシーの変更についてログを確認するように指示することは、監査人が必要とする全ての権限とデータに対するアクセスを与えます。<br>選択肢：監査人のIAMユーザーを、logging.privateLogEntries.list権限を持つカスタムロールに割り当てます。ログのCloud Storageへのエクスポートを実行します<br>この選択肢が正しくない理由は以下の通りです。<br>カスタムロールを使用した場合、そのロールが持つ機能はカスタムに設定された範囲に限定されます。一方でroles/logging.privateLogViewerロールは、監査ログとデータアクセスログの両方の閲覧が可能なため、よりすべての要件を対応できます。<br>また、ログのCloud Storageへのエクスポートも必要ないため、この選択肢は適切ではありません。<br>選択肢：監査人のIAMユーザーを、logging.privateLogEntries.list権限を持つカスタムロールに割り当てます。監査人に、Cloud IAMポリシーの変更についてもログを確認するように指示します<br>この選択肢が正しくない理由は以下の通りです。<br>カスタムロールでは、ある個々の権限ではなく、必要なすべての権限を割り当てる必要があります。この場合、logging.privateLogEntries.listの権限だけではGoogle Cloudの監査ログとデータアクセスログを確認するための十分な権限を持っていません。そのため、roles/logging.privateLogViewerのようなプリセットロールを使用する方がよいです。'>
<div class='choice'> 監査人のIAMユーザーを、logging.privateLogEntries.list権限を持つカスタムロールに割り当てます。ログのCloud Storageへのエクスポートを実行します</div>
<div class='choice'> 監査人にIAMロールroles/logging.privateLogViewerを割り当てます。Cloud Storageへのログのエクスポートを実行します</div>
<div class='choice'> 監査人のIAMユーザーを、logging.privateLogEntries.list権限を持つカスタムロールに割り当てます。監査人に、Cloud IAMポリシーの変更についてもログを確認するように指示します</div>
<div class='choice'> 監査人にIAMロールroles/logging.privateLogViewerを割り当てます。監査人に、Cloud IAMポリシーの変更についてもログを確認するように指示します</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題72<br>あなたの会社はGoogle Workspaceを使って従業員のアカウントを管理しています。2年以内に従業員数が100人から1,000人に増加する見込みです。ほとんどの従業員がGoogle Cloudアカウントにアクセスする必要があります。システムとプロセスは、パフォーマンスの低下、不必要な手作業の増加、セキュリティの問題なしに、10倍の成長をサポートする必要があります。<br>あなたはこの要件を満たすために、どうすればよいですか？' data-answer='2' data-explanation='解説<br>正解は「Cloud Identityのユーザーをグループに編成します。Cloud Identityで多要素認証を実施します」です。<br>この問題では、会社の急成長に対応しつつ、効率的で安全なGoogle Cloudアカウントのアクセス管理手法について問いています。これから大幅に増員する従業員全員にGoogle Cloudアカウントへのアクセス権を滞りなく、かつ安全に管理するためにはどのような手段を取るべきか考える必要があります。その際、パフォーマンスの低下、不必要な手作業の増加、セキュリティの問題が発生しない方法を選ばなければなりません。また、使用するツールやサービスについても理解しておく必要があります。具体的には、Cloud IdentityやGoogle Workspace、Active DirectoryやIDフェデレーションなどの概念や機能を理解した上で、それらを適切に応用することが求められます。<br>基本的な概念や原則：<br>Google Workspace：Googleが提供するクラウドベースの生産性向上ツールのスイートです。メール、カレンダー、ドキュメントの共有、ビデオ会議など、ビジネスに必要な機能を提供します。<br>Cloud Identity：Google CloudのIAM（Identity and Access Management）プロダクトです。ユーザーのアカウントを管理し、Google Cloudにアクセスするための認証を提供します。<br>ユーザーグループ：Cloud Identityで提供される機能で、特定の属性を持つユーザーをまとめることができます。グループを用いることで、ロールとポリシーの割り当てを一元管理し、管理作業を効率化することができます。<br>多要素認証：システムへの不正アクセスを防ぐためのセキュリティ手段です。ユーザー名とパスワードだけでなく、ハードウェアトークンやモバイルアプリからの認証コードなど、2つ以上の異なる形式の認証が必要です。<br>Active Directory：マイクロソフトが提供する、ユーザーアカウントやコンピュータの情報を一元管理するディレクトリサービスです。一部の企業では、社内のユーザーアカウント管理に使用されます。<br>IDフェデレーション：異なるセキュリティドメイン間でユーザーのIDや属性情報を共有するための技術です。これにより、一つの認証情報で複数のシステムにアクセスすることが可能になります。<br>サードパーティーのIDプロバイダサービス：Google Cloud以外のサービスで、ユーザー管理と認証を提供するものです。これにより、複数のクラウドサービスに対して一元的なユーザー管理が可能です。<br>正解についての説明：<br>（選択肢）<br>・Cloud Identityのユーザーをグループに編成します。Cloud Identityで多要素認証を実施します<br>この選択肢が正解の理由は以下の通りです。<br>まず、Cloud Identityを通じてユーザーをグループに編成することで、管理の効率化と組織のスケーラビリティが確保されます。ユーザーをグループにまとめることで、簡単にデータアクセスを制御したり、特定のリソースへのアクセスを許可したりできます。この概念は、数百人以上の従業員の管理を必要とする大規模な企業にとって特に重要です。<br>また、Cloud Identityに多要素認証を実施することで、セキュリティが向上します。複数の認証メソッドを使うことで、特定のセキュリティ要件を満たしたり、不正なアクセスを防いだりすることが可能になります。要員の大幅な増加が予想される場合、セキュリティを確保しながら成長を管理するために、これらの機能を活用することが非常に重要です。<br>不正解の選択肢についての説明：<br>選択肢：ユーザーをActive Directoryに移行します。人事システムをActive Directoryに接続します。Cloud IdentityのGoogle Cloud Directory Sync（GCDS）をオンにします。Cloud IdentityからActive Directoryへのアイデンティティフェデレーションをオンにします<br>この選択肢が正しくない理由は以下の通りです。<br>まず、Active Directoryを導入するのは過度で、それによりシステムの複雑性が増し、管理が難しくなります。<br>また、すでにGoogle Workspaceが使用されているため、Cloud Identityを活用してユーザーをグループに編成し、多要素認証を行う方が手間がかからず効率的です。<br>選択肢：Cloud IdentityとGoogle Workspace間のIDフェデレーションを有効にします。ドメインワイドの委任に対して多要素認証を強制します<br>この選択肢が正しくない理由は以下の通りです。<br>Google WorkspaceとCloud Identityは既に統合されているため、間のIDフェデレーションを有効にする必要はありません。<br>また、ドメイン全体の委任に対して多要素認証を強制すると、不要な手作業が増え、効率性が低下します。これは、効率的な管理とセキュリティー強化を目指す問題の要件とは矛盾します。<br>選択肢：フェデレーションを通じてサードパーティーのIDプロバイダサービスを使用します。Google Workplaceからサードパーティープロバイダーにユーザーをリアルタイムで同期させます<br>この選択肢が正しくない理由は以下の通りです。<br>サードパーティーのIDプロバイダサービスを使用すると、管理が複雑になり不必要な手作業が増える可能性があります。<br>また、リアルタイムで同期させるという手法は、パフォーマンス低下の原因となる可能性があります。原則として、すでにGoogle Workspaceを使用している場合は、Cloud Identityの使用が推奨されます。これは、シームレスな統合と簡単な管理を提供し、効率とセキュリティを向上させます。'>
<div class='choice'> フェデレーションを通じてサードパーティーのIDプロバイダサービスを使用します。Google Workplaceからサードパーティープロバイダーにユーザーをリアルタイムで同期させます</div>
<div class='choice'> Cloud IdentityとGoogle Workspace間のIDフェデレーションを有効にします。ドメインワイドの委任に対して多要素認証を強制します</div>
<div class='choice'> Cloud Identityのユーザーをグループに編成します。Cloud Identityで多要素認証を実施します</div>
<div class='choice'> ユーザーをActive Directoryに移行します。人事システムをActive Directoryに接続します。Cloud IdentityのGoogle Cloud Directory Sync（GCDS）をオンにします。Cloud IdentityからActive Directoryへのアイデンティティフェデレーションをオンにします</div>
</div>
            <!-- 他の問題も同様に追加 -->
        </div>

        <h2 id="question"></h2>
        <ul class="choices" id="choices"></ul>
        <button onclick="checkAnswer()">採点</button>
        <button onclick="nextQuestion()" id="nextButton" style="display: none;">次の問題へ</button>
        <div class="result" id="result"></div>
    </div>

    <script>
        let currentQuestionIndex = 0;
        let correctCount = 0;
        const questions = [];

        document.addEventListener('DOMContentLoaded', () => {
            const questionElements = document.querySelectorAll('#quiz-data .question');
            questions.push(...Array.from(questionElements).map(questionElement => ({
                question: questionElement.getAttribute('data-question').replace(/\\n/g, '<br>'),
                choices: Array.from(questionElement.querySelectorAll('.choice')).map((choice, index) => ({
                    text: choice.innerHTML.replace(/\\n/g, '<br>'),  // innerHTMLに変更
                    index: index
                })),
                correctAnswer: questionElement.getAttribute('data-answer').split(',').map(Number),
                explanation: questionElement.getAttribute('data-explanation').replace(/\\n/g, '<br>'),
                multiple: questionElement.getAttribute('data-multiple') === 'true'
            })));
            showQuestion();
        });

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function showQuestion() {
            const questionElement = document.getElementById('question');
            const choicesContainer = document.getElementById('choices');
            const currentQuestion = questions[currentQuestionIndex];

            shuffleArray(currentQuestion.choices);

            questionElement.innerHTML = currentQuestion.question;
            choicesContainer.innerHTML = '';

            currentQuestion.choices.forEach((choice, i) => {
                const li = document.createElement('li');
                const input = document.createElement('input');
                const label = document.createElement('label');

                input.type = currentQuestion.multiple ? 'checkbox' : 'radio';
                input.name = 'choice';
                input.value = choice.index;
                input.id = 'choice' + i;

                label.htmlFor = 'choice' + i;
                label.innerHTML = choice.text;  // textContentをinnerHTMLに変更

                li.appendChild(input);
                li.appendChild(label);
                choicesContainer.appendChild(li);
            });

            document.getElementById('result').textContent = "";
            document.getElementById('nextButton').style.display = 'none';
        }

        function checkAnswer() {
            const currentQuestion = questions[currentQuestionIndex];
            const selectedChoices = Array.from(document.querySelectorAll('input[name="choice"]:checked'))
                                        .map(checkbox => parseInt(checkbox.value))
                                        .sort();
            const resultElement = document.getElementById('result');
            
            if (selectedChoices.length > 0) {
                const isCorrect = currentQuestion.multiple
                    ? selectedChoices.toString() === currentQuestion.correctAnswer.sort().toString()
                    : selectedChoices.length === 1 && selectedChoices[0] === currentQuestion.correctAnswer[0];
                
                if (isCorrect) {
                    resultElement.innerHTML = "正解です！<br>" + currentQuestion.explanation;
                    resultElement.style.color = "green";
                    correctCount++; // 正解数をカウント
                } else {
                    resultElement.innerHTML = "残念、不正解です。<br>" + currentQuestion.explanation;
                    resultElement.style.color = "red";
                }
                document.getElementById('nextButton').style.display = 'inline';
            } else {
                resultElement.textContent = "回答を選択してください。";
                resultElement.style.color = "orange";
            }
        }

        function nextQuestion() {
            currentQuestionIndex++;
            
            if (currentQuestionIndex < questions.length) {
                showQuestion();
            } else {
                showFinalResult();
            }
        }

        function showFinalResult() {
            const quizContainer = document.querySelector('.quiz-container');
            quizContainer.innerHTML = `
                <h2>問題終了！</h2>
                <p>あなたの正解数は ${correctCount} / ${questions.length} です。</p>
                <button onclick="restartQuiz()">再挑戦する</button>
            `;
        }

        function restartQuiz() {
            correctCount = 0;
            currentQuestionIndex = 0;

            // クイズのUI全体を初期化
            const quizContainer = document.querySelector('.quiz-container');
            quizContainer.innerHTML = `
                <h2 id="question"></h2>
                <ul class="choices" id="choices"></ul>
                <button onclick="checkAnswer()">採点</button>
                <button onclick="nextQuestion()" id="nextButton" style="display: none;">次の問題へ</button>
                <div class="result" id="result"></div>
            `;

            // 初期化後に最初の問題を表示
            showQuestion();
        }        
    </script>
</body>
</html>