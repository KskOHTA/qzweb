<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Google Cloud Leader問題集 06</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="quiz-container">
        <div id="quiz-data" style="display: none;">
<div class='question' data-multiple='FALSE' data-question='問題1<br>あなたのチームは組織のインフラを保守しています。現在のインフラには変更が必要です。あなたは提案した変更をチームの他のメンバーと共有する必要があります。また、Googleが推奨するベストプラクティスに従う必要があります。<br>この要件を満たすために、どうすればよいですか？' data-answer='2' data-explanation='解説<br>正解は「Deployment Managerのテンプレートを使用して、提案された変更を記述し、Cloud Source Repositoriesに保存します」です。<br>この問題では、推奨されるインフラの変更の管理と共有の手法について理解することが必要です。あなたが提案する変更をチームの他のメンバーと共有する必要があるため、変更を記述し、それを保存できる方法を見つける必要があります。その上で、Googleの推奨するベストプラクティスに焦点を当て、それに従った解決策を選択すべきです。<br>基本的な概念や原則：<br>Deployment Manager：Google Cloudのインフラストラクチャ展開のオートメーションツールです。YAMLテンプレートを使ってリソースの配置や構成を定義し、反復可能で一貫性のあるデプロイを実現します。<br>Cloud Source Repositories：プライベートGitリポジトリをホストするGoogle Cloudのサービスです。コードのバージョン管理と共有を支援します。<br>Infrastructure as Code（IaC）：インフラストラクチャ設定をコードとして表現、管理する手法です。反復性、一貫性、再利用性を向上させ、システムの構築と変更を自動化します。<br>Cloud Storage：オブジェクトデータの保存に適したGoogle Cloudのストレージサービスです。コードバージョン管理や共有には適していません。<br>gcloud：Google CloudのSDKの一部で、CLIからサービスを操作するためのツールです。しかし、これだけでの作業内容の共有やベストプラクティスへの準拠は難しいです。<br>正解についての説明：<br>（選択肢）<br>・Deployment Managerのテンプレートを使用して、提案された変更を記述し、Cloud Source Repositoriesに保存します<br>この選択肢が正解の理由は以下の通りです。<br>最初に、Deployment Managerはインフラストラクチャのバージョン管理と再利用性を提供します。テンプレートの使用は、構成の再利用性を向上させ、重複する設定を一元化するためのベストプラクティスです。Deployment Managerのテンプレートを使うことで、提案された変更を明確に記述し、チームの他のメンバーが理解しやすくなります。<br>また、Cloud Source Repositoriesは、プライベートで安全なGitリポジトリを提供します。Cloud Source Repositoriesは、変更履歴の追跡やチームでのコード共有が容易になり、視覚的なツールを使ってコードをより分かりやすくレビューできます。<br>この組み合わせにより、インフラストラクチャの変更を記述しそれを共有するための、冗長性のない明瞭さと再利用可能な方法が提供されます。これはGoogleが推奨するベストプラクティスであり、効率的なインフラストラクチャの変更管理をサポートします。<br>不正解の選択肢についての説明：<br>選択肢：Deployment Managerテンプレートを使って提案された変更を記述し、Cloud Storageバケットに保存します<br>この選択肢が正しくない理由は以下の通りです。<br>Deployment ManagerテンプレートをCloud Storageバケットに保存する方法は、提案した変更を共有する目的には使えますが、バージョン管理の観点から推奨される方法ではありません。<br>一方、Cloud Source Repositoriesを使用すれば、変更の履歴と差分を確認したり、必要に応じて特定のバージョンに戻すことも可能なため、Googleが推奨するベストプラクティスに従っています。<br>選択肢：開発環境で変更を適用し、gcloud compute instances listを実行し、出力を共有Storageバケットに保存します<br>この選択肢が正しくない理由は以下の通りです。<br>開発環境で変更を適用し、gcloud compute instances listを実行する方法では、提案された変更を再現性や再利用性のある形式で共有することが難しく、またGoogleのベストプラクティスにも従っていません。<br>一方、Deployment Managerのテンプレートを使用すれば、構成がコードで管理され、再現性と再利用性を保証しつつ、変更を共有することができます。<br>選択肢：開発環境で変更を適用し、gcloud compute instances listを実行し、その出力をCloud Source Repositoriesに保存します<br>この選択肢が正しくない理由は以下の通りです。<br>開発環境で変更を適用し、gcloud compute instances listの出力を保存する方法はインフラの変更内容を共有する効果的な手法ではありません。<br>また、この方法はGoogleが推奨するベストプラクティスにも従っていません。<br>一方、Deployment Managerのテンプレートを使用すれば、明確かつ再現性のある形で提案されたインフラの設計変更を表現し、その情報をCloud Source Repositoriesに保存することができます。これにより、チーム全体での共有とインフラの変更内容を管理することが可能になります。'>
<div class='choice'> 開発環境で変更を適用し、gcloud compute instances listを実行し、その出力をCloud Source Repositoriesに保存します</div>
<div class='choice'> 開発環境で変更を適用し、gcloud compute instances listを実行し、出力を共有Storageバケットに保存します</div>
<div class='choice'> Deployment Managerのテンプレートを使用して、提案された変更を記述し、Cloud Source Repositoriesに保存します</div>
<div class='choice'> Deployment Managerテンプレートを使って提案された変更を記述し、Cloud Storageバケットに保存します</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題2<br>あなたの会社は、ワークロード全体をCompute Engineに移行しようとしています。インターネットからアクセスできるサーバーもあれば、内部ネットワークからのみアクセスできるサーバーもあります。すべてのサーバーは、特定のポートとプロトコルで相互に通信できる必要があります。現在のオンプレミスネットワークは、パブリックサーバー用に非武装地帯（DMZ）、プライベートサーバー用にローカルエリアネットワーク（LAN）に依存しています。あなたはこのネットワーク構成を踏まえて、Google Cloud上のネットワーキングインフラを設計する必要があります。<br>あなたはこの要件を満たすために、どうすればよいですか？' data-answer='2' data-explanation='解説<br>正解は「1.DMZ用のサブネットとLAN用のサブネットを持つ単一のVPCを作成します<br>2.DMZとLANサブネット間の関連トラフィックを開放するファイアウォールのルールと、DMZのパブリックな内向きトラフィックを許可する別のファイアウォールのルールを設定します」です。<br>この問題では、オンプレミスネットワークからGoogle Cloudへのネットワーク移行が求められています。要件としてパブリックサーバーのためのDMZとプライベートサーバーのためのLANの2種類のネットワークの存在と、それらが特定のポートとプロトコルで通信する必要があることから、VPCとサブネットの設定、および各種のトラフィックを制御するためのファイアウォールのルールの設定が各選択肢に織り込まれています。これはオンプレミスの設定をCloudに移行させるための具体的なステップを考慮して問題を解くことが求められています。<br>基本的な概念や原則：<br>VPC（Virtual Private Cloud）：仮想的なプライベートネットワークをGoogle Cloud内に構築するサービスです。ユーザーは自由にサブネットを定義し、その通信ルールを制御できます。<br>サブネット：ネットワークを複数の区分に分ける方法の一つです。特定のサービスや用途に対してネットワークを分割し、管理がしやすくすることができます。<br>非武装地帯（DMZ）：インターネットと内部ネットワークの間に設けられた隔離されたネットワーク領域のことです。公開するサービスを配置することにより、内部ネットワークの安全性を確保します。<br>ローカルエリアネットワーク（LAN）：特定の範囲内でコンピューターや機器が相互に通信するためのネットワークです。<br>ファイアウォールのルール：ネットワークのセキュリティを保つため、特定の通信を許可したり、拒否したりするルールです。Google Cloudでは、これらのルールを自由に設定して、ネットワーク通信を制御できます。<br>内向きトラフィック：ネットワークの外部から内部へ向かう通信のことです。この通信はしばしば悪意のある攻撃の対象になるため、適切な制御が必要です。<br>外向きトラフィック：ネットワークの内部から外部へ向かう通信のことです。この通信もまた、不適切な利用やデータ漏洩のリスクがあるため、セキュリティ対策が必要です。<br>正解についての説明：<br>（選択肢）<br>・1.DMZ用のサブネットとLAN用のサブネットを持つ単一のVPCを作成します<br>2.DMZとLANサブネット間の関連トラフィックを開放するファイアウォールのルールと、DMZのパブリックな内向きトラフィックを許可する別のファイアウォールのルールを設定します<br>この選択肢が正解の理由は以下の通りです。<br>まず、Google CloudのVPC（Virtual Private Cloud）はプライベートネットワークを作成し、その上でCompute Engineの仮想マシンをホストするのに役立ちます。それぞれのサブネットは特定のIPアドレス範囲を持ち、そのサブネット内のインスタンスは互いに通信できます。非武装地帯（DMZ）とローカルエリアネットワーク（LAN）の適用を一つのVPC上に作成することで、オンプレミスでの区分けをネットワーク設計に落とし込むことができます。<br>さらに、Google Cloudではファイアウォールのルールを設定することで、指定されたネットワークトラフィックを制御できます。そのため、DMZとLANサブネット間の通信を許可するルールと、DMZのパブリックな内部向きのトラフィックを許可するルールを設定することで、それぞれのサーバが必要とする通信を実現します。これにより、オンプレミスネットワークのセキュリティモデルを再現することができます。<br>つまり、サブネットとファイアウォールのルールを活用することで、オンプレミスのネットワーク構成をGoogle Cloudに移行することができます。<br>不正解の選択肢についての説明：<br>選択肢：1.DMZ用のサブネットとLAN用のサブネットを持つ単一のVPCを作成します<br>2.DMZとLANサブネット間の関連トラフィックを開放するファイアウォールのルールと、DMZのパブリックな外向きトラフィックを許可する別のファイアウォールのルールを設定します<br>この選択肢が正しくない理由は以下の通りです。<br>DMZのロールは、インターネットからのアクセスを受け入れることで、その設定においてパブリックな外向きトラフィックを許可する必要はありません。<br>逆に、内向きのトラフィックはDMZが受け入れる必要があり、正解の選択肢で述べられています。<br>選択肢：1.DMZ用のサブネットを持つVPCとLAN用のサブネットを持つVPCを作成します<br>2.DMZとLANサブネット間の関連トラフィックを開放するファイアウォールのルールを設定し、DMZのパブリックな内向きトラフィックを許可する別のファイアウォールのルールを設定します<br>この選択肢が正しくない理由は以下の通りです。<br>Google Cloudでは、異なるVPC間でのファイアウォールのルールの設定による通信制御は直接行えません。サーバー間の通信を実現するためには単一のVPC内にサブネットを作成し、その中でファイアウォールのルールを設定するのが適切です。<br>選択肢：1.DMZ用のサブネットを持つVPCとLAN用のサブネットを持つVPCを作成します<br>2.DMZとLANサブネット間の関連トラフィックを開放するファイアウォールのルールと、DMZのパブリックな外向きトラフィックを許可するファイアウォールのルールを設定します<br>この選択肢が正しくない理由は以下の通りです。<br>DMZとLANのサブネットを別々のVPCに作成すると、ネットワーク管理が複雑になります。<br>また、DMZの"パブリックな外向きトラフィックを許可する"は間違いで、正しくは"パブリックな内向きトラフィックを許可する"です。これはDMZが公開サーバーの保護と適切な規制が必要です。'>
<div class='choice'><br>1.DMZ用のサブネットとLAN用のサブネットを持つ単一のVPCを作成します<br>2.DMZとLANサブネット間の関連トラフィックを開放するファイアウォールのルールと、DMZのパブリックな外向きトラフィックを許可する別のファイアウォールのルールを設定します</div>
<div class='choice'><br>1.DMZ用のサブネットを持つVPCとLAN用のサブネットを持つVPCを作成します<br>2.DMZとLANサブネット間の関連トラフィックを開放するファイアウォールのルールを設定し、DMZのパブリックな内向きトラフィックを許可する別のファイアウォールのルールを設定します</div>
<div class='choice'><br>1.DMZ用のサブネットとLAN用のサブネットを持つ単一のVPCを作成します<br>2.DMZとLANサブネット間の関連トラフィックを開放するファイアウォールのルールと、DMZのパブリックな内向きトラフィックを許可する別のファイアウォールのルールを設定します</div>
<div class='choice'><br>1.DMZ用のサブネットを持つVPCとLAN用のサブネットを持つVPCを作成します<br>2.DMZとLANサブネット間の関連トラフィックを開放するファイアウォールのルールと、DMZのパブリックな外向きトラフィックを許可するファイアウォールのルールを設定します</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題3<br>あなたは、一連のバッチ処理ジョブ用に計算リソースを選択し、設定する必要があります。これらのジョブの完了には約2時間かかり、毎晩実行されます。あなたは、サービスコストを最小限に抑えたいと考えています。<br>この要件を満たすためには、どうすればよいですか？' data-answer='1' data-explanation='解説<br>正解は「Compute Engineを選択します。適切な標準マシンタイプのプリエンプティブVMインスタンスを使用します」です。<br>この問題では、バッチ処理ジョブの実行方法とそれに最適なコンピューティングリソースの選択について理解することが求められています。重要な点は、これらのジョブが計算集中型で夜間に回され、この問題の主要な目的がコスト削減であることです。したがって、選択肢を見るときには、必要な全コンピューティングリソースを提供しつつ、コストを最小限に抑えることができるオプションを見つけることが求められます。<br>基本的な概念や原則：<br>Compute Engine：Google Cloudの仮想マシンを提供するサービスです。ユーザーはOS、マシンタイプ、ストレージ、ネットワークの設定などをカスタマイズすることができます。<br>プリエンプティブVMインスタンス：Google Cloudのリソース使用効率を最大化するための仮想マシンです。標準のVMインスタンスよりも大幅に低いコストで使用できますが、最大で24時間しか持続しない、また使用中の予告なしに割り当てが解除される可能性があります。バックグラウンドの計算タスクに適しています。<br>Google Kubernetes Engine：Google Cloud上でコンテナ化されたアプリケーションを実行するためのマネージドサービスです。高度なスケーリング、ロードバランシング、管理機能を提供しますが、零次のニーズには高コストとなる可能性があります。<br>マシンタイプ：Google Cloudで使用できる各仮想マシンのCPU、メモリ、ストレージといったリソース構成です。衡量基準として、標準マシンタイプ、高CPU型マシンタイプ、高メモリ型マシンタイプ、マイクロバーストをサポートするマシンタイプなどがあります。<br>正解についての説明：<br>（選択肢）<br>・Compute Engineを選択します。適切な標準マシンタイプのプリエンプティブVMインスタンスを使用します<br>この選択肢が正解の理由は以下の通りです。<br>Compute EngineのプリエンプティブVMインスタンスは、コスト効率の高い一時的な仕事をするのに適した計算リソースです。プリエンプティブVMインスタンスは通常のインスタンスに比べて大幅に割引されており、短期間（最大24時間）で利用することができます。そのため、約2時間で完了し、毎晩実行されるバッチ処理ジョブに対して、非常にコスト効率的な選択です。<br>ただし、プリエンプティブVMインスタンスは他の要求がある場合や24時間を過ぎた場合に再起動や終了されることがあるため、そのバッチ処理ジョブが予期せぬ割り込みを許容できる必要があります。<br>今回のケースでは、毎晩2時間で完了するバッチジョブであるため、予期せぬ再起動や終了がそれほど問題にならないと考えられます。<br>不正解の選択肢についての説明：<br>選択肢：Google Kubernetes Engineを選択します。小さなインスタンスタイプのシングルノードクラスターを使用します<br>この選択肢が正しくない理由は以下の通りです。<br>Google Kubernetes Engineのシングルノードクラスターは、コストを最小限に抑えるという要件に沿っていません。これは、Kubernetesが継続的な管理とオーバーヘッドを必要とするからです。<br>一方、プリエンプティブVMインスタンスは、通常のインスタンスよりも大幅に低コストで、バッチ処理には理想的です。<br>選択肢：Google Kubernetes Engineを選択します。マイクロインスタンスタイプで3ノードクラスターを使用します<br>この選択肢が正しくない理由は以下の通りです。<br>Google Kubernetes Engineはコンテナ化されたアプリケーションを実行するのに最適ですが、単一のバッチ処理ジョブには過度に複雑で高コストになる可能性があります。<br>一方、プリエンプティブVMは断続的なワークロードに適しており、Compute Engineの通常のインスタンスよりも低価格であるため、コストを最小限に抑えるには最適です。<br>選択肢：Compute Engineを選択します。マイクロバーストをサポートするVMインスタンスタイプを使用します<br>この選択肢が正しくない理由は以下の通りです。<br>マイクロバーストをサポートするVMインスタンスタイプは一時的に処理能力が高まる特性がありますが、2時間にわたるバッチ処理ジョブには適していません。<br>また、プリエンプティブVMインスタンスは割引率が高くコストを抑えることが可能で、バッチ処理のような中断可能なワークロードに適しています。'>
<div class='choice'> Google Kubernetes Engineを選択します。小さなインスタンスタイプのシングルノードクラスターを使用します</div>
<div class='choice'> Compute Engineを選択します。適切な標準マシンタイプのプリエンプティブVMインスタンスを使用します</div>
<div class='choice'> Google Kubernetes Engineを選択します。マイクロインスタンスタイプで3ノードクラスターを使用します</div>
<div class='choice'> Compute Engineを選択します。マイクロバーストをサポートするVMインスタンスタイプを使用します</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題4<br>Google Cloud上でリレーショナルデータのための費用対効果の高いソリューションを選択し、構成したいと考えています。1つの地理的ロケーションにある小規模な運用データを扱っています。ポイントインタイムリカバリーをサポートする必要があります。<br>あなたはこの要件を満たすために、どうすればよいですか？' data-answer='2' data-explanation='解説<br>正解は「Cloud SQL（MySQL）を選択します。enable binary loggingオプションが選択されていることを確認します」です。<br>この問題では、リレーショナルデータのコスト効率の良いソリューションを求められており、さらにポイントインタイムリカバリーの必要性が強調されています。また、データは一つの地理的なロケーションにあり、小規模な運用とされています。選択肢を選ぶ際には、これら要件を満たすソリューションを選ぶ重要性を理解しておく必要があります。異なるソリューションの特性とそれらが提供する機能について十分に理解していることが求められます。<br>基本的な概念や原則：<br>Cloud SQL：Google Cloudのフルマネージドリレーショナルデータベースサービスです。MySQL、PostgreSQL、SQL Serverをサポートしています。<br>Binary Logging：MySQLのアクティビティを記録するためのプロセスです。これにより、データのポイントインタイムリカバリーが可能になります。<br>Cloud Spanner：Google Cloudのフルマネージド、ミッションクリティカルなリレーショナルデータベースサービスです。グローバルな規模のトランザクションをサポートしています。<br>Failover Replicas：データベースのダウンタイムを防ぐために、主要なデータベースインスタンスのコピーを作成します。ただし、ポイントインタイムリカバリーの要件を満たすためにはBinary Loggingの有効化が必要です。<br>正解についての説明：<br>（選択肢）<br>・Cloud SQL（MySQL）を選択します。enable binary loggingオプションが選択されていることを確認します<br>この選択肢が正解の理由は以下の通りです。<br>Google Cloud SQLは、フルマネージドのリレーショナルデータベースサービスであり、特に小規模な運用データに対してぴったりの選択肢です。それは、スケーラビリティ、柔軟性、そして利便性を提供し、低コストのソリューションで運用できます。<br>また、Cloud SQLの"enable binary logging"オプションを選択することで、指定した時点でのデータ復元（ポイントインタイムリカバリー）が可能になります。これは、障害やデータ喪失が発生した時に、データベースを特定の過去の状態に戻すことができるため、データの安全性という観点から非常に重要な機能です。<br>よって、Google Cloud SQLを選択し、バイナリログを有効にすることで、要件を満たすことができます。<br>不正解の選択肢についての説明：<br>選択肢：Cloud SQL（MySQL）を選択します。create failover replicasオプションを選択します<br>この選択肢が正しくない理由は以下の通りです。<br>create failover replicasオプションは冗長性を提供し、障害時に利用できますが、ポイントインタイム復元をサポートするわけではありません。<br>それに対して、enable binary loggingオプションを有効にすることで、特定のポイントまでデータを復元することができます。<br>選択肢：Cloud Spannerを選択します。2ノードでインスタンスをセットアップします<br>この選択肢が正しくない理由は以下の通りです。<br>Cloud Spannerは費用対効果が高く大規模で地理的に分散したデータを扱うためのリレーショナルデータベースサービスです。<br>しかし、ここでは小規模な運用データを扱う作業が要求されており、Cloud SQLの方が費用対効果が高いため、Cloud Spannerは適切な選択肢ではありません。<br>選択肢：Cloud Spannerを選択します。インスタンスをマルチリージョンに設定します<br>この選択肢が正しくない理由は以下の通りです。<br>Cloud Spannerは地方分散型のアプリケーションで強力な性能を発揮しますが、単一リージョンで利用する小規模運用データにはオーバースペックであり、費用対効果が低いです。対してCloud SQL（MySQL）はbinary loggingを有効化すれば、ポイントインタイムリカバリーをサポートし、費用対効果の観点からも適しています。'>
<div class='choice'> Cloud Spannerを選択します。2ノードでインスタンスをセットアップします</div>
<div class='choice'> Cloud Spannerを選択します。インスタンスをマルチリージョンに設定します</div>
<div class='choice'> Cloud SQL（MySQL）を選択します。enable binary loggingオプションが選択されていることを確認します</div>
<div class='choice'> Cloud SQL（MySQL）を選択します。create failover replicasオプションを選択します</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題5<br>あなたはKubernetes Engineクラスターで複数のマイクロサービスを実行しています。あるマイクロサービスは画像をレンダリングしています。画像のレンダリングを担当するマイクロサービスは、必要なメモリに比べて大量のCPU時間を必要とします。他のマイクロサービスは、N1標準マシンタイプに最適化されたワークロードです。すべてのワークロードが可能な限り効率的にリソースを使用できるように、クラスターを最適化する必要があります。<br>この要件を満たすために、どうすればよいですか？' data-answer='1' data-explanation='解説<br>正解は「画像レンダリングマイクロサービス用に、コンピューティングに最適化されたマシンタイプのノードでノードプールを作成します。他のマイクロサービスには、汎用マシン型ノードのノードプールを使用します」です。<br>この問題では、あなたがGoogle Kubernetes Engine（GKE）を用いて複数のマイクロサービスを運用しており、その中で画像レンダリングサービスが比較的多くのCPU使用が必要という要件に対応する方法を考える必要があります。その他のサービスは標準的なCPU使用率です。課題は、全てのマイクロサービスが最も効率的にリソースを使用できるようにすることです。これを解決するためには、Kubernetesの各サービスに最適なハードウェア設定をするためのノードプールの設計や、ポッドの優先順位の設定、そしてリソース要求の設定など、GKEクラスターの設計及び調整に関する知識が必要です。具体的な解答に至るまでにはこれらを元に選択肢を評価する必要があります。<br>基本的な概念や原則：<br>Kubernetes Engine：Google CloudのマネージドKubernetesサービスです。コンテナ化されたアプリケーションのデプロイ、スケーリング、管理を簡単にすることができます。<br>マイクロサービス：小さく、疎結合されたサービスから構成されるアーキテクチャーのスタイルです。各マイクロサービスは独立してデプロイとスケーリングが可能です。<br>ノードプール：Google Kubernetes Engine（GKE）の一部で、同じ設定を持ったノード（VMインスタンス）のグループです。<br>コンピューティングに最適化されたマシンタイプ：CPUに重点を置いた作業に適したGoogle Cloudのマシンタイプです。画像レンダリングなどの高い計算能力を必要とするワークロードに適しています。<br>N1標準マシンタイプ：Google Cloudの汎用マシンタイプで、バランスの取れたCPUとメモリを特徴としています。一般的なワークロードに適用します。<br>ポッド優先度：Kubernetesで指定できる設定で、リソースが足りない場合にどのポッドを優先してリソースを割り当てるべきかを定義します。<br>リソース要求：Kubernetesの設定で、ポッドが必要とするCPUやメモリの量を指定します。適切なリソース要求を設定することで、ワークロードのパフォーマンスと安定性を保つことができます。<br>正解についての説明：<br>（選択肢）<br>・画像レンダリングマイクロサービス用に、コンピューティングに最適化されたマシンタイプのノードでノードプールを作成します。他のマイクロサービスには、汎用マシン型ノードのノードプールを使用します<br>この選択肢が正解の理由は以下の通りです。<br>まず、ノードプールを作成することにより、同じKubernetes Engineクラスター上で異なるマシンタイプを使用することが可能になります。これは異なるタイプのワークロード、特に異なる資源要求を持つワークロードを効率的に処理する上で非常に有用です。そのため、大量のCPU時間を必要とする画像レンダリングマイクロサービスのために、コンピューティングに最適化されたマシンタイプのノードでノードプールを作成することは、そのマイクロサービスのパフォーマンスを最適化します。<br>一方、他のマイクロサービスはN1標準マシンタイプに最適化されているので、そのためのノードプールとして汎用マシン型ノードを使用することは、それらのマイクロサービスに適したリソースを提供し、全体の効率を向上させます。これにより、全体としてクラスター内のワークロードが効率的にリソースを使用することができます。<br>不正解の選択肢についての説明：<br>選択肢：画像レンダリングマイクロサービスのポッドに、他のマイクロサービスよりも高いポッド優先度を割り当てます<br>この選択肢が正しくない理由は以下の通りです。<br>ポッドの優先度は、ポッドがスケジュールされる順序を制御しますが、それがリソースの最適化や効率的な利用に貢献するわけではありません。むしろ、リソースの要件が厳格に異なるマイクロサービスのために専用のノードプールを作成する方がより効果的です。<br>選択肢：画像レンダリングマイクロサービスには、汎用マシン型ノードのノードプールを使用します。他のマイクロサービス用に、計算を最適化したマシン型ノードのノードプールを作成します<br>この選択肢が正しくない理由は以下の通りです。<br>まず、画像レンダリングマイクロサービスは大量のCPU時間を必要とするので、計算を最適化したマシン型ノードのノードプールを使用すべきです。汎用マシン型ノードではその需要に対する効率が低くなります。他のマイクロサービスは、N1標準マシンに最適化されているので、汎用マシン型ノードの方が適しています。<br>選択肢：画像レンダリングマイクロサービスデプロイのリソース要求仕様で、必要なCPUとメモリの量を設定します。他のマイクロサービスのリソース要求はデフォルトのままにしておきます<br>この選択肢が正しくない理由は以下の通りです。<br>CPUを多く使う画像レンダリングマイクロサービスに対し、リソース要求仕様だけで容量を設定した場合、他のマイクロサービスのリソース使用が決められていないため、全体的なリソースの最適化には至りません。各マイクロサービスに対し適切なノードプールを割り当てることで、より効率的なリソース使用が可能です。'>
<div class='choice'> 画像レンダリングマイクロサービスには、汎用マシン型ノードのノードプールを使用します。他のマイクロサービス用に、計算を最適化したマシン型ノードのノードプールを作成します</div>
<div class='choice'> 画像レンダリングマイクロサービス用に、コンピューティングに最適化されたマシンタイプのノードでノードプールを作成します。他のマイクロサービスには、汎用マシン型ノードのノードプールを使用します</div>
<div class='choice'> 画像レンダリングマイクロサービスのポッドに、他のマイクロサービスよりも高いポッド優先度を割り当てます</div>
<div class='choice'> 画像レンダリングマイクロサービスデプロイのリソース要求仕様で、必要なCPUとメモリの量を設定します。他のマイクロサービスのリソース要求はデフォルトのままにしておきます</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題6<br>あなたのVMは、サブネットマスクが255.255.255.240のサブネットで動作しています。現在のサブネットにはもう空きIPアドレスがなく、新しいVM用に追加の10個のIPアドレスが必要です。既存のVMと新しいVMはすべて、追加のルートなしで互いに到達できるはずです。<br>この要件を満たすために、どうすればよいですか？' data-answer='2' data-explanation='解説<br>正解は「現在のサブネットのIP範囲を拡大するにはgcloudコマンドを使います」です。<br>この問題では、サブネットの拡張について考えることが必要です。現在のサブネットに空きIPアドレスがない状態で、新たにIPアドレスが必要であり、既存と新規のVMが追加のルートなしで通信可能であるという要請に対して適切な対応を選ぶことが求められています。選択肢を検討する際、IPアドレスの範囲を変更する方法に留意し、その際に通信が可能な状態を保つための最適な手法に焦点を当てる必要があります。<br>基本的な概念や原則：<br>サブネットマスク：ネットワークとホスト部分を分けるための数値で、IPアドレスの範囲を定義します。サブネットマスクが広いほど、利用可能なIPアドレスの数は少なくなります。<br>IP範囲の拡大：サブネット内の利用可能なIPアドレスの数を増やすための手法です。サブネットマスクを変更することで、サブネット内のIPアドレスの範囲を広げることができます。<br>gcloudコマンド：Google Cloudの製品とサービスを管理するためのコマンドラインツールです。APIリクエストを行い、リソースの作成、更新、削除などを行うことができます。<br>Shared VPC：複数のプロジェクト間でネットワークリソースを共有するための機能です。サービスプロジェクトに存在するVMは、ホストプロジェクトのVPCネットワークとサブネットを利用することができます。新しいプロジェクトを作成する代わりにサブネットのIP範囲を拡大する方が効率的です。<br>正解についての説明：<br>（選択肢）<br>・現在のサブネットのIP範囲を拡大するにはgcloudコマンドを使います<br>この選択肢が正解の理由は以下の通りです。<br>まず、Google Cloudでは、サブネットのIP範囲を後から拡大することができます。これはgcloudコマンドを使って行うことができます。既存のVMと新しいVMが全て追加のルートなしで互いに到達できる必要があるとの要件から、新たに別のサブネットを作成し、そこに新しいVMを配置することは難しいかもしれません。その点、既存のサブネットのIP範囲を拡大することで、全てのVMが同じサブネット内に留まることができ、互いに到達可能性を保つことができます。<br>また、新たに10のIPアドレスが必要との事ですが、サブネットマスクを拡大することで十分な数のIPアドレスが確保できます。<br>したがって、この選択肢が最も適切な解答です。<br>不正解の選択肢についての説明：<br>選択肢：サブネットを削除し、より広い範囲のIPアドレスを使って再作成します<br>この選択肢が正しくない理由は以下の通りです。<br>サブネットを削除し再作成すると、既存のVMが接続切れを引き起こしたり通信上の問題が発生する可能性があります。<br>それに対して、gcloudコマンドを使いIP範囲を拡大すると、既存のVMへ影響を与えずに新たなIPアドレスを確保できます。<br>選択肢：新しいプロジェクトを作成します。Shared VPCを使用して、現在のネットワークを新しいプロジェクトと共有します<br>この選択肢が正しくない理由は以下の通りです。<br>新しいプロジェクトを作成しShared VPCを使うのはIPアドレスを増やせますが、新しいプロジェクトでの操作になります。これは既存VMと新VMが追加のルートなしで互いに到達できる要件を満たさない為です。<br>それに対して、gcloudコマンドを使用してIP範囲を拡大する方法なら既存サブネット内でIPアドレスを増やせ満足します。<br>選択肢：現在のサブネットを上書きするために、同じ開始IPでより広い範囲の新しいサブネットを作成します<br>この選択肢が正しくない理由は以下の通りです。<br>Google Cloudでは、一度作成したサブネットの範囲を手動で拡大することができますが、既存のサブネットを上書きして新しいサブネットを作成することはできません。現在のサブネットのIP範囲を拡大するにはgcloudコマンドを使用すべきです。'>
<div class='choice'> サブネットを削除し、より広い範囲のIPアドレスを使って再作成します</div>
<div class='choice'> 新しいプロジェクトを作成します。Shared VPCを使用して、現在のネットワークを新しいプロジェクトと共有します</div>
<div class='choice'> 現在のサブネットのIP範囲を拡大するにはgcloudコマンドを使います</div>
<div class='choice'> 現在のサブネットを上書きするために、同じ開始IPでより広い範囲の新しいサブネットを作成します</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題7<br>カスタムモードVPCのサブネットでプライマリプライベートIPアドレスが不足しています。サブネットのIP範囲は10.0.0.0/20で、IPアドレスは主にプロジェクト内の仮想マシンで使用されます。あなたは、仮想マシンのためにより多くのIPアドレスを提供する必要があります。<br>この要件を満たすために、どうすればよいですか？' data-answer='1' data-explanation='解説<br>正解は「サブネットのIP範囲を10.0.0.0/20から10.0.0.0/18に変更します」です。<br>この問題では、ネットワーキングとIPアドレッシングの基本的な理解が求められます。問題文からは、VPCのサブネット内で利用できるIPアドレスが不足していることが分かります。問題解決のためには、仮想マシンで使用するためのIPアドレスを増やす解決策を選択する必要があります。そして、IPアドレスの範囲を拡大する方法を理解しているかどうかが試されています。そのため、選択肢の中からIPアドレスの範囲を増やす適切な方法を選ぶことが重要です。<br>基本的な概念や原則：<br>CIDR表記：ネットワークアドレスとネットワークサイズ（ネットマスク）を "/" で続けて表記する手法です。例えば、10.0.0.0/20の場合、20はネットマスクの長さ（使えるIPアドレスの範囲）を表します。<br>サブネット（サブネットワーク）：ネットワークを小さなネットワークに分割したものです。IPアドレスの範囲（CIDRブロック）が割り当てられます。<br>IPアドレスの範囲拡張：CIDR表記でネットマスクを短くする（例：/20から/18）ことでIPアドレスの範囲を拡張できます。ただし、既存のサブネットと重複しない範囲を設定する必要があります。<br>仮想マシン（VM）：物理的なハードウェアをエミュレートしたソフトウェアです。仮想マシンごとに独立したIPアドレスが必要です。<br>セカンダリIP範囲：サブネットに追加で設定可能なIPアドレスの範囲です。ただし、Compute EngineのVMに使用することはできません。主にGKEやAppEngineで使用します。<br>正解についての説明：<br>（選択肢）<br>・サブネットのIP範囲を10.0.0.0/20から10.0.0.0/18に変更します<br>この選択肢が正解の理由は以下の通りです。<br>まず、サブネットのIP範囲を調整することによって、そのサブネット内で利用可能なIPアドレスの数を増やすことができます。具体的には、プライマリプライベートIPアドレスが不足している場合には、CIDR表記を利用したIP範囲を拡大することで解決します。CIDR表記は、IPアドレスとある評価数を組み合わせた形で、例えば10.0.0.0/20という表記はIPアドレス10.0.0.0の範囲が20ビットであることを示しています。つまり、範囲のサイズが大きければ大きいほど、その範囲内に収まるIPアドレスの数は多くなります。<br>今回の問題では、範囲を10.0.0.0/20から10.0.0.0/18に変更することで、範囲内のIPアドレスが4倍に増加し、それに応じて仮想マシンのためのIPアドレスも増えます。<br>不正解の選択肢についての説明：<br>選択肢：サブネットにセカンダリIP範囲10.1.0.0/20を追加します<br>この選択肢が正しくない理由は以下の通りです。<br>セカンダリIP範囲を追加することは、既存のサブネットが使うIPアドレスを増やすのではなく、別の範囲のIPアドレスを提供するためのものです。つまり、仮想マシンが使用するプライマリIPアドレスの範囲を増やすという要件を満たしません。それに対して正解の選択肢は、サブネットのIPアドレス範囲を広げることで、使用可能なIPアドレスを増やすため、要件を満たします。<br>選択肢：サブネットのIP範囲を10.0.0.0/20から10.0.0.0/22に変更します<br>この選択肢が正しくない理由は以下の通りです。<br>CIDR表記では、スラッシュ(/)の後ろの数値が小さくなると、利用可能なIPアドレスの数は増えます。この不正解選択肢では、/20から/22に範囲を変更しているため、利用可能なIPアドレスの数が減ってしまい、IPアドレスの不足問題を解決できません。<br>一方で、正解の選択肢では、/20から/18に範囲を変更しており、これにより利用可能なIPアドレスが増え、問題を解決できます。<br>選択肢：サブネットのIP範囲をIPv4からIPv6に変換します<br>この選択肢が正しくない理由は以下の通りです。<br>Google CloudのVPCネットワークはIPv6をサポートしていません。存在する仮想マシンがIPv4を使用しているため、突然のIPv6への変換は互換性の問題を引き起こします。<br>一方、IP範囲を10.0.0.0/20から10.0.0.0/18に変更すると、利用可能なIPアドレスが増加し、要件を満たすことができます。'>
<div class='choice'> サブネットのIP範囲を10.0.0.0/20から10.0.0.0/22に変更します</div>
<div class='choice'> サブネットのIP範囲を10.0.0.0/20から10.0.0.0/18に変更します</div>
<div class='choice'> サブネットにセカンダリIP範囲10.1.0.0/20を追加します</div>
<div class='choice'> サブネットのIP範囲をIPv4からIPv6に変換します</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題8<br>あなたの会社では、MySQLデータベースを使用する仮想マシン上で3層のWebアプリケーションを実行しています。このアプリケーションをGoogle CloudインスタンスとCloud SQLで実行するために、クラウドインフラストラクチャの総コストの見積もりを作成する必要があります。<br>この要件を満たすために、どうすればよいですか？' data-answer='2' data-explanation='解説<br>正解は「Google Cloud Pricing Calculatorを使用して、使用すると予想されるすべてのGoogle Cloudリソースのコストを決定します。Webサーバーには同じようなサイズのインスタンスを使用し、Cloud SQLには現在のオンプレミスのマシンを比較対象として使用します」です。<br>この問題では、仮想マシンで動作するMySQLデータベースを用いた3層のWebアプリケーションをGoogle Cloud上で動作させる際のコスト見積もりを作成する方法について問われています。解答を導き出すためには、Google Cloudの料金体系やGoogle Cloud Pricing Calculatorについての理解が必要です。また、該当リソースとしてWebサーバーやCloud SQLなどが挙げられており、これらに対する適切なコスト見積もり手段を選ぶことが求められます。各選択肢の適否判断の際には、Google Cloudの各サービスや料金体系の知識と、実際の利用シナリオにおける費用効率を考慮する必要があります。<br>基本的な概念や原則：<br>Google Cloud Pricing Calculator：Google Cloudの各種サービスのコストを予測するためのツールです。使用するサービスと資源の量を入力することで、見積もりを作成します。<br>Cloud SQL：フルマネージド型のリレーショナルデータベースサービスです。MySQL、PostgreSQL、SQL Serverなどのデータベースエンジンを提供しています。<br>Webアプリケーションの3層構造：一般的なWebアプリケーションの構造で、プレゼンテーション層（フロントエンド）、ビジネスロジック層（バックエンド）、データストレージ層から成り立っています。<br>Google Cloudインスタンス：Google Cloud Compute Engineの仮想サーバーのことを指します。インスタンスのタイプやサイズに応じた料金が課金されます。<br>オンプレミスとクラウドの比較：クラウド移行の際には、現行のオンプレミスのリソースとクラウドのリソースを比較することが重要です。この比較により、必要なリソースと予測されるコストを評価します。<br>負荷テスト：システムが高負荷状態で正常に動作するかをテストします。この結果を元に実際に発生すると予想されるコストを評価することができますが、テスト環境と本番環境での動作が異なる可能性もあります。<br>Googleスプレッドシート：Googleドキュメントの一部で、エクセルのようなスプレッドシートをクラウド上で共有・編集できます。各種計算機能もありますが、Google Cloud Pricing Calculatorのような専用ツールが既に存在するため、費用見積もりには向いていません。<br>正解についての説明：<br>（選択肢）<br>・Google Cloud Pricing Calculatorを使用して、使用すると予想されるすべてのGoogle Cloudリソースのコストを決定します。Webサーバーには同じようなサイズのインスタンスを使用し、Cloud SQLには現在のオンプレミスのマシンを比較対象として使用します<br>この選択肢が正解の理由は以下の通りです。<br>まず、Google Cloud Pricing CalculatorはGoogle Cloudで利用する予想リソースの見積もりを試算できるツールで、仮想マシンやデータベースなどのリソースの使用料を簡単に試算可能なため、総コスト見積もり作成に役立ちます。<br>また、クラウド移行の際は、オンプレミス環境と同等もしくはそれ以上の性能を持つインスタンスやデータベースを選定することが重要です。同などのWebサーバーとして同じ規模のインスタンスを選び、Cloud SQLについても現在使用しているMySQLデータベースと比較的近いリソースを選ぶという方法は、効率的かつ的確なコスト見積もりを作成する理論的・現実的考慮に基づいています。よって、この選択肢が正確に見積もりを立てるための最善のアプローチと言えます。<br>不正解の選択肢についての説明：<br>選択肢：複数のGoogle Cloudリソースの組み合わせでGoogleスプレッドシートを作成します。別のシートで、現在のGoogle Cloudの価格をインポートし、数式内の計算にこれらの価格を使用します<br>この選択肢が正しくない理由は以下の通りです。<br>Google Cloud Pricing Calculatorを使用すると、正確かつ簡単に見積もりを作成できます。<br>一方、スプレッドシートを使用した方法は手間がかかり、価格が変動する可能性も考慮すると、常に最新の情報で見積もりを更新することが難しいため、効率的ではありません。<br>選択肢：Google Cloud Pricing Calculatorを使用し、Cloud Operationsテンプレートを選択して、Webアプリケーションをできるだけ詳細に定義します<br>この選択肢が正しくない理由は以下の通りです。<br>Cloud Operationsテンプレートは、監視、トレース、ロギングなどの運用管理機能のコスト見積もりを行うために使用するものであり、仮想マシンやCloud SQLデータベースなどのリソースの見積もりを行うのに適していません。それに対して正解の選択肢におけるインスタンスやCloud SQLは、アプリケーションを実行する上での直接的なコストを計算することができます。<br>選択肢：Google Cloud上で同様のアーキテクチャを実装し、小規模で妥当な負荷テストを実行します。課金情報を確認し、システムが通常処理する実際の負荷に基づいて推定コストを計算します<br>この選択肢が正しくない理由は以下の通りです。<br>全体のシステムを実装し負荷テストを実行することは負担が大きく、また結果を得るまでに時間がかかります。それに対してGoogle Cloud Pricing Calculatorを使用すると、予想されるリソースのコストをすぐに、そして確実に把握することができます。'>
<div class='choice'> Google Cloud上で同様のアーキテクチャを実装し、小規模で妥当な負荷テストを実行します。課金情報を確認し、システムが通常処理する実際の負荷に基づいて推定コストを計算します</div>
<div class='choice'> 複数のGoogle Cloudリソースの組み合わせでGoogleスプレッドシートを作成します。別のシートで、現在のGoogle Cloudの価格をインポートし、数式内の計算にこれらの価格を使用します</div>
<div class='choice'> Google Cloud Pricing Calculatorを使用して、使用すると予想されるすべてのGoogle Cloudリソースのコストを決定します。Webサーバーには同じようなサイズのインスタンスを使用し、Cloud SQLには現在のオンプレミスのマシンを比較対象として使用します</div>
<div class='choice'> Google Cloud Pricing Calculatorを使用し、Cloud Operationsテンプレートを選択して、Webアプリケーションをできるだけ詳細に定義します</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題9<br>Cloud Storageのバケットにデータをアーカイブするソリューションを構成したいと考えています。このソリューションは費用対効果が高くなければなりません。複数のバージョンがあるデータは、30日後にアーカイブします。以前のバージョンは月に一度、レポートのためにアクセスされます。このアーカイブデータは、月末に更新されることもあります。<br>この要件を満たすために、どうすればよいですか？' data-answer='0' data-explanation='解説<br>正解は「30日後に新しいバージョンのデータをNearlineストレージにアーカイブするバケットライフサイクルルールを追加します」です。<br>この問題では、データの保存とアーカイブに関する要件が述べられています。Cloud Storageのバケットを利用してデータをアーカイブしなければならず、バージョン管理が求められており、また費用対効果が重要な要素となっています。さらに、特定の頻度で旧バージョンのデータにアクセスし、時折データを更新する必要があるため、これらの要件を満たす適切なストレージクラスとデータ管理ポリシーを正しく識別することが肝心です。<br>基本的な概念や原則：<br>Cloud Storage：Google Cloudのオブジェクトストレージサービスです。データを安全に保存し、アクセスできます。<br>Nearlineストレージ：Cloud Storageのストレージクラスの一つで、低頻度にアクセスするデータの保存に適しています。費用対効果が高く、アクセス時のレイテンシは通常のオブジェクトストレージと同等です。<br>バケットライフサイクルルール：Cloud Storageのバケットに適用するカスタムルールです。特定の条件を満たすと、オブジェクトを自動的に移行したり削除したりすることができます。<br>Coldlineストレージ：Cloud Storageのストレージクラスの一つで、長期間保存のためのデータや災害復旧のためのデータの保存に適しています。Nearlineストレージよりもコストは低いですが、データの取り出しには時間がかかり、費用もかかります。<br>リージョナルストレージ：Cloud Storageのストレージクラスの一つで、特定のリージョン内で頻繁にアクセスされるデータの保存に適しています。高可用性と高耐久性を提供します。<br>正解についての説明：<br>（選択肢）<br>・30日後に新しいバージョンのデータをNearlineストレージにアーカイブするバケットライフサイクルルールを追加します<br>この選択肢が正解の理由は以下の通りです。<br>まず、Google Cloud StorageのNearlineストレージクラスは、月に一度程度のアクセスが予測されるデータに対してコスト効率が高いです。バケットライフサイクルルールを使用して、30日後に新しいバージョンのデータをNearlineストレージに自動的に移行することで、コストを効率的に管理できます。<br>また、Nearlineストレージクラスは、データがアクティブでなくなってから30日以内にデータを削除した場合の早期削除料を避けるため、データを30日間保持するのに適しています。<br>さらに、Nearlineストレージへのデータ移動は、データの可用性や耐久性に影響を与えません。これらの要素が組み合わさり、コスト効率が高く、パフォーマンスに影響を与えず、レポートのために月に一度アクセスする要件を満たすため、この選択肢が正解です。<br>不正解の選択肢についての説明：<br>選択肢：Coldlineストレージに、30日後に新しいバージョンのデータをアーカイブするバケットライフサイクルルールを追加します<br>この選択肢が正しくない理由は以下の通りです。<br>それぞれのバージョンは月に1度アクセスされますが、Coldlineストレージは90日以内のアクセスに対して追加料金を発生させるため、費用対効果が低くなります。正解のNearlineストレージは30日後でも追加料金がかからず費用対効果が高いため、適しています。<br>選択肢：30日後にリージョンストレージからColdlineストレージにデータをアーカイブするバケットライフサイクルルールを追加します<br>この選択肢が正しくない理由は以下の通りです。<br>データをアーカイブする際、Coldlineストレージは90日以上保存するデータに適しています。このケースでは、データが月に一度アクセスされ、月末に更新される可能性があるため、Coldlineよりもアクセス頻度が高く許容されるNearlineが適切です。<br>選択肢：30日後にリージョナルストレージからNearlineストレージにデータをアーカイブするバケットライフサイクルルールを追加します<br>この選択肢が正しくない理由は以下の通りです。<br>リージョナルストレージからNearlineストレージにデータをアーカイブするルールを追加すると、データ移行コストが発生します。これが費用対効果を低下させます。<br>対照的に、新バージョンのデータを最初からNearlineストレージにアーカイブする正解選択肢はこれを避けています。'>
<div class='choice'> 30日後に新しいバージョンのデータをNearlineストレージにアーカイブするバケットライフサイクルルールを追加します</div>
<div class='choice'> 30日後にリージョンストレージからColdlineストレージにデータをアーカイブするバケットライフサイクルルールを追加します</div>
<div class='choice'> 30日後にリージョナルストレージからNearlineストレージにデータをアーカイブするバケットライフサイクルルールを追加します</div>
<div class='choice'> Coldlineストレージに、30日後に新しいバージョンのデータをアーカイブするバケットライフサイクルルールを追加します</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題10<br>あなたはGoogle Cloud上で複数のGoogle Cloudサービスを使用するソリューションを設計しました。あなたの会社は、ソリューションのコストを見積もるようあなたに依頼しました。あなたは、毎月の総コストの見積もりを提供する必要があります。<br>この要件を満たすために、どうすればよいですか？' data-answer='0' data-explanation='解説<br>正解は「ソリューション内の各Google Cloudサービスについて、製品の価格ページで価格の詳細を確認します。Pricing Calculatorを使用して、各Google Cloudサービスの月額コストを合計します」です。<br>この問題では、Google Cloud上で構築予定のシステムの総コストを見積もる方法が求められています。注目すべきポイントは、毎月総コストを予測したい、ということ項であり、これには使用予定の各サービスの価格情報が必要です。また、各サービスがどのように使用されるのかにより、費用は変動するので、費用見積もりは使用状況を予測した上で行うことが必要です。問題解決の手がかりとなるのは、それぞれのサービスの価格ページとPricing Calculatorの活用です。見積もりを行う際は単にそれぞれのサービスで掛かる費用を合計するだけでなく、それぞれのサービスがシステム全体でどのように働くか、その関連性も考慮することが求められています。<br>基本的な概念や原則：<br>Google Cloudサービス：Google Cloudが提供する様々なクラウドサービスのことです。それぞれのサービスは異なる機能を持ち、異なる料金体系があります。<br>製品の価格ページ：Google Cloudのウェブサイト上にある各サービスの詳細な料金情報を提供するページです。使用量に応じたコストを確認できます。<br>Pricing Calculator：Google Cloudが提供するツールで、異なるサービスの使用コストを予測できます。サービスの使用時間や使用量に基づいて計算を行うことができます。<br>Googleシート：Googleが提供するスプレッドシートツールです。コスト計算や予測など、様々な情報の集計や管理に使用できますが、正確なコスト予測には適していません。<br>Billing Report：Google Cloudの課金情報を表示するツールです。しかし、一週間の使用コストから一ヶ月のコストを予測するのは正確でないかもしれません。<br>Cloud Monitoring：Google Cloudのリソースやアプリケーションのパフォーマンスを監視するツールです。リソースの使用量を追跡できますが、その情報を月額コストに直接変換することはできません。<br>プロビジョニング：Google Cloud上でリソースを確保、設定、管理するプロセスです。しかし、短期間のプロビジョニングコストから長期的なコストを予測するのは不正確である可能性があります。<br>正解についての説明：<br>（選択肢）<br>・ソリューション内の各Google Cloudサービスについて、製品の価格ページで価格の詳細を確認します。Pricing Calculatorを使用して、各Google Cloudサービスの月額コストを合計します<br>この選択肢が正解の理由は以下の通りです。<br>まず、ソリューションを設計する際には各サービスのコストが重要な要素となるため、Google Cloudの製品価格ページを通じて、使用する各サービスの詳細な価格情報を得ることが非常に重要です。これにより、各サービスの単価を理解し、それが全体的なコストにどのように影響するか確認できます。<br>また、Pricing CalculatorはGoogle Cloudのツールであり、複数のサービスのコストを総計し月額の総コストを見積もることができます。要件には月次のコスト見積もりが求められているため、このツールを使用することでそれに対応することができます。<br>このように、個別のサービスの価格情報を取得し、それをPricing Calculatorで統合することで、ソリューション全体のコスト見積もりを正確に行うことができます。<br>不正解の選択肢についての説明：<br>選択肢：ソリューション内の各Google Cloudサービスについて、製品の価格ページで価格の詳細を確認します。各製品の予想される月額費用をまとめたGoogleシートを作成します<br>この選択肢が正しくない理由は以下の通りです。<br>Googleシートを使用して予想される月額費用をまとめる手法は主観的判断が含まれやすく、公正性や精度に欠けます。それに対してPricing Calculatorを使用すれば、自動で詳細な予想コストを算出し、より正確で公正な見積もりが可能です。<br>選択肢：ソリューションをGoogle Cloudにプロビジョニングします。ソリューションを1週間プロビジョニングしたままにします。Cloud ConsoleのBilling Reportページに移動します。1週間のコストを掛け算して、毎月のコストを決定します<br>この選択肢が正しくない理由は以下の通りです。<br>ソリューションをプロビジョニングしたままにすると不必要な費用が掛かります。<br>また、1週間のコストを基に月間のコストを決定する方法は正確ではありません。利用料金は使用時間やデータ量によって変動するため、短期間の使用を基に長期間のコストを推定するだけでは正確な見積もりとはならなりません。<br>選択肢：ソリューションをGoogle Cloudにプロビジョニングします。ソリューションを1週間プロビジョニングしたままにします。Cloud Monitoringを使用して、プロビジョニングされたリソース量と使用されたリソース量を決定します。1週間のコストを掛け算して、毎月のコストを決定します<br>この選択肢が正しくない理由は以下の通りです。<br>まず、実際にソリューションをプロビジョニングするオペレーションはコストと時間をかける行為です。<br>また、1週間のデータは全体のトレンドを正確に捉えられない可能性があります。<br>一方、Pricing Calculatorを使えば、時間もコストもかけずに正確な月額コストを計算できます。'>
<div class='choice'> ソリューション内の各Google Cloudサービスについて、製品の価格ページで価格の詳細を確認します。Pricing Calculatorを使用して、各Google Cloudサービスの月額コストを合計します</div>
<div class='choice'> ソリューション内の各Google Cloudサービスについて、製品の価格ページで価格の詳細を確認します。各製品の予想される月額費用をまとめたGoogleシートを作成します</div>
<div class='choice'> ソリューションをGoogle Cloudにプロビジョニングします。ソリューションを1週間プロビジョニングしたままにします。Cloud ConsoleのBilling Reportページに移動します。1週間のコストを掛け算して、毎月のコストを決定します</div>
<div class='choice'> ソリューションをGoogle Cloudにプロビジョニングします。ソリューションを1週間プロビジョニングしたままにします。Cloud Monitoringを使用して、プロビジョニングされたリソース量と使用されたリソース量を決定します。1週間のコストを掛け算して、毎月のコストを決定します</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題11<br>あなたの会社では、オンプレミスのサーバーで、約30時間かかるバッチ処理を1つ実行しています。このタスクは毎月実行され、オフラインで実行でき、中断された場合は再起動する必要があります。コストを最小限に抑えながら、このワークロードをクラウドに移行したいと考えています。<br>この要件を満たすために、どうすればよいですか？' data-answer='1' data-explanation='解説<br>正解は「ワークロードをCompute Engine VMに移行します。必要に応じてインスタンスを起動および停止します」です。<br>この問題では、バッチ処理をクラウドに移行する際のコスト効率の高さと、タスクの中断からの再起動が可能である能力に注意が必要です。問題文から、タスクが月1回しか行われず、その間はオンラインでもオフラインでもできると読み取れます。これらの情報に基づき、適切なクラウド環境とワークロード管理策を選択する必要があります。特に、コスト管理に効果的な手法を優先する必要があると理解すべきです。<br>基本的な概念や原則：<br>Compute Engine VM：Google Cloud上で仮想マシンを実行するためのInfrastructure as a Serviceです。既存のワークロードをクラウドに移行する際によく使用されます。<br>バッチ処理：一連のジョブを自動的に実行する処理方法です。バッチ処理では、ジョブの実行順序やスケジューリングが重要です。<br>Spot VMs：Google Cloudの予約インスタンス定義の一部です。Spot VMsは、Compute Engineの余剰容量を活用してコストを削減するために使用されますが、コンピュート容量が不足するとVMがシャットダウンされます。<br>Managed Instance Group：類似のインスタンスを一元管理するためのサービスです。スケーリングやヘルスチェックを自動的に行います。<br>Google Kubernetes Engine（GKE）：Google Cloud上でKubernetesクラスターを容易に作成、運用するためのマネージドサービスです。コンテナ化されたアプリケーションのデプロイ、スケーリング、管理を行うのに適しています。<br>正解についての説明：<br>（選択肢）<br>・ワークロードをCompute Engine VMに移行します。必要に応じてインスタンスを起動および停止します<br>この選択肢が正解の理由は以下の通りです。<br>まず、Compute Engine VMは、インスタンスを必要に応じて起動および停止することが可能で、これによりコストを効率的に管理することができます。バッチ処理は一度に大量のデータを処理するため、リソースの消費が大きく、また長時間実行されるため、オンデマンドでリソースを利用できるCompute Engine VMは最適です。<br>また、このバッチ処理はオフラインで実行することが可能で、中断は許容されるため、インスタンスの起動と停止をうまく制御することでコストを最小限に抑えながら、リソースを適切に確保することができます。<br>したがって、バッチ処理のワークロードをCompute Engine VMに移行し、必要に応じてインスタンスを起動および停止することは、コストを最小限に抑えつつクラウドに移行するための適切な手段と言えます。<br>不正解の選択肢についての説明：<br>選択肢：Spot VMsを有効化し、Instance Templateを作成します。テンプレートからManaged Instance Groupを作成し、Target CPU Utilizationを調整します。ワークロードを移行します<br>この選択肢が正しくない理由は以下の通りです。<br>Spot VMsは上下が頻繁に発生し、中断された場合の再起動が必要なワークロードには適していません。<br>また、Managed Instance GroupとTarget CPU Utilizationの調整は、一定の性能を保証したい場合やスケールさせたい場合に有用ですが、このケースではコストを最小限に抑えることが求められています。<br>それに対して、正解のCompute Engine VMではインスタンスを必要な時だけ立ち上げ、コストを最小限に抑えることができます。<br>選択肢：ワークロードをSpotノードを持つGoogle Kubernetes Engineクラスターに移行します<br>この選択肢が正しくない理由は以下の通りです。<br>Spotノードを持つGKEクラスターはコスト効率は良いものの、Spotノードは予告なく中断される可能性があります。これは、中断された場合に再起動が必要なバッチ処理には不適しています。<br>一方、Compute Engine VMでは手動でインスタンスの起動・停止を管理できるため、この要件を満たします。<br>選択肢：ワークロードをCompute Engine Spot VMに移行します<br>この選択肢が正しくない理由は以下の通りです。<br>Spot VMは一時的に利用可能なリソースで、予告なく中断される事があります。<br>一方で、課題では、一度開始されたバッチ処理が中断された場合、再起動が必要とされています。これは課題の要件を満たさないため、Spot VMは適切な選択ではありません。'>
<div class='choice'> Spot VMsを有効化し、Instance Templateを作成します。テンプレートからManaged Instance Groupを作成し、Target CPU Utilizationを調整します。ワークロードを移行します</div>
<div class='choice'> ワークロードをCompute Engine VMに移行します。必要に応じてインスタンスを起動および停止します</div>
<div class='choice'> ワークロードをCompute Engine Spot VMに移行します</div>
<div class='choice'> ワークロードをSpotノードを持つGoogle Kubernetes Engineクラスターに移行します</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題12<br>プロジェクト内にApp Engineアプリケーションを含むGoogle Cloudプロジェクトを作成しました。最初に、アプリケーションはus-west2リージョンから提供されるように構成しました。次に、asia-northeast1リージョンからアプリケーションを提供するようにしたいと考えています。<br>あなたはこの要件を満たすために、どうすればよいですか？' data-answer='1' data-explanation='解説<br>正解は「新しいGoogle Cloudプロジェクトを作成し、この新しいプロジェクト内にApp Engineアプリケーションを作成します。アプリケーションを提供するリージョンとしてasia-northeast1を指定します」です。<br>この問題では、Google Cloudプロジェクト内のApp Engineアプリケーションのリージョンを変更する方法が問われています。まず、リージョンは一度設定すると変更できない性質がApp Engineアプリケーションにある事を理解する必要があります。また、1つのGoogle Cloudプロジェクトにつき1つのApp Engineアプリケーションしか作成できないことも留意点です。これらを踏まえ、指定のリージョンから提供するための正しいアプローチを考察することが求められます。<br>基本的な概念や原則：<br>Google Cloudプロジェクト：Google Cloud上の単一の作業空間です。プロジェクトは独立したリソース、制限、設定、ユーザー管理などを持つことができ、サービスの利用状況、アクセス管理などを管理できます。<br>App Engine：フルマネージドのサーバレスプラットフォームで、アプリケーションを自動的にスケーリングしてユーザーの需要に応じてリソースを割り当てます。一度設定したリージョンは変更できません。<br>リージョン：Google Cloudのデータセンターが配置されている地理的なエリアです。各リージョンは複数のゾーンに分割され、リージョン間でのデータ転送やリージョン内でのリソースの使用には料金がかかります。<br>デフォルトのリージョンプロパティ：Google Cloudプロジェクトのリージョン設定です。これはプロジェクトレベルで設定され、作成後に変更することはできません。<br>アプリケーションのリージョンプロパティ：App Engineのリージョン設定です。リージョンはアプリケーション作成時に1度だけ設定可能で、後から変更することはできません。<br>プロジェクトのリージョンプロパティ：プロジェクトのリージョン設定です。プロジェクト作成時に設定され、後から変更することはできません。<br>複数のApp Engineアプリケーション：一つのプロジェクトには一つのApp Engineアプリケーションのみを作成することができます。複数リージョンでApp Engineを稼働させるには複数のプロジェクトを作成する必要あります。<br>正解についての説明：<br>（選択肢）<br>・新しいGoogle Cloudプロジェクトを作成し、この新しいプロジェクト内にApp Engineアプリケーションを作成します。アプリケーションを提供するリージョンとしてasia-northeast1を指定します<br>この選択肢が正解の理由は以下の通りです。<br>まず、App Engineアプリケーションのリージョンは作成時に1度だけ指定でき、その後変更することができません。<br>従って、既存のApp Engineアプリケーションのリージョンをus-west2からasia-northeast1に変更することは可能ではありません。<br>そのため、新しいリージョンでアプリケーションを提供するためには、新しいGoogle Cloudプロジェクトを作成し、そのプロジェクト内にApp Engineアプリケーションを作成する必要があります。この新しいApp Engineアプリケーションのリージョンとしてasia-northeast1を指定すれば、Asia-Northeast1リージョンからアプリケーションを提供することができます。<br>このような理由から、App Engineアプリケーションを新たなリージョンから提供するためには、新しいGoogle Cloudプロジェクトを作成し、新しいプロジェクトで新たにApp Engineアプリケーションを作成する手法が適切です。<br>不正解の選択肢についての説明：<br>選択肢：既存のGoogle Cloudプロジェクトのデフォルトのリージョンプロパティの設定をasia-northeast1に変更します<br>この選択肢が正しくない理由は以下の通りです。<br>一旦設定したApp Engineアプリケーションのリージョンは、後から変更することができません。<br>したがって、新たに異なるリージョンで同一のアプリケーションを提供したい場合には、新しいプロジェクトを作成する必要があります。<br>選択肢：既存のApp Engineアプリケーションのリージョンプロパティ設定をus-centralからasia-northeast1に変更します<br>この選択肢が正しくない理由は以下の通りです。<br>既存のApp Engineアプリケーションのリージョンを変更することはできません。リージョンはApp Engineアプリケーション作成時に選択され、その後変更することができません。<br>したがって、新しいリージョンでアプリケーションを提供するために、新しいプロジェクトを作成し、そのプロジェクト内でアプリケーションを作成する必要があります。<br>選択肢：既存のGoogle Cloudプロジェクトに2つ目のApp Engineアプリケーションを作成し、アプリケーションを提供するリージョンとしてasia-northeast1を指定します<br>この選択肢が正しくない理由は以下の通りです。<br>Google Cloudプロジェクトは1つのApp Engineアプリケーションしか持てないため、既存のプロジェクトに2つ目のApp Engineアプリケーションを作成することはできません。<br>したがって、異なるリージョンからアプリケーションを提供するためには新しいプロジェクトを作成する必要があります。'>
<div class='choice'> 既存のGoogle Cloudプロジェクトのデフォルトのリージョンプロパティの設定をasia-northeast1に変更します</div>
<div class='choice'> 新しいGoogle Cloudプロジェクトを作成し、この新しいプロジェクト内にApp Engineアプリケーションを作成します。アプリケーションを提供するリージョンとしてasia-northeast1を指定します</div>
<div class='choice'> 既存のApp Engineアプリケーションのリージョンプロパティ設定をus-centralからasia-northeast1に変更します</div>
<div class='choice'> 既存のGoogle Cloudプロジェクトに2つ目のApp Engineアプリケーションを作成し、アプリケーションを提供するリージョンとしてasia-northeast1を指定します</div>
</div>
            <!-- 他の問題も同様に追加 -->
        </div>

        <h2 id="question"></h2>
        <ul class="choices" id="choices"></ul>
        <button onclick="checkAnswer()">採点</button>
        <button onclick="nextQuestion()" id="nextButton" style="display: none;">次の問題へ</button>
        <div class="result" id="result"></div>
    </div>

    <script>
        let currentQuestionIndex = 0;
        let correctCount = 0;
        const questions = [];

        document.addEventListener('DOMContentLoaded', () => {
            const questionElements = document.querySelectorAll('#quiz-data .question');
            questions.push(...Array.from(questionElements).map(questionElement => ({
                question: questionElement.getAttribute('data-question').replace(/\\n/g, '<br>'),
                choices: Array.from(questionElement.querySelectorAll('.choice')).map((choice, index) => ({
                    text: choice.innerHTML.replace(/\\n/g, '<br>'),  // innerHTMLに変更
                    index: index
                })),
                correctAnswer: questionElement.getAttribute('data-answer').split(',').map(Number),
                explanation: questionElement.getAttribute('data-explanation').replace(/\\n/g, '<br>'),
                multiple: questionElement.getAttribute('data-multiple') === 'true'
            })));
            showQuestion();
        });

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function showQuestion() {
            const questionElement = document.getElementById('question');
            const choicesContainer = document.getElementById('choices');
            const currentQuestion = questions[currentQuestionIndex];

            shuffleArray(currentQuestion.choices);

            questionElement.innerHTML = currentQuestion.question;
            choicesContainer.innerHTML = '';

            currentQuestion.choices.forEach((choice, i) => {
                const li = document.createElement('li');
                const input = document.createElement('input');
                const label = document.createElement('label');

                input.type = currentQuestion.multiple ? 'checkbox' : 'radio';
                input.name = 'choice';
                input.value = choice.index;
                input.id = 'choice' + i;

                label.htmlFor = 'choice' + i;
                label.innerHTML = choice.text;  // textContentをinnerHTMLに変更

                li.appendChild(input);
                li.appendChild(label);
                choicesContainer.appendChild(li);
            });

            document.getElementById('result').textContent = "";
            document.getElementById('nextButton').style.display = 'none';
        }

        function checkAnswer() {
            const currentQuestion = questions[currentQuestionIndex];
            const selectedChoices = Array.from(document.querySelectorAll('input[name="choice"]:checked'))
                                        .map(checkbox => parseInt(checkbox.value))
                                        .sort();
            const resultElement = document.getElementById('result');
            
            if (selectedChoices.length > 0) {
                const isCorrect = currentQuestion.multiple
                    ? selectedChoices.toString() === currentQuestion.correctAnswer.sort().toString()
                    : selectedChoices.length === 1 && selectedChoices[0] === currentQuestion.correctAnswer[0];
                
                if (isCorrect) {
                    resultElement.innerHTML = "正解です！<br>" + currentQuestion.explanation;
                    resultElement.style.color = "green";
                    correctCount++; // 正解数をカウント
                } else {
                    resultElement.innerHTML = "残念、不正解です。<br>" + currentQuestion.explanation;
                    resultElement.style.color = "red";
                }
                document.getElementById('nextButton').style.display = 'inline';
            } else {
                resultElement.textContent = "回答を選択してください。";
                resultElement.style.color = "orange";
            }
        }

        function nextQuestion() {
            currentQuestionIndex++;
            
            if (currentQuestionIndex < questions.length) {
                showQuestion();
            } else {
                showFinalResult();
            }
        }

        function showFinalResult() {
            const quizContainer = document.querySelector('.quiz-container');
            quizContainer.innerHTML = `
                <h2>問題終了！</h2>
                <p>あなたの正解数は ${correctCount} / ${questions.length} です。</p>
                <button onclick="restartQuiz()">再挑戦する</button>
            `;
        }

        function restartQuiz() {
            correctCount = 0;
            currentQuestionIndex = 0;

            // クイズのUI全体を初期化
            const quizContainer = document.querySelector('.quiz-container');
            quizContainer.innerHTML = `
                <h2 id="question"></h2>
                <ul class="choices" id="choices"></ul>
                <button onclick="checkAnswer()">採点</button>
                <button onclick="nextQuestion()" id="nextButton" style="display: none;">次の問題へ</button>
                <div class="result" id="result"></div>
            `;

            // 初期化後に最初の問題を表示
            showQuestion();
        }        
    </script>
</body>
</html>