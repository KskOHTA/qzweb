<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Google Cloud Leader問題集 03</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="quiz-container">
        <div id="quiz-data" style="display: none;">
<div class='question' data-multiple='FALSE' data-question='問題1<br>あなたはGoogle Kubernetes Engine上で動作するアプリケーションを作成しています。アプリケーションに最適なデータベースシステムとしてMongoDBを特定し、サポートSLAを提供するマネージドMongoDB環境をデプロイしたいと考えています。<br>この要件を満たすために、どうすればよいですか？' data-answer='3' data-explanation='解説<br>正解は「Google Cloud MarketplaceからMongoDB Atlasをデプロイします」です。<br>この問題では、Google Kubernetes Engine上のアプリケーションにMongoDBをデータベースシステムとして統合し、しかもそれがマネージドな環境であることが求められています。したがって、必要なMongoDBの設定、運用、または管理を行うことなく、サービスレベル契約（SLA）を提供できるマネージドサービスの適用を求める選択肢を見つけることが重要です。選択肢の中でもGoogle Cloudの環境と親和性が高く、必要なサポートを提供するものを見つけることが最善の解法です。<br>基本的な概念や原則：<br>Google Cloud Marketplace：Google Cloud上で使用できる商用アプリケーションやデータサービスを提供するマーケットプレイスです。マネージドサービスとして提供することで、運用負荷を低減します。<br>MongoDB Atlas：完全マネージドのMongoDBサービスです。Google Cloud Marketplaceから利用可能で、テキスト検索、リアルタイム可視性、自動スケーリングなど、MongoDBの全機能を提供します。<br>SLA（Service Level Agreement）：サービスプロバイダーと顧客との間で合意されたサービス品質を定める契約です。サービスの可用性やパフォーマンスなどを保証します。<br>Cloud Bigtable：Google CloudのNoSQL大規模データベースサービスです。高いスループットと低レイテンシでの読み書きが可能ですが、MongoDBとは原理が異なります。<br>Compute Engine：Google CloudのIaaS型のサービスです。仮想マシンを作成し、自由に環境構築が可能ですが、マネージド型の環境提供はされません。<br>正解についての説明：<br>（選択肢）<br>・Google Cloud MarketplaceからMongoDB Atlasをデプロイします<br>この選択肢が正解の理由は以下の通りです。<br>Google Cloudでは直接のマネージドMongoDBサービスを提供していませんが、Google Cloud Marketplaceを利用することで、第三者が提供するソリューションにアクセスすることができます。その中にはMongoDBのマネージドサービスであるMongoDB Atlasも含まれています。MongoDB Atlasは、MongoDB本体が提供するマネージドデータベースサービスなので、MongoDBに対する深い知識と高水準なSLAを提供します。<br>さらに、Google Cloudとのシームレスな統合により、Google Kubernetes Engineクラスターからも簡単にアクセスすることができます。<br>したがって、アプリケーションに最適なデータベースシステムとしてのMongoDBを採用し、SLAを提供するマネージドMongoDB環境をデプロイするためには、Google Cloud MarketplaceからMongoDB Atlasをデプロイするのが最適です。<br>不正解の選択肢についての説明：<br>選択肢：Cloud Bigtableクラスターを作成し、HBase APIを使用します<br>この選択肢が正しくない理由は以下の通りです。<br>Cloud BigtableとHBase APIを使用するという選択はMongoDBの代用になりません。Cloud BigtableはGoogleのNoSQL Big Dataデータベースであり、HBase APIはBigtableとは異なるデータモデルを提供します。<br>それに対して、正解であるMongoDB AtlasはマネージドMongoDBサービスです。<br>選択肢：MongoDBインストールパッケージをダウンロードし、Compute Engineインスタンス上で実行します<br>この選択肢が正しくない理由は以下の通りです。<br>MongoDBをCompute Engineインスタンスで直接実行すると、自分で運用と管理を行わなければなりません。これにはSLAの提供やアップデートの管理といった運用負担が生じます。対して正解のMongoDB Atlasはマネージドサービスであり、SLAの提供や運用メンテナンスがGoogle Cloud MarketPlaceから提供されるため、要件に適しています。<br>選択肢：MongoDBインストールパッケージをダウンロードし、マネージドインスタンスグループで実行します<br>この選択肢が正しくない理由は以下の通りです。<br>MongoDBをマネージドインスタンスグループで実行する方法はマネージドMongoDB環境の提供やサポートSLAの要件を満たしません。<br>一方、MongoDB AtlasはGoogle Cloud Marketplaceで提供されるマネージドサービスで、サポートSLAの要件も満たします。'>
<div class='choice'> Cloud Bigtableクラスターを作成し、HBase APIを使用します</div>
<div class='choice'> MongoDBインストールパッケージをダウンロードし、Compute Engineインスタンス上で実行します</div>
<div class='choice'> MongoDBインストールパッケージをダウンロードし、マネージドインスタンスグループで実行します</div>
<div class='choice'> Google Cloud MarketplaceからMongoDB Atlasをデプロイします</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題2<br>あなたの会社には、取引注文を管理するための社内アプリケーションがあります。このアプリケーションは、単一の物理的な場所にいる従業員のみが使用します。このアプリケーションには、強力な一貫性、高速なクエリ、および複数テーブルのトランザクション更新に対するACIDの確保が必要です。アプリケーションの最初のバージョンはPostgreSQLで実装されており、最小限のコード変更でクラウドにデプロイしたいと考えています。このアプリケーションに最も適したデータベースはどれですか？' data-answer='1' data-explanation='解説<br>正解は「Cloud SQL」です。<br>この問題では、会社の既存のアプリケーションとその要件、そしてクラウドへの移行の要件を理解することが求められています。現在のアプリケーションはPostgreSQLで実装されており、強力な一貫性、高速なクエリ、複数テーブルのトランザクション更新に対するACIDの確保が必要であるとされています。また、最小限のコード変更でクラウドにデプロイすることを望んでいます。これらの要件に基づいて、アプリケーションに最も適したデータベースを選択することが求められています。<br>基本的な概念や原則：<br>Cloud SQL：フルマネージドなリレーショナルデータベースサービスで、PostgreSQLの他にMySQLなどもサポートしています。一貫性、高速なクエリ、複数テーブルのトランザクション更新などのリレーショナルデータベースの基本機能を提供します。<br>BigQuery：Google Cloudのビッグデータ分析用のフルマネージドなエンタープライズデータウェアハウスです。大量のデータに対して高速なSQLクエリを行うことが特長です。<br>Cloud Spanner：グローバルに分散したデータベースシステムで、強力なトランザクション一貫性とスケーラビリティを兼ね備えています。主に大規模で複雑なトランザクションに対応するために利用されます。<br>Cloud Datastore：NoSQLデータベースサービスで、自動スケーリングと高可用性を提供します。主にWebアプリケーションで使用される半構造化データの管理に向いています。<br>ACID：データベーストランザクションの四大特性（原子性、一貫性、隔離性、持続性）を指し、データの信頼性を維持するために重要です。<br>正解についての説明：<br>（選択肢）<br>・Cloud SQL<br>この選択肢が正解の理由は以下の通りです。<br>まず、Cloud SQLはGoogle Cloud上でのリレーショナルデータベースの管理を簡易化するフルマネージドサービスであり、PostgreSQLを提供しています。これにより、アプリケーションの初期実装と互換性を保持しつつ、最小限のコード変更でクラウドにデプロイすることができます。<br>また、取引注文を管理するこのタイプのアプリケーションに対しては、強力な一貫性、高速なクエリ、そして複数テーブルのトランザクション更新に対するACIDの確保を必要とします。Cloud SQLはリレーショナルデータベースとしてこれらの要件を満たす能力を有しています。<br>さらに、Cloud SQLは完全にマネージドであるため、データベースのメンテナンスや管理についての手間を減らすことができ、開発者がアプリケーションの開発に集中できます。<br>したがって、このシナリオでCloud SQLが最適な選択肢です。<br>不正解の選択肢についての説明：<br>選択肢：BigQuery<br>この選択肢が正しくない理由は以下の通りです。<br>BigQueryは大量のデータを分析するためのサービスであり、一貫性、高速なクエリ、トランザクション更新に対するACIDの確保を提供する能力がありません。<br>それに対して、Cloud SQLはPostgreSQLをサポートし、必要な一貫性とACIDの確保を提供します。これにより、最小限のコード変更でクラウドへの移行が可能です。<br>選択肢：Cloud Spanner<br>この選択肢が正しくない理由は以下の通りです。<br>Cloud Spannerは分散型のリレーショナルデータベースで、グローバルなスケールでの一貫性や高可用性を提供しますが、このケースでは単一の場所での使用ですのでその強みは必要ありません。<br>また、PostgreSQLからの移行も簡単に行えるCloud SQLが適しています。<br>選択肢：Cloud Datastore<br>この選択肢が正しくない理由は以下の通りです。<br>Cloud DatastoreはNoSQLデータベースであり、単一エンティティを超えたトランザクション更新や、SQLのような高速な複数テーブルクエリをサポートしていません。その一方、Cloud SQLはACIDの確保や高速なクエリ、そして複数テーブルのトランザクション更新を提供するので、それらが求められる課題に対して最適です。'>
<div class='choice'> BigQuery</div>
<div class='choice'> Cloud SQL</div>
<div class='choice'> Cloud Datastore</div>
<div class='choice'> Cloud Spanner</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題3<br>App Engine環境でホストされているアプリケーションの新バージョンを構築しています。アプリケーションを完全に新バージョンに切り替える前に、1% のユーザーで新バージョンをテストしたいと考えています。<br>あなたはこの要件を満たすために、どうすればよいですか？' data-answer='2' data-explanation='解説<br>正解は「App Engineに新しいバージョンのアプリケーションをデプロイします。その後、Google Cloud ConsoleのApp Engineの設定で、現在のバージョンと新しくデプロイしたバージョンの間でトラフィックを適宜分割します」です。<br>この問題では、Google Cloud上のApp Engine上でホストされているアプリケーションの新バージョンをどのようにして一部のユーザーにテストさせるかということが求められています。ここで重要なのは、新バージョンを全ユーザーに展開する前の検証を行う必要があるため、新旧のバージョンを同時に運用し、その一部のトラフィックを新しいバージョンにルーティングすることです。この点を念頭に置いて選択肢を評価することが求められます。また問題の選択肢は、App Engine上にデプロイするか、他のサービス上にデプロイするかという点で異なるので、それぞれの特性を理解して選択肢を評価します。<br>基本的な概念や原則：<br>App Engine：Google Cloudのフルマネージド、サーバレスプラットフォームで、アプリケーションの開発、ホスト、スケーリングに使用します。使用料金は実際に使用したリソースに対してのみ発生します。<br>新しいバージョンのデプロイ：アプリケーションの新しい機能や修正を適用するために行う作業です。新しいバージョンを本番環境にデプロイする前に、テスト環境で機能を検証することが一般的です。<br>トラフィックの分割：ユーザーのリクエストを複数のバージョンのアプリケーションに分配するプロセスです。これにより、新しいバージョンのアプリケーションのパフォーマンスをテストしたり、変更の影響を評価したりすることができます。<br>Google Cloud Console：Google Cloudのリソースやサービスを管理するためのウェブベースのインターフェースです。各種設定や監視、トラフィックの分割などを行うことができます。<br>Google Kubernetes Engine：Google CloudのマネージドKubernetesサービスです。コンテナ化されたアプリケーションのデプロイに使用しますが、本問題の要件を満たすためには不適切です。<br>Compute Engine：Google Cloudの仮想マシンを提供するサービスです。柔軟な仮想マシンの設定と自動スケーリングが可能ですが、本問題の要件を満たすためには不適切です。<br>正解についての説明：<br>（選択肢）<br>・App Engineに新しいバージョンのアプリケーションをデプロイします。その後、Google Cloud ConsoleのApp Engineの設定で、現在のバージョンと新しくデプロイしたバージョンの間でトラフィックを適宜分割します<br>この選択肢が正解の理由は以下の通りです。<br>Google CloudのApp Engineは複数のバージョンのアプリケーションをホストする能力があるため、新しいバージョンと既存のバージョンを同時に稼働させることができます。<br>さらに、App Engineはトラフィック分割機能を提供しているため、ユーザーの一部だけに新バージョンを表示するといった要件に適しています。具体的には、Google Cloud ConsoleのApp Engine設定を使って、新旧のバージョン間でトラフィックの割合を調節できます。そこで1%のユーザーだけに新バージョンを適用する設定を行うことによって問題の要件を満たすことができます。それにより、新バージョンの動作を少数のユーザーでテストすることができます。問題なく動作した場合、トラフィックの割合を増やしていき、全ユーザーに新バージョンを適用していくことができます。<br>不正解の選択肢についての説明：<br>選択肢：アプリケーションの新バージョンをApp EngineではなくGoogle Kubernetes Engineにデプロイし、Google Cloud Consoleを使ってトラフィックを分割します<br>この選択肢が正しくない理由は以下の通りです。<br>要件はApp Engineでアプリケーションの新バージョンをテストすることですが、この選択肢はGoogle Kubernetes Engineを利用しています。<br>また、Google Kubernetes EngineとApp Engineではトラフィックの分割管理方法が異なるため、この解答では要件を正確に満たしません。<br>選択肢：アプリケーションの新しいバージョンをApp EngineではなくCompute Engineインスタンスにデプロイし、Google Cloud Consoleを使用してトラフィックを分割します<br>この選択肢が正しくない理由は以下の通りです。<br>まず、Compute EngineとApp Engineは異なるプロダクトであり、アプリケーションの新しいバージョンをCompute Engineにデプロイした場合、App Engine環境とは異なる環境になり、テスト結果が変わる可能性があります。<br>また、Compute Engineではトラフィックの分割に対応していませんから、トラフィックを1%のユーザだけに向けるという要件を満たすことができません。<br>選択肢：App Engineに新しいバージョンを別のアプリとしてデプロイします。その後、Google Cloud Consoleを使用してApp Engineを設定し、2つのアプリ間でトラフィックを分割します<br>この選択肢が正しくない理由は以下の通りです。<br>App Engineでは、既存のアプリを新バージョンに切り替える際に同一のアプリ内で複数のバージョンを持つことが可能であり、それぞれにトラフィックを分割することができます。ですから、新しいバージョンを別のアプリとしてデプロイする必要はありません。'>
<div class='choice'> アプリケーションの新しいバージョンをApp EngineではなくCompute Engineインスタンスにデプロイし、Google Cloud Consoleを使用してトラフィックを分割します</div>
<div class='choice'> アプリケーションの新バージョンをApp EngineではなくGoogle Kubernetes Engineにデプロイし、Google Cloud Consoleを使ってトラフィックを分割します</div>
<div class='choice'> App Engineに新しいバージョンのアプリケーションをデプロイします。その後、Google Cloud ConsoleのApp Engineの設定で、現在のバージョンと新しくデプロイしたバージョンの間でトラフィックを適宜分割します</div>
<div class='choice'> App Engineに新しいバージョンを別のアプリとしてデプロイします。その後、Google Cloud Consoleを使用してApp Engineを設定し、2つのアプリ間でトラフィックを分割します</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題4<br>Cloud Pub/Subトピックからのメッセージを処理するアプリケーションをCloud Run上にデプロイしたいと考えています。あなたは、Googleが推奨するプラクティスに従う必要があります。<br>あなたはこの要件を満たすために、どうすればよいですか？' data-answer='2' data-explanation='解説<br>正解は「1.サービスアカウントを作成します<br>2.そのサービスアカウントにCloud Runアプリケーション用のCloud Run Invokerロールを与えます<br>3.そのサービスアカウントを使用し、Cloud Runアプリケーションをプッシュエンドポイントとして使用するCloud Pub/Subサブスクリプションを作成します」です。<br>この問題では、Cloud Run上で動作するアプリケーションがCloud Pub/Subからのメッセージを適切に処理する方法について問われています。Googleの推奨パターンに基づいて適切な選択を行うことが求められています。そのため、Google Cloudのサービスの正しい使い方を理解していることが解答には必要です。具体的には、Cloud Run, Cloud Pub/Sub, サービスアカウント, ロール, サブスクリプションを含むアプリケーションとインフラストラクチャの構造について知っていることが重要です。<br>基本的な概念や原則：<br>Cloud Pub/Sub：Google Cloudのサービスで、アプリケーション間でメッセージを非同期に配信することができ、既存サービスとの連携も強化します。<br>Cloud Run：コンテナを動作させるフルマネージドのサービスです。サーバレス実行環境で、高性能なスケーリングを実現します。<br>サービスアカウント：アプリケーション専用の名前付きアカウントで、Google Cloudサービスの認証と認可を担当します。特定のGoogle Cloudリソースへのアクセス制御を提供します。<br>Cloud Run Invokerロール：Cloud Runのリソースに対するアクセス権を調整するロールです。特定のサービスの呼び出しを制御する能力を提供します。<br>Pub/Sub Subscriberロール： Cloud Pub/Subのリソースに対するアクセス権を調整するロールです。メッセージの購読と取得を容易にします。<br>GKE（Google Kubernetes Engine）：Google CloudのマネージドKubernetesサービスで、コンテナ化されたアプリケーションを柔軟にスケールし、運用することができます。<br>Cloud Functions：Google Cloudのサーバレス実行環境で、特定のイベントに対する応答として単一の関数を動作させる機能を提供します。<br>正解についての説明：<br>（選択肢）<br>・1.サービスアカウントを作成します<br>2.そのサービスアカウントにCloud Runアプリケーション用のCloud Run Invokerロールを与えます<br>3.そのサービスアカウントを使用し、Cloud Runアプリケーションをプッシュエンドポイントとして使用するCloud Pub/Subサブスクリプションを作成します<br>この選択肢が正解の理由は以下の通りです。<br>まず、サービスアカウントを使用することで、具体的なインスタンスやユーザーに紐づかない形でアクセス制限を設定できます。これにより、Cloud RunアプリケーションがPub/Subからのメッセージを適切に処理するための専用アクセス権を提供できます。<br>次に、作成したサービスアカウントにCloud Run Invokerロールを与えることで、そのアカウントからCloud Runサービスを呼び出すことが可能になります。これにより、Pub/Subからのメッセージ取得がCloud Run上のアプリケーションによって行われることができます。<br>最後に、そのサービスアカウントを使用してCloud Pub/Subサブスクリプションを作成し、Cloud Runアプリケーションをプッシュエンドポイントとして設定することで、Pub/Subからのメッセージは直接Cloud Runにプッシュされ、アプリケーションがそれを処理することができます。<br>この手順は、Googleが推奨するプラクティスに従ってCloud Pub/SubとCloud Runを統合する為の最善の標準的な手順となっています。<br>不正解の選択肢についての説明：<br>選択肢：1.そのトピックのCloud Pub/Subトリガーを使用するCloud Functionsを実装します<br>2.メッセージごとにCloud FunctionからCloud Run上のアプリケーションを呼び出します<br>この選択肢が正しくない理由は以下の通りです。<br>Cloud Functionを使用してCloud Runアプリケーションを呼び出すことは可能ですが、Googleの推奨するプラクティスとは異なります。これは、二重の管理とコストが発生し、効率性が低下する恐れがあります。直接Cloud Runアプリケーションにプッシュし、必要な認証と自治を保証するためにサービスアカウントを使用する方が効率的です。<br>選択肢：1.Cloud Runで使用するサービスアカウントにPub/Sub Subscriberロールを付与します<br>2.そのトピックのCloud Pub/Subサブスクリプションを作成します<br>3.アプリケーションにそのサブスクリプションからメッセージをプルさせます<br>この選択肢が正しくない理由は以下の通りです。<br>Cloud Runはデータのプッシュドリブンモデルを用い、Pub/Subからメッセージをプルする設定は推奨されていません。推奨される流れはPub/Subが持つデータをCloud Runにプッシュすることであり、それにはInvokerロールが必要です。<br>選択肢：1.接続をInternalに設定し、GKE上のCloud Runにアプリケーションをデプロイします<br>2.そのトピックのCloud Pub/Subサブスクリプションを作成します<br>3.アプリケーションと同じGoogle Kubernetes Engineクラスターに、メッセージを受け取ってアプリケーションに送信するコンテナをデプロイします<br>この選択肢が正しくない理由は以下の通りです。<br>Googleが推奨するプラクティスは、サービスアカウントを使用することです。<br>しかし、この選択肢はGKE上のCloud Runにアプリケーションをデプロイし、別のコンテナでメッセージを受け取る方法を提案しています。これは複雑さを増してしまい、独自の解決策でありGoogleの推奨するプラクティスには該当しません。'>
<div class='choice'><br>1.Cloud Runで使用するサービスアカウントにPub/Sub Subscriberロールを付与します<br>2.そのトピックのCloud Pub/Subサブスクリプションを作成します<br>3.アプリケーションにそのサブスクリプションからメッセージをプルさせます</div>
<div class='choice'><br>1.接続をInternalに設定し、GKE上のCloud Runにアプリケーションをデプロイします<br>2.そのトピックのCloud Pub/Subサブスクリプションを作成します<br>3.アプリケーションと同じGoogle Kubernetes Engineクラスターに、メッセージを受け取ってアプリケーションに送信するコンテナをデプロイします</div>
<div class='choice'><br>1.サービスアカウントを作成します<br>2.そのサービスアカウントにCloud Runアプリケーション用のCloud Run Invokerロールを与えます<br>3.そのサービスアカウントを使用し、Cloud Runアプリケーションをプッシュエンドポイントとして使用するCloud Pub/Subサブスクリプションを作成します</div>
<div class='choice'><br>1.そのトピックのCloud Pub/Subトリガーを使用するCloud Functionsを実装します<br>2.メッセージごとにCloud FunctionからCloud Run上のアプリケーションを呼び出します</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題5<br>Google Cloudに新しいERPシステムをデプロイしようとしています。このアプリケーションは、高速なデータアクセスのために完全なデータベースをインメモリで保持しており、Google Cloud上でこのアプリケーションに最適なリソースを構成する必要があります。<br>この要件を満たすために、どうすればよいですか？' data-answer='1' data-explanation='解説<br>正解は「M1マシンタイプのCompute Engineインスタンスをプロビジョニングします」です。<br>この問題では、新たなERPシステムの特性を理解し、それに最適なリソース選択肢をGoogle Cloudで探すことが求められています。重要な情報は、ERPシステムが高速なデータアクセスのために全データベースをインメモリで保持するということです。インメモリのデータベースが必要な場合は、大量のRAMを備えたリソースの提供が必要であることに注意して選択肢を評価してください。<br>基本的な概念や原則：<br>M1マシンタイプ：Google CloudのCompute Engineで利用できるマシンタイプの一つで、高いメモリ容量を提供します。インメモリデータベースなど、大量のメモリを必要とするアプリケーションに最適です。<br>インメモリデータベース：データを主記憶装置（RAM）に保存し、高速なデータアクセスを提供するデータベースシステムです。<br>プリエンプティブルインスタンス：Google CloudのCompute Engineで利用できる低コストのインスタンスタイプですが、リソースが必要な場合にはいつでも割り込まれる可能性があります。負荷が一定で、即時性や可用性が要求されるワークロードには適していません。<br>GPU付きCompute Engineインスタンス：特にグラフィックス処理や機械学習など、GPUの計算能力を必要とするワークロードに利用します。一般的なERPシステムでは必要ありません。<br>ローカルSSD付きCompute Engineインスタンス：一時的なスクラッチスペースとして使用され、永続ディスクと比べて高速なI/O性能を提供しますが、故障時のデータ保護など、永続性を要求するワークロードには適していません。<br>正解についての説明：<br>（選択肢）<br>・M1マシンタイプのCompute Engineインスタンスをプロビジョニングします<br>この選択肢が正解の理由は以下の通りです。<br>まず、M1マシンタイプのCompute Engineインスタンスは、メモリ最適化インスタンスとされており、大量のメモリを必要とする高性能なアプリケーションに適しています。このタイプのマシンは高密度なメモリと高パフォーマンスなCPUを提供し、その特性が大規模なインメモリデータベースに最適です。<br>したがって、要件で指定されているような高速なデータアクセスを必要とするERPシステムをGoogle Cloud上で稼働させるのに最適な選択です。<br>したがって、完全なデータベースをインメモリで保持する新しいERPシステムのGoogle Cloudデプロイの要件を満たすためには、M1マシンタイプのCompute Engineインスタンスをプロビジョニングするべきであるといえます。<br>不正解の選択肢についての説明：<br>選択肢：プリエンプティブルCompute Engineインスタンスを提供します<br>この選択肢が正しくない理由は以下の通りです。<br>プリエンプティブルCompute Engineインスタンスは最大で24時間しか保証されず、またいつでも停止される可能性があります。これは、インメモリデータベースをもつERPシステムには不適切で、随時アクセスが必要なためリソースの継続的な可用性が必要です。<br>これに対して、M1マシンタイプは高メモリを提供し、安定して稼働し続けるため正解とされます。<br>選択肢：GPUが接続されたCompute Engineインスタンスをプロビジョニングします<br>この選択肢が正しくない理由は以下の通りです。<br>GPUが接続されたCompute Engineインスタンスは、画像処理や機械学習といったGPUを使用する特定のワークロードに有用ですが、本問題のシナリオでは完全なデータベースをインメモリで保持するERPシステムが求められています。したがってGPUは不要であり、大量のメモリを提供するM1タイプのインスタンスが適切です。<br>選択肢：ローカルSSDが接続されたCompute Engineインスタンスをプロビジョニングします<br>この選択肢が正しくない理由は以下の通りです。<br>ローカルSSDが接続されたCompute Engineインスタンスは、データをSSDに格納するための設定ですが、問題文ではデータベースをインメモリで保持するニーズが強調されています。このため、より大きなメモリを提供するM1マシンタイプのCompute Engineインスタンスが最適です。'>
<div class='choice'> ローカルSSDが接続されたCompute Engineインスタンスをプロビジョニングします</div>
<div class='choice'> M1マシンタイプのCompute Engineインスタンスをプロビジョニングします</div>
<div class='choice'> GPUが接続されたCompute Engineインスタンスをプロビジョニングします</div>
<div class='choice'> プリエンプティブルCompute Engineインスタンスを提供します</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題6<br>コンテナイメージにパッケージされたアプリケーションを、新しいプロジェクトにデプロイする必要があります。このアプリケーションはHTTPエンドポイントを公開し、1日に受け取るリクエストはごくわずかです。あなたは、コストを最小限に抑えたいと考えています。<br>この要件を満たすために、どうすればよいですか？' data-answer='1' data-explanation='解説<br>正解は「コンテナをCloud Runにデプロイします」です。<br>この問題では、アプリケーションデプロイに関する特定の要件に基づいて最適なデプロイメント環境を選択することが求められています。問題文からはアプリケーションがコンテナ化されており、リクエスト量が少なく、コストを最小限に抑えたいことがわかります。したがって、それぞれの選択肢を評価する際には、これらの要件に最も適した環境を選ぶことを考えることが必要です。<br>基本的な概念や原則：<br>Cloud Run：リクエストがあるときだけ実行されるフルマネージドのサーバレスプラットフォームです。アイドル時の料金が発生しないため、コストを最小限に抑えることができます。<br>GKEのCloud Run：GKE（Google Kubernetes Engine）上で動作するサーバレスプラットフォームです。リソースの管理とコントロールが必要な場合に利用しますが、Cloud Runに比べるとコストが高くなる可能性があります。<br>App Engineフレキシブル環境：アプリケーションを容易にデプロイできるPaaSです。スケーリングが自動で行われますが、ランダウンタイムの間もインスタンスは稼働し続けるため、コストが発生します。<br>GKE：コンテナ化したアプリケーションを実行するためのKubernetes環境です。クラスターの自動スケーリングと水平ポッドの自動スケーリングが可能ですが、リソースが不要な時でもコストが掛かる場合があります。<br>正解についての説明：<br>（選択肢）<br>・コンテナをCloud Runにデプロイします<br>この選択肢が正解の理由は以下の通りです。<br>Cloud RunはGoogle Cloudのフルマネージド型サービスで、ステートレスコンテナをスケールアウトさせることができます。つまり、リクエストがあるときだけコンテナが起動し、レスポンス後には自動的にコンテナが終了します。これによりリソースの消費が最小化され、コストの削減につながります。具体的な使用料は実際の利用分だけになるので、リクエストが少ない時にはコストを非常に低く抑えることができます。<br>また、Cloud Runはコンテナイメージからのデプロイをサポートしているため、場合の要件に最適です。だからこそ、コンテナをCloud Runにデプロイするのが最適であり、この選択肢は正解です。<br>不正解の選択肢についての説明：<br>選択肢：GKEのCloud Runにコンテナをデプロイします<br>この選択肢が正しくない理由は以下の通りです。<br>GKEのCloud Runでは、リソースを持つ常設のKubernetesクラスターが必要で、わずかなリクエストに対して余計なコストがかかる可能性があります。<br>それに対して、Cloud Runは使った分だけの課金となりコストを最小限に抑えることができます。<br>選択肢：App Engineフレキシブル環境にコンテナをデプロイします<br>この選択肢が正しくない理由は以下の通りです。<br>App Engineフレキシブル環境は、ユーザーが少ない時間でもインスタンスが常に稼働しているため、リクエストが少ない場合でもコストがかかります。<br>しかし、Cloud Runはリクエストのあるときだけコストが発生し、リクエストがないときはコストが発生しないためコストを最小限に抑えることができます。<br>選択肢：クラスターの自動スケーリングと水平ポッドの自動スケーリングを有効にして、GKEにコンテナをデプロイします<br>この選択肢が正しくない理由は以下の通りです。<br>GKEを使用すると、コンテナの管理に関する柔軟性が増しますが、クラスター自身のインフラコストが発生します。<br>一方、Cloud Runは使用量課金モデルで、リクエストが少ない場合はコストを大幅に節約できます。<br>したがって、コストを最小限にしたい場合にはCloud Runが適しています。'>
<div class='choice'> クラスターの自動スケーリングと水平ポッドの自動スケーリングを有効にして、GKEにコンテナをデプロイします</div>
<div class='choice'> コンテナをCloud Runにデプロイします</div>
<div class='choice'> GKEのCloud Runにコンテナをデプロイします</div>
<div class='choice'> App Engineフレキシブル環境にコンテナをデプロイします</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題7<br>マネージドインスタンスグループとしてデプロイされたウェブアプリケーションがあります。新しいバージョンのアプリケーションを徐々にデプロイする必要があります。Webアプリケーションは現在、ライブのWebトラフィックを受け付けています。したがって、デプロイ中に利用可能な容量が減少しないようにしたいと考えています。<br>あなたはこの要件を満たすために、どうすればよいですか？' data-answer='3' data-explanation='解説<br>正解は「maxSurgeを1、maxUnavailableを0に設定し、ローリングアクションによるスタートアップを行います」です。<br>この問題では、マネージドインスタンスグループを使用したウェブアプリケーションのデプロイメントで、新しいバージョンを徐々に導入する方法を求められています。重要な要件として、デプロイ中にも利用可能な容量を維持することが求められているため、更新中でもサービスが停止しないような方式を選ぶことが必要です。また、徐々に新しいバージョンを導入するという要件から、一度に全インスタンスを更新せず、段階的に新しいバージョンへの移行を行う方法を選ぶべきです。そのため、設定値やアップデート方法について適切に理解しておくことが重要です。<br>基本的な概念や原則：<br>マネージドインスタンスグループ：Google Cloudでは、同じインスタンステンプレートから作成され、同じインスタンス設定を共有するインスタンス群のことを指します。これにより、ロードバランシング、自動スケーリング、自動修復などの機能が利用できます。<br>ローリングアップデート：新しいバージョンのアプリケーションを段階的にデプロイするプロセスです。<br>maxSurgeとmaxUnavailable：ローリングアップデート間の容量管理を可能にするパラメータです。maxSurgeは新規インスタンスの追加上限を、maxUnavailableは削除可能なインスタンス上限を指定します。<br>ロードバランシング：インバウンドネットワークトラフィックをバックエンドの複数のインスタンスに分散させるプロセスです。これにより、高い可用性と信頼性を実現します。<br>インスタンステンプレート：Compute Engineインスタンスの設定情報をプリセットとして保存する機能です。これを使うと、同じ設定を持つインスタンスを簡単に作成できます。<br>正解についての説明：<br>（選択肢）<br>・maxSurgeを1、maxUnavailableを0に設定し、ローリングアクションによるスタートアップを行います<br>この選択肢が正解の理由は以下の通りです。<br>まず、ローリングアクションはマネージドインスタンスグループの更新を可能にし、更新の影響を制御するためにmaxSurgeとmaxUnavailableという二つのパラメータが利用可能です。maxSurgeは新しいインスタンスを追加できる上限を設定します。ここでは&#39;maxSurge&#39;を1に設定することで、既存のインスタンスに影響を与えずに新しいバージョンのアプリケーションを1つだけ追加できます。<br>一方、maxUnavailableは適用中のアップデートで使えなくなるインスタンスの最大数を指定します。ここでは&#39;maxUnavailable&#39;を0に設定しているので、デプロイ中に利用可能な容量が減少することはありません。これにより、徐々にデプロイを行いつつ同時に、既存のWebトラフィックに対するサービスのダウンタイムを防ぐことができます。<br>不正解の選択肢についての説明：<br>選択肢：maxSurgeを0に、maxUnavailableを1に設定し、ローリングアクションによるスタートアップを行います<br>この選択肢が正しくない理由は以下の通りです。<br>maxSurgeを0に設定すると、デプロイ中に新たなインスタンスを追加できず、更新中のインスタンスがトラフィックを処理できない期間があるためです。<br>また、maxUnavailableを1にすると、更新中に1つのインスタンスが利用不可能になる可能性があり、これは容量の減少を引き起こす可能性があります。<br>選択肢：更新されたインスタンステンプレートで新しいマネージドインスタンスグループを作成します。ロードバランサのバックエンドサービスにグループを追加します。新しいマネージドインスタンスグループのすべてのインスタンスがヘルシーになったら、古いマネージドインスタンスグループを削除します<br>この選択肢が正しくない理由は以下の通りです。<br>新しいマネージドインスタンスグループを作成すると新旧ソフトウェア間でのトラフィック振り分けが難しくなります。<br>さらに、新しいマネージドインスタンスグループが全てヘルシーになるまで古いグループを削除できないため、一時的にリソース使用量が2倍になります。これはコスト増加や容量オーバーヘッドを招く可能性があります。対して正解のローリングアクションは、新旧ソフトウェアのバージョン切り替わりをスムーズに遂行しつつ、効率的なリソース使用を保証します。<br>選択肢：新しいアプリケーションバージョンで新しいインスタンステンプレートを作成します。既存の管理対象インスタンスグループを新しいインスタンステンプレートで更新します。マネージドインスタンスグループ内のインスタンスを削除して、マネージドインスタンスグループが新しいインスタンステンプレートを使用してインスタンスを再作成できるようにします<br>この選択肢が正しくない理由は以下の通りです。<br>既存のインスタンスを削除して新しいインスタンステンプレートを適用すると、デプロイ中に利用可能な容量が一時的に減少します。これは設問の要件、すなわち"デプロイ中に利用可能な容量が減少しないようにしたい"に反します。正解選択肢のローリングアップデートでは、新旧バージョンの平行運用が可能なため、前述の問題を回避できます。'>
<div class='choice'> 新しいアプリケーションバージョンで新しいインスタンステンプレートを作成します。既存の管理対象インスタンスグループを新しいインスタンステンプレートで更新します。マネージドインスタンスグループ内のインスタンスを削除して、マネージドインスタンスグループが新しいインスタンステンプレートを使用してインスタンスを再作成できるようにします</div>
<div class='choice'> 更新されたインスタンステンプレートで新しいマネージドインスタンスグループを作成します。ロードバランサのバックエンドサービスにグループを追加します。新しいマネージドインスタンスグループのすべてのインスタンスがヘルシーになったら、古いマネージドインスタンスグループを削除します</div>
<div class='choice'> maxSurgeを0に、maxUnavailableを1に設定し、ローリングアクションによるスタートアップを行います</div>
<div class='choice'> maxSurgeを1、maxUnavailableを0に設定し、ローリングアクションによるスタートアップを行います</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題8<br>管理インスタンスグループのCompute Engine VMにアプリケーションをデプロイしています。アプリケーションは常に実行されている必要がありますが、Google Cloudプロジェクトごとに実行されるVMのインスタンスは1つだけです。どのようにインスタンスグループを構成する必要がありますか？' data-answer='2' data-explanation='解説<br>正解は「autoscalingをオンに設定し、インスタンスの最小数を1に設定し、インスタンスの最大数を1に設定します」です。<br>この問題では、アプリケーションが常に稼働し、そのためには各プロジェクトで1つのVMインスタンスが稼働する設定が必要であることを理解することが要求されます。そのため選択肢を見るときには、それぞれの選択肢がこれらの基準を満たすかどうかに注意します。オートスケーリングの有効化や無効化、最小インスタンス数、そして最大インスタンス数の設定について理解することで適切な構成を選ぶことが可能になります。<br>基本的な概念や原則：<br>管理インスタンスグループ：Compute Engine上で複数のVMインスタンスを一括で管理するための機能です。一括操作、オートスケーリング、ロードバランシングなどの機能を提供しています。<br>Compute Engine：Google Cloudの仮想マシンを提供するサービスです。柔軟な仮想マシンの設定と自動スケーリングが可能です。<br>オートスケーリング：インスタンスグループのインスタンス数を自動的に調整する機能です。負荷や利用状況に応じてワークロードをスケールアップまたはダウンします。<br>最小インスタンス数：オートスケーリング設定の一部で、常に維持されるべきインスタンスの最小数を設定します。<br>最大インスタンス数：オートスケーリング設定の一部で、スケーリングによって作成できるインスタンスの最大数を設定します。<br>正解についての説明：<br>（選択肢）<br>・autoscalingをオンに設定し、インスタンスの最小数を1に設定し、インスタンスの最大数を1に設定します<br>この選択肢が正解の理由は以下の通りです。<br>管理インスタンスグループのCompute Engine VMにアプリケーションをデプロイする際、プロジェクトごとに一つのインスタンスのみ有効にするという制約があるため、オートスケーリングの設定は最小でも最大でも1に設定することが最適です。<br>オートスケーリングがオンに設定されていると、負荷に応じてデプロイされるインスタンス数が自動的に調整されます。<br>しかし、この設問のケースでは、プロジェクトごとに実行できるVMのインスタンスは1つだけであることから、最小と最大の両方の値を1に設定することで、インスタンス数が確実に1つに保たれます。<br>また、アプリケーションは常に稼働していなければならないとの要件があるため、インスタンスがゼロにならないよう、最小値もオートスケーリングで1に設定しておきます。これにより、アプリケーションの稼働が保証されます。<br>不正解の選択肢についての説明：<br>選択肢：オートスケーリングをオフに設定し、インスタンスの最小数を1に設定し、インスタンスの最大数を1に設定します<br>この選択肢が正しくない理由は以下の通りです。<br>オートスケーリングをオフに設定すると、VMインスタンスが何らかの理由で停止した場合、自動的に新しいインスタンスが生成されません。<br>しかし、アプリケーションは常に実行されている必要があるので、停止したインスタンスを自動的に置き換えるためにはオートスケーリングが必要です。<br>選択肢：autoscalingをオンに設定し、最小インスタンス数を1に設定し、最大インスタンス数を2に設定します<br>この選択肢が正しくない理由は以下の通りです。<br>最大インスタンス数を2に設定すると、予期せぬ状況で2つのインスタンスが起動してしまう可能性があり、1つのプロジェクトで必要なインスタンスは1つだけの要件を満たしません。対して正解は、最小と最大のインスタンス数を共に1に設定することで、常に1つだけのインスタンスが実行されることを保証しています。<br>選択肢：オートスケーリングをオフに設定し、最小インスタンス数を1に設定し、最大インスタンス数を2に設定します<br>この選択肢が正しくない理由は以下の通りです。<br>オートスケーリングがオフの状態では、VMインスタンスが停止した場合に自動的に別のインスタンスが立ち上がらず、アプリケーションが常に稼働する要件を満たすことができません。<br>対して正解選択肢では、オートスケーリングがオンとなっており、万一の事態に備えて新たなインスタンスが自動で立ち上がるよう設定されています。'>
<div class='choice'> オートスケーリングをオフに設定し、最小インスタンス数を1に設定し、最大インスタンス数を2に設定します</div>
<div class='choice'> オートスケーリングをオフに設定し、インスタンスの最小数を1に設定し、インスタンスの最大数を1に設定します</div>
<div class='choice'> autoscalingをオンに設定し、インスタンスの最小数を1に設定し、インスタンスの最大数を1に設定します</div>
<div class='choice'> autoscalingをオンに設定し、最小インスタンス数を1に設定し、最大インスタンス数を2に設定します</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題9<br>Google Cloud上で実行したい単一のバイナリアプリケーションがあります。基礎となるインフラストラクチャのCPU使用率に基づいてアプリケーションを自動的にスケールすることにしました。組織のポリシーでは、仮想マシンを直接使用する必要があります。アプリケーションのスケーリングが運用上効率的で、できるだけ早く完了するようにする必要があります。<br>あなたはこの要件を満たすために、どうすればよいですか？' data-answer='1' data-explanation='解説<br>正解は「インスタンステンプレートを作成し、オートスケールが設定されたマネージドインスタンスグループでテンプレートを使用します」です。<br>この問題では、Google Cloud上でバイナリアプリケーションを実行し、CPU使用率に連動して自動でスケールできるような構成を考える必要があります。仮想マシンを直接使用する必要があり、スケーリングは速やかに行われるべきです。どのGoogle Cloudのサービスを使用すべきかを問う問題となっていますが、この場合はバイナリアプリケーションに対する操作と、インフラストラクチャのCPU使用率に応じた自動のスケーリング機能の二点に注目すべきです。<br>基本的な概念や原則：<br>インスタンステンプレート：Google Cloudの仮想マシンの設定を保存するためのリソースです。テンプレートはインスタンスグループに対して適用可能で、スケーリングやアップデートに役立ちます。<br>マネージドインスタンスグループ：Google Cloudの機能で、仮想マシンのグループを自動的にスケールアップまたはスケールダウンすることができます。また、グループ内の仮想マシンに障害が発生した場合に自動修復も可能です。<br>オートスケーリング：負荷に応じて自動的にインスタンス数を増減させる機能です。CPU使用率などのメトリクスを基にスケーリングが行われます。<br>Google Kubernetes Engine：Google Cloud上でのKubernetes環境を提供するサービスです。水平ポッドオートスケーリングなどの機能も提供しますが、仮想マシンを直接使用する必要がある場合には適合しません。<br>Cloud Monitoring：Google Cloudの監視サービスです。CPU使用率などのメトリクスを収集・表示し、アラートを設定することができます。しかし、自動スケーリングにはアプリケーション側の対応が必要となるため、効率的なスケーリングを追求する上では適していません。<br>正解についての説明：<br>（選択肢）<br>・インスタンステンプレートを作成し、オートスケールが設定されたマネージドインスタンスグループでテンプレートを使用します<br>この選択肢が正解の理由は以下の通りです。<br>まず、インスタンステンプレートを作成することで、これを基にVMインスタンスを生成する仕組みを確立することができます。テンプレートを使うことで、一貫性と再利用性を確保し、また運用の手間を省くことができます。<br>次に、マネージドインスタンスグループ（MIGs）は、一連の同一のVMインスタンスを自動的にスケールし管理する仕組みを提供してくれます。MIGsを使うと、インフラのヘルスチェックや自動修復、ディストリビューション等を管理してくれるため、運用負荷を軽減できます。<br>さらに、MIGsのオートスケーリング機能は、設定したメトリクス（ここではCPU使用率）に基づいてインスタンスの数を自動的に増減し、リソース使用率を最適化します。これにより、アプリケーションのスケーリングが運用上効率的で高速に行われることを確実にします。<br>以上の理由から、インスタンステンプレートを作成し、オートスケールが設定されたマネージドインスタンスグループでテンプレートを使用するのが最適な策です。<br>不正解の選択肢についての説明：<br>選択肢：Google Kubernetes Engineクラスターを作成し、水平ポッドオートスケーリングを使ってアプリケーションをスケールします<br>この選択肢が正しくない理由は以下の通りです。<br>問題の要件は仮想マシンを直接使用する必要があり、と指定されており、Google Kubernetes Engineはその基盤上でコンテナを実行するサービスであるため、仮想マシンを直接使うという基準を満たしません。そのため、マネージドインスタンスグループを使う選択肢が適しています。<br>選択肢：インスタンステンプレートを作成し、時間帯に応じてスケールアップ/ダウンするマネージドインスタンスグループでテンプレートを使用します<br>この選択肢が正しくない理由は以下の通りです。<br>時間帯に基づくスケーリングではCPU使用率に対する反応が遅く、要件で求められている"基礎となるインフラストラクチャのCPU使用率に基づいてアプリケーションを自動的にスケールする"という条件を満たすことができません。正解のオートスケールはこの要件に適しています。<br>選択肢：Cloud MonitoringのCPU使用率モニタリングに基づいて、アプリケーションのスケールアップとスケールダウンの自動化を構築するために、一連のサードパーティーツールを使用します<br>この選択肢が正しくない理由は以下の通りです。<br>Google Cloudのマネージドインスタンスグループ（MIG）自体がインフラのスケーリング機能を提供しているため、サードパーティーツールを使用して自動化を構築する必要はありません。<br>また、サードパーティーツールを使用すると、開発とメンテナンスに追加の時間と労力がかかる可能性があります。<br>したがって、正解の選択肢のようにMIGを用いたオートスケールを用いるほうが効率的です。'>
<div class='choice'> インスタンステンプレートを作成し、時間帯に応じてスケールアップ/ダウンするマネージドインスタンスグループでテンプレートを使用します</div>
<div class='choice'> インスタンステンプレートを作成し、オートスケールが設定されたマネージドインスタンスグループでテンプレートを使用します</div>
<div class='choice'> Google Kubernetes Engineクラスターを作成し、水平ポッドオートスケーリングを使ってアプリケーションをスケールします</div>
<div class='choice'> Cloud MonitoringのCPU使用率モニタリングに基づいて、アプリケーションのスケールアップとスケールダウンの自動化を構築するために、一連のサードパーティーツールを使用します</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題10<br>あなたはKubernetes Engineクラスターで複数のマイクロサービスを実行しています。あるマイクロサービスは画像をレンダリングしています。画像のレンダリングを担当するマイクロサービスは、必要なメモリに比べて大量のCPU時間を必要とします。他のマイクロサービスは、n2標準のマシンタイプに最適化されたワークロードです。すべてのワークロードが可能な限り効率的にリソースを使用できるように、クラスターを最適化する必要があります。<br>この要件を満たすために、どうすればよいですか？' data-answer='1' data-explanation='解説<br>正解は「画像レンダリングマイクロサービス用に、コンピューティングに最適化されたマシンタイプのノードでノードプールを作成します。他のマイクロサービスには、汎用マシン型ノードのノードプールを使用します」です。<br>この問題では、Kubernetes Engineクラスターリソースの最適化が求められており、特にCPUリソースが重要な画像レンダリングマイクロサービスと、他のマイクロサービスを考慮に入れる必要があります。目標は、各マイクロサービスが効率的にリソースを使用できるようにすることです。そのため、問題のポイントは、個々のマイクロサービスのニーズに応じてリソースを効果的に割り当て、必要なものを必要な時に提供できるようにすることです。この観点から適切なノードプール戦略を選択し、またそれをどのように各マイクロサービスに適用するかが重要です。<br>基本的な概念や原則：<br>Kubernetes Engine：Google Cloudのコンテナ化されたアプリケーションをオーケストレートするためのマネージドサービスです。Kubernetes環境のセットアップ、スケーリング、アップデートを自動化します。<br>マイクロサービス：独立してデプロイ可能な小さなサービスのことで、1つの大きなアプリケーションを構成します。異なるマイクロサービスは各々異なるリソース要求を持つことがあります。<br>ノードプール：Kubernetes Engineにおける、同じ構成を持つノード（ワーカーマシン）のグループです。異なるノードプールは、異なるマシンタイプや異なるリソース要求を持つマイクロサービスに利用できます。<br>マシンタイプ：Google Cloud Compute Engineにおける、仮想マシンのスペックを表す指標です。CPU、メモリ、ストレージの種類や量などを定義します。コンピューティング最適化、メモリ最適化、ストレージ最適化など、さまざまなワークロードに最適化されたマシンタイプがあります。<br>リソース要求：Kubernetesの機能で、ポッドが必要とするCPUとメモリの量を指定します。しかし、この設定だけではワークロードに最適なマシンタイプのノードが使用されるとは限りません。<br>ポッド優先度：Kubernetesの機能で、ポッドがリソースを競合する際の優先度を決定します。しかし、これはリソースの効率的な使用とは直接関連はありません。<br>正解についての説明：<br>（選択肢）<br>・画像レンダリングマイクロサービス用に、コンピューティングに最適化されたマシンタイプのノードでノードプールを作成します。他のマイクロサービスには、汎用マシン型ノードのノードプールを使用します<br>この選択肢が正解の理由は以下の通りです。<br>ノードプールをうまく活用することで、各マイクロサービスのリソース要件に合わせた最適化が可能です。画像レンダリングマイクロサービスは大量のCPU時間を必要とするため、その性能要件に合わせた、コンピューティングに最適化されたマシンタイプのノードでノードプールを作成することが最適です。これにより、このマイクロサービスの性能を最大限に引き出しつつ、不必要なリソース消費を防ぐことができます。<br>一方、他のマイクロサービスはn2標準のマシンタイプに最適化されているので、これらのサービスに対しては、バランスの取れたリソース配置を提供する汎用マシン型ノードのノードプールを使用するのが適しています。これにより、すべてのマイクロサービスが必要なリソースを効率的に使用する構成です。<br>不正解の選択肢についての説明：<br>選択肢：画像レンダリングマイクロサービスのポッドに、他のマイクロサービスよりも高いポッド優先度を割り当てます<br>この選択肢が正しくない理由は以下の通りです。<br>ポッドの優先度の設定は、リソース使用効率の最適化には直接関連がないためです。優先度設定はポッド間のスケジューリング優先度を管理するもので、それ自体が特定のマイクロサービスのCPUやメモリ使用量を最適化するものではありません。<br>選択肢：画像レンダリングマイクロサービスには、汎用マシン型ノードのノードプールを使用します。他のマイクロサービス用に、計算を最適化したマシン型ノードのノードプールを作成します<br>この選択肢が正しくない理由は以下の通りです。<br>画像レンダリングマイクロサービスは大量のCPU時間を必要とするため、計算に最適化されたマシン型ノードが適しています。汎用マシン型ノードを用いると、リソース使用効率が低下し性能も不十分になります。<br>したがって、このマイクロサービスには汎用マシン型よりも計算最適化型のノードプールが適しています。<br>選択肢：画像レンダリングマイクロサービスデプロイのリソース要求仕様で、必要なCPUとメモリの量を設定します。他のマイクロサービスのリソース要求はデフォルトのままにしておきます<br>この選択肢が正しくない理由は以下の通りです。<br>リソース要求を設定するだけでは、最適化されたマシンタイプが自動的に割り当てられるわけではありません。リソースが効率的に使用されるように、ワークロードに合わせてノードプールを選択することが重要です。CPUを集中的に使用する画像レンダリングを行うマイクロサービスと他のマイクロサービスは異なるワークロードを扱うため、適切なマシンタイプのノードプールをそれぞれ作成する方が最適です。'>
<div class='choice'> 画像レンダリングマイクロサービスには、汎用マシン型ノードのノードプールを使用します。他のマイクロサービス用に、計算を最適化したマシン型ノードのノードプールを作成します</div>
<div class='choice'> 画像レンダリングマイクロサービス用に、コンピューティングに最適化されたマシンタイプのノードでノードプールを作成します。他のマイクロサービスには、汎用マシン型ノードのノードプールを使用します</div>
<div class='choice'> 画像レンダリングマイクロサービスのポッドに、他のマイクロサービスよりも高いポッド優先度を割り当てます</div>
<div class='choice'> 画像レンダリングマイクロサービスデプロイのリソース要求仕様で、必要なCPUとメモリの量を設定します。他のマイクロサービスのリソース要求はデフォルトのままにしておきます</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題11<br>あなたはDockerイメージにパッケージされたアプリケーションを作成しました。そのDockerイメージをGoogle Kubernetes Engineにワークロードとしてデプロイしたいと考えています。<br>この要件を満たすために、どうすればよいですか？' data-answer='2' data-explanation='解説<br>正解は「Container Registryにイメージをアップロードし、イメージを参照するKubernetes Deploymentを作成します」です。<br>この問題では、DockerイメージをGoogle Kubernetes Engineに適切にデプロイするための手順を理解する必要があります。Dockerイメージのアップロード先と、その後のKubernetesにおける利用方法に注意しましょう。選択肢を見る際には、Dockerイメージをどこに格納し、Kubernetesのどの概念（DeploymentやService）を使ってそのイメージを参照するか、を基に選ぶべきだということを意識してください。<br>基本的な概念や原則：<br>Container Registry：Google Cloudのプライベートコンテナイメージストレージとデリバリーサービスで、Dockerイメージを格納し、管理を行います。これを使用することで、Kubernetes Engineでのデプロイメントを容易に実現することができます。<br>Dockerイメージ：アプリケーションを含むコンテナのスナップショットです。これにより、システムやハードウェア緻密にアプリケーションを実行することができます。<br>Google Kubernetes Engine（GKE）：Google Cloudが提供するKubernetes環境を実行するためのマネージドサービスです。GKEは、プロジェクトのDockerイメージをデプロイするための信頼性の高いプラットフォームを提供します。<br>Kubernetes Deployment：Kubernetesのリソースの一種で、指定した数のリプリカを持つアプリケーションを実行します。Deploymentはイメージのデプロイやアップデートを容易に行うことができます。<br>Cloud Storage：Google Cloudのスケーラブルで耐久性のあるデータストレージサービスです。必ずしもコンテナイメージのデプロイには適していません。<br>Kubernetes Service：Kubernetesのリソースの一種で、一連のポッドにネットワークトラフィックをルーティングします。ただし、直接的にはイメージのデプロイには関与しません。<br>正解についての説明：<br>（選択肢）<br>・Container Registryにイメージをアップロードし、イメージを参照するKubernetes Deploymentを作成します<br>この選択肢が正解の理由は以下の通りです。<br>まず、DockerイメージをGoogle Kubernetes Engineにデプロイするためには、そのイメージをGoogle Cloud内でアクセス可能な場所に保管する必要があります。Google CloudのContainer Registryはプライベートで高速なDockerイメージのストレージサービスであり、これを使用してDockerイメージをクラウドにアップロードすることで、GKEやその他のGoogle Cloudサービスから容易にアクセスできるようになります。<br>次に、アップロードしたDockerイメージをGKEにデプロイするためには、そのイメージを参照するKubernetesのDeploymentリソースを作成します。DeploymentはGKEで提供されるKubernetesリソースの一つで、指定したDockerイメージを基にポッドを作成・管理し、その状態を保持します。これらのポッドをベースとしてサービスを作成することで、アプリケーションを外部からアクセス可能にすることができます。<br>以上の手順により、DockerイメージにパッケージされたアプリケーションをGKEにデプロイすることができます。<br>不正解の選択肢についての説明：<br>選択肢：画像をCloud Storageにアップロードし、その画像を参照するKubernetes Serviceを作成します<br>この選択肢が正しくない理由は以下の通りです。<br>DockerイメージをCloud Storageにアップロードし、それを参照するKubernetes Serviceを作成する方法は、適切なアプリケーションのデプロイ手段とはなり得ません。DockerイメージはContainer Registryにアップロードするのが正しいです。その上でKubernetes Deploymentを作成し、そこからイメージを参照させてアプリケーションをデプロイします。<br>選択肢：イメージをCloud Storageにアップロードし、イメージを参照するKubernetes Deploymentを作成します<br>この選択肢が正しくない理由は以下の通りです。<br>DockerイメージをCloud Storageにアップロードしても、KubernetesはCloud Storageから直接イメージを読み込めません。<br>それに対して、Container RegistryはDockerイメージの管理とデプロイを直接行い、Kubernetes Deploymentに直接参照することができます。<br>選択肢：Container Registryにイメージをアップロードし、イメージを参照するKubernetes Serviceを作成します<br>この選択肢が正しくない理由は以下の通りです。<br>Kubernetes Serviceはアプリケーションのネットワーク接続を管理しますが、Dockerイメージを直接デプロイするロールはありません。<br>一方、Kubernetes DeploymentはDockerイメージに基づいてポッドを作成し、スケールや更新などの管理を行います。だからこそ、DockerイメージをデプロイするにはDeploymentを利用するべきです。'>
<div class='choice'> 画像をCloud Storageにアップロードし、その画像を参照するKubernetes Serviceを作成します</div>
<div class='choice'> イメージをCloud Storageにアップロードし、イメージを参照するKubernetes Deploymentを作成します</div>
<div class='choice'> Container Registryにイメージをアップロードし、イメージを参照するKubernetes Deploymentを作成します</div>
<div class='choice'> Container Registryにイメージをアップロードし、イメージを参照するKubernetes Serviceを作成します</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題12<br>ロードバランスをしたいインスタンスグループがあります。ロードバランサにクライアントのSSLセッションを終了させたいと考えています。インスタンスグループはHTTPSで公開ウェブアプリケーションを提供するために使われます。あなたは、Googleが推奨するプラクティスに従う必要があります。<br>この要件を満たすために、どうすればよいですか？' data-answer='1' data-explanation='解説<br>正解は「HTTP(S)ロードバランサを設定します」です。<br>この問題では、ロードバランサにクライアントのSSLセッション終了のタスクを任せるための適切な設定を理解することが重要です。要件の一部として公開ウェブアプリケーションの提供も示されているので、HTTPやHTTPSのトラフィックに対応できるロードバランサの選択が求められています。また、Googleが推奨するプラクティスを採用するという要請に基づき、それぞれの選択肢がその推奨プラクティスに一致するかを考慮することが重要で、Google Cloudの公式ドキュメンテーションは参考になります。<br>基本的な概念や原則：<br>HTTP(S)ロードバランサ：HTTPおよびHTTPSトラフィックを複数のインスタンスに分散できるトラフィックマネージメントサービスです。クライアントのSSLセッションを終了するためによく使用されます。<br>SSLセッションの終了：ロードバランサで行われるプロセスで、クライアントからの暗号化されたトラフィックを復号化し、バックエンドのサーバーに送信します。これにより、バックエンドのサーバは元のデータを処理することができます。<br>インスタンスグループ：Google Cloud上で一緒に管理される一連の仮想マシンインスタンスです。ロードバランスやスケーリングなどのタスクを共同で実行します。<br>内部TCPロードバランサ：プライベートなGoogle Cloudネットワーク内部でTCPトラフィックを分散させるサービスです。公開ウェブアプリケーションの提供ではgenerally使用されません。<br>外部SSLプロキシロードバランサと外部TCPプロキシロードバランサ：非HTTP(S)トラフィックを処理するためのロードバランサです。これらは一般的に、HTTP(S)を使用しないアプリケーションのロードバランスに使用されます。<br>正解についての説明：<br>（選択肢）<br>・HTTP(S)ロードバランサを設定します<br>この選択肢が正解の理由は以下の通りです。<br>HTTP(S)ロードバランサは、Google Cloud上で動作する複数のインスタンスに対するトラフィックを均等に分散させるための機能であり、ロードバランシングが必要なインスタンスグループにとって最適な選択肢です。それだけでなく、HTTP(S)ロードバランサはSSL終端の能力を持っていて、これによりロードバランサがクライアントのSSLセッションを終了できます。これによりインスタンスのリソースを節約し、セキュリティを強化することができます。<br>また、HTTPSを利用するウェブアプリケーションにとっては、SSL終端が重要な要素の一つであり、HTTP(S)ロードバランサはこの要件を満足します。さらにGoogleのベストプラクティスでもあるLayer 7ロードバランシングの機能も提供しています。<br>したがって、ロードバランシングとSSL終端の両方を実現するために、HTTP(S)ロードバランサを設定するのが一番良い方法といえます。<br>不正解の選択肢についての説明：<br>選択肢：内部TCPロードバランサを設定します<br>この選択肢が正しくない理由は以下の通りです。<br>内部TCPロードバランサはエンドユーザーへの公開ウェブアプリケーション提供に向きません。内部TCPロードバランサは、内部のプライベートネットワーク内でバランシングをするためのもので、SSLセッションなどの高度な機能を持ちません。<br>それに対して、HTTP(S)ロードバランサはセッション終了等を含めた高度なHTTP(S)固有の操作を提供できます。<br>選択肢：外部SSLプロキシロードバランサを設定します<br>この選択肢が正しくない理由は以下の通りです。<br>HTTPSの公開ウェブアプリケーションでロードバランシングを行いたいのであれば、HTTP(S)ロードバランサを利用するのが適切です。これはL7のロードバランシングを可能にします。<br>一方、外部SSLプロキシロードバランサは一般的にはTCP/SSLのトラフィック（L4）のバランシングに使用されます。<br>したがって、この要件には適していません。<br>選択肢：外部TCPプロキシロードバランサを設定します<br>この選択肢が正しくない理由は以下の通りです。<br>TCPプロキシロードバランサは、TCPレベルのロードバランシングに使用されますが、特定のHTTPSリクエストのロードバランシングには適していません。HTTPSという特性上、HTTP(S)ロードバランサが推奨されます。これは、HTTPSのセッション終了とレイヤー7のロードバランシング機能を提供するためです。'>
<div class='choice'> 外部SSLプロキシロードバランサを設定します</div>
<div class='choice'> HTTP(S)ロードバランサを設定します</div>
<div class='choice'> 外部TCPプロキシロードバランサを設定します</div>
<div class='choice'> 内部TCPロードバランサを設定します</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題13<br>ポート443でSSL暗号化されたTCPトラフィックを受信するアプリケーションがあります。このアプリケーションのクライアントは世界中にいます。クライアントの待ち時間を最小限に抑えたいと考えています。<br>どのロードバランシングオプションを使用すべきですか？' data-answer='3' data-explanation='解説<br>正解は「SSLプロキシロードバランサ」です。<br>この問題では、具体的な要件に基づいたロードバランシングの選択肢を問われています。要件は次の通りです：ポート443でSSL暗号化されたTCPトラフィック、世界中からのクライアント、待ち時間の最小限化。これらの要件を満たすロードバランシングの種類を選択肢から選びます。次に、正解と不正解の選択肢をそれぞれ正確に消去法で照らし合わせることが必要です。<br>基本的な概念や原則：<br>SSLプロキシロードバランサ：外部トラフィック（IPv4 / IPv6）に対して、SSLプロキシロードバランサはパッシュで層7のSSLセッションを終了させるサービスです。ここでのSSLトラフィックは、バックエンドのインスタンスまでTCPとして続きます。<br>HTTPSロードバランサ：HTTPSのリクエストを複数のバックエンドサービスに分散させ、グローバルからリージョナルへのインテリジェントなトラフィックルーティングを提供します。<br>ネットワークロードバランサ：TCP/UDPのトラフィックをリージョン全体のインスタンスグループに分散させるタイプのロードバランサです。IPアドレスとポート番号に基づいてトラフィックを転送します。<br>内部TCP/UDPロードバランサ：VPCネットワーク内部からのトラフィックをGoogle Cloud内のインスタンスグループに分散させるロードバランサです。<br>ファイアウォールのルール：Google Cloudの専用防火壁設定です。特定のIPアドレス範囲からのトラフィックを許可するなど、ネットワークトラフィックへの制御を提供します。<br>正解についての説明：<br>（選択肢）<br>・SSLプロキシロードバランサ<br>この選択肢が正解の理由は以下の通りです。<br>SSLプロキシロードバランサは、Google Cloudのロードバランシングオプションの中で、SSL（TCP / 443）トラフィックの分散に適しています。ポート443のSSLで暗号化されたトラフィックを受け取るアプリケーションのシナリオに対応しており、その仕組みは、クライアントからのSSLトラフィックをバックエンドのサーバーに転送するために使用します。<br>また、このロードバランサはGoogle Cloudのグローバルネットワークを活用して、トラフィックを最も近いバックエンドにルーティングします。これにより、どこにいてもクライアントの待ち時間が最小限に抑えられます。<br>したがって、世界中のクライアントからのトラフィックを受け入れるアプリケーションに対して、クライアントの待ち時間を最小限に抑える目的に最適です。<br>不正解の選択肢についての説明：<br>選択肢：HTTPSロードバランサ<br>この選択肢が正しくない理由は以下の通りです。<br>HTTPSロードバランサはHTTPとHTTPSトラフィックのロードバランシングを行うためのものであり、SSL暗号化されたTCPトラフィックのロードバランシングには適していません。これに対してSSLプロキシロードバランサはSSL/TLSトラフィックのロードバランシング用に設計されているため、要件に最適です。<br>選択肢：ネットワークロードバランサ<br>この選択肢が正しくない理由は以下の通りです。<br>ネットワークロードバランサは単一リージョン内でのTCP/UDPトラフィックの負荷分散用途に適していますが、クライアントが世界中に分散していて待ち時間を最小限に抑える必要がある場合、SSLプロキシロードバランサのようなグローバルなロードバランシングオプションが適しています。<br>選択肢：内部TCP/UDPロードバランサ。ターゲットインスタンスの0.0.0.0/0からの内向きトラフィックを許可するファイアウォールのルールを追加します<br>この選択肢が正しくない理由は以下の通りです。<br>内部TCP/UDPロードバランサは、ユーザーから直接トラフィックを受け入れるのではなく、プライベートネットワーク内部の負荷分散を目的として設計されています。<br>一方、SSLプロキシロードバランサは公開されたサービスに対するSSLトラフィックを分散するために設計されていて、グローバルなスケールで動作します。これにより、世界中からのクライアントの待ち時間を最小限に抑えられます。'>
<div class='choice'> ネットワークロードバランサ</div>
<div class='choice'> HTTPSロードバランサ</div>
<div class='choice'> 内部TCP/UDPロードバランサ。ターゲットインスタンスの0.0.0.0/0からの内向きトラフィックを許可するファイアウォールのルールを追加します</div>
<div class='choice'> SSLプロキシロードバランサ</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題14<br>あなたは時系列データを処理するパイプラインを構築しています。<br>どのGoogle Cloudサービスをボックス1、2、3、4に入るべきですか？' data-answer='2' data-explanation='解説<br>正解は「Cloud Pub/Sub、Cloud Dataflow、Cloud Bigtable、BigQuery」です。<br>この問題では、IoTデバイスからの時系列データを処理するパイプラインを構築するときにGoogle Cloudのどのサービスを使用するべきか問われています。パイプラインの中間プロセスが2から枝分かれし、ストレージと分析に分かれていることを確認してください。これにより、データがストレージに保存され、さらに分析を受けることが予測されます。各パートで適切なサービスを選択する際には、データのフローとそれぞれのサービスの機能を十分理解することが重要です。<br>基本的な概念や原則：<br>Cloud Pub/Sub：リアルタイムのメッセージングサービスで、プロデューサからコンシューマへのメッセージ配信をおこないます。高スループットと低レイテンシを提供します。<br>Cloud Dataflow：ストリームとバッチデータの両方を処理するためのフルマネージドなサービスです。データの処理と変換を容易に行うことができ、エラトレラントなパイプラインを構築します。<br>Cloud Bigtable：Google CloudのNoSQLビッグデータデータベースサービスで、大量の時系列データを効率的に管理します。低レイテンシでリアルタイムのアクセスを可能にします。<br>BigQuery：Google Cloudのフルマネージドなビッグデータ分析サービスです。大量のデータに対してSQLクエリを高速に実行し、インサイトを取得することができます。<br>Firebase Cloud Messaging：Push通知やメッセージング機能を使うアプリで使われることが多いFirebaseの一部です。IoTデータ処理のパイプラインには通常は使用されません。<br>正解についての説明：<br>（選択肢）<br>・Cloud Pub/Sub、Cloud Dataflow、Cloud Bigtable、BigQuery<br>この選択肢が正解の理由は以下の通りです。<br>まず、Cloud Pub/Subはリアルタイムで大量のメッセージング処理を管理するためのサービスであり、IoTデバイスからの高度にスケーラブルな入力ストリームとして機能します。これにより、ボックス1でメッセージのパブリッシュとサブスクライブを行うことができます。<br>次に、Cloud Dataflowはストリームやバッチデータの並列処理を提供し、時間やシーケンスに依存するデータを柔軟に処理する能力を持っています。これは、ボックス2の配信処理と分析処理の実装にふさわしいサービスです。<br>また、Cloud Bigtableは高スループットと低レイテンシで大量の時系列データを処理するのに適したNoSQLデータベースサービスであり、ボックス3のストレージソリューションとして適しています。<br>最後に、BigQueryは大規模な分析用に設計されたエンタープライズ向けデータウェアハウスであり、時間的なトレンド、パターン、異常検出など、時系列データの分析観点から見てボックス4のロールを適切に果たします。<br>不正解の選択肢についての説明：<br>選択肢：Cloud Pub/Sub、Cloud Dataflow、Cloud Datastore、BigQuery<br>この選択肢が正しくない理由は以下の通りです。<br>ボックス3にCloud Datastoreが選択されていますが、Cloud Datastoreはドキュメント指向のNoSQLデータベースで時系列データの保存には最適ではありません。<br>それに対して、Cloud Bigtableは時系列データの保存に最適な高性能なNoSQLデータベースであり、このため正解はCloud Bigtableです。<br>選択肢：Firebase Cloud Messaging、Cloud Pub/Sub、Cloud Spanner、BigQuery<br>この選択肢が正しくない理由は以下の通りです。<br>まず、"Firebase Cloud Messaging"は主にモバイルユーザーにプッシュ通知を送るためのサービスなので、時系列データの処理には不適切です。代わりに"Cloud Pub/Sub"は大量のメッセージを瞬時に処理できるため、この場合に適しています。<br>また、"Cloud Spanner"はリレーショナルデータベースで、時系列データの長期格納には"Cloud Bigtable"が適しています。<br>選択肢：Cloud Pub/Sub、Cloud Storage、BigQuery、Cloud Bigtable<br>この選択肢が正しくない理由は以下の通りです。<br>Cloud Storageはデータレイクの役割を果たしますが、時系列データを処理するパイプラインでは、リアルタイムにデータストリームを管理できるCloud Dataflowの方が適切です。<br>また、BigQueryはデータ分析に、Cloud Bigtableは高速な読み取りと書き込みが必要な大規模な時系列データに適しています、しかし3にCloud Bigtableがないとパイプラインは不適切です。'>
<div class='choice'> Firebase Cloud Messaging、Cloud Pub/Sub、Cloud Spanner、BigQuery</div>
<div class='choice'> Cloud Pub/Sub、Cloud Storage、BigQuery、Cloud Bigtable</div>
<div class='choice'> Cloud Pub/Sub、Cloud Dataflow、Cloud Bigtable、BigQuery</div>
<div class='choice'> Cloud Pub/Sub、Cloud Dataflow、Cloud Datastore、BigQuery</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題15<br>Compute Engineにライセンシングサーバーをデプロイする必要があります。アプリケーションの構成を変更せず、アプリケーションがライセンスサーバーに到達できるようにしたいと考えています。<br>あなたはこの要件を満たすために、どうすればよいですか？？' data-answer='2' data-explanation='解説<br>正解は「gcloudを使用してIP 10.0.3.21を静的なプライベートIPアドレスとして予約し、ライセンスサーバーに割り当てます」です。<br>この問題では、Compute Engine上にデプロイするライセンシングサーバーのIPアドレス要件に着目することが求められています。既存のアプリケーション構成を変更せずにライセンスサーバーに到達可能とするためには、指定のIPアドレスでサーバーがプロビジョニングされることが必要です。選択肢を見る際は、IPアドレスが静的であり、内部的にアクセス可能であることを確認してください。また、無関係なオプションを判別するために、エフェメラルIPと静的IPの違いを理解しておく必要があります。<br>基本的な概念や原則：<br>静的プライベートIPアドレス：VPCネットワーク内で一貫した場所にリソースを配置するために使用することができるIPアドレスです。特定のアプリケーションやサービスが予期せぬ変更なく通信を続けられるようにします。<br>gcloud：Google Cloudのコマンドラインツールです。リソースを管理したり、開発タスクを実行したりするためのインターフェースを提供します。<br>エフェメラルIPアドレス：一時的に割り当てられる、生存期間が限られたIPアドレスです。固定のIPアドレスが不要な一時的なタスクや短期間のコネクティビティに使用されます。<br>静的パブリックIPアドレス：インターネット上の任意の場所からリソースにアクセスするための固定IPアドレスです。ライセンスサーバーのような一貫性のあるアクセスが必要な場合には適していません。<br>正解についての説明：<br>（選択肢）<br>・gcloudを使用してIP 10.0.3.21を静的なプライベートIPアドレスとして予約し、ライセンスサーバーに割り当てます<br>この選択肢が正解の理由は以下の通りです。<br>まず、Compute Engineのインスタンスはデフォルトで動的なプライベートIPアドレスを割り当てられますが、これらのIPアドレスはインスタンスが停止された後は保証されません。動的IPはそのインスタンスが削除または停止されると再びプールに戻り、次回のインスタンス作成時に他のインスタンスに割り当てられます。ライセンスサーバーをデプロイする場合、固定的に特定のIPアドレスが割り当てられている必要があります。クライアント（アプリケーション）が固定的にサーバーを参照できるようにするためです。<br>そのため、インスタンスが削除または停止されたときでもIPアドレスが変わらないように、静的プライベートIPアドレスを使用してライセンスサーバーに割り当てるべきです。`gcloud`コマンドを使用してIPアドレスを予約し、割り当てることで、ライセンシングサーバーは一貫性を持ってアクセス可能となり、アプリケーション構成を変更する必要がなくなります。<br>不正解の選択肢についての説明：<br>選択肢：gcloudを使用してIP 10.0.3.21を静的パブリックIPアドレスとして予約し、ライセンスサーバーに割り当てます<br>この選択肢が正しくない理由は以下の通りです。<br>静的パブリックIPアドレスを予約し、ライセンスサーバーに割り当てると、インターネットから直接アクセス可能になるため、セキュリティ上のリスクが増えます。<br>一方、静的なプライベートIPアドレスを用いることで、アプリケーションがライセンスサーバーにセキュアにアクセスできます。<br>選択肢：カスタムエフェメラルIPアドレスとしてIP 10.0.3.21を使用し、ライセンスサーバーに割り当てます<br>この選択肢が正しくない理由は以下の通りです。<br>エフェメラルIPアドレスは一時的なものであり、VMが停止または削除されると解放されてしまうため、ライセンシングサーバーが常に一定のIPアドレスで接続可能であることを保証できません。<br>一方、静的なプライベートIPアドレスは保持され続けるため、一貫した接続性が担保できます。<br>選択肢：自動的なエフェメラルIPアドレスでライセンシングサーバを開始し、次にそれを静的なプライベートIPアドレスに昇格させます<br>この選択肢が正しくない理由は以下の通りです。<br>エフェメラルIPアドレスは一時的なもので、サーバが停止または再起動されると変わる可能性があるため、ライセンシングサーバのIPアドレスが必要になります。<br>したがって、この方法ではアプリケーションの構成を変更せずにライセンスサーバーに到達する要件を満たしません。静的なプライベートIPアドレスを予め予約しておくことで、サーバのIPアドレスが変更されることなくアプリケーションがライセンスサーバーにアクセスできます。'>
<div class='choice'> 自動的なエフェメラルIPアドレスでライセンシングサーバを開始し、次にそれを静的なプライベートIPアドレスに昇格させます</div>
<div class='choice'> カスタムエフェメラルIPアドレスとしてIP 10.0.3.21を使用し、ライセンスサーバーに割り当てます</div>
<div class='choice'> gcloudを使用してIP 10.0.3.21を静的なプライベートIPアドレスとして予約し、ライセンスサーバーに割り当てます</div>
<div class='choice'> gcloudを使用してIP 10.0.3.21を静的パブリックIPアドレスとして予約し、ライセンスサーバーに割り当てます</div>
</div>
            <!-- 他の問題も同様に追加 -->
        </div>

        <h2 id="question"></h2>
        <ul class="choices" id="choices"></ul>
        <button onclick="checkAnswer()">採点</button>
        <button onclick="nextQuestion()" id="nextButton" style="display: none;">次の問題へ</button>
        <div class="result" id="result"></div>
    </div>

    <script>
        let currentQuestionIndex = 0;
        let correctCount = 0;
        const questions = [];

        document.addEventListener('DOMContentLoaded', () => {
            const questionElements = document.querySelectorAll('#quiz-data .question');
            questions.push(...Array.from(questionElements).map(questionElement => ({
                question: questionElement.getAttribute('data-question').replace(/\\n/g, '<br>'),
                choices: Array.from(questionElement.querySelectorAll('.choice')).map((choice, index) => ({
                    text: choice.innerHTML.replace(/\\n/g, '<br>'),  // innerHTMLに変更
                    index: index
                })),
                correctAnswer: questionElement.getAttribute('data-answer').split(',').map(Number),
                explanation: questionElement.getAttribute('data-explanation').replace(/\\n/g, '<br>'),
                multiple: questionElement.getAttribute('data-multiple') === 'true'
            })));
            showQuestion();
        });

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function showQuestion() {
            const questionElement = document.getElementById('question');
            const choicesContainer = document.getElementById('choices');
            const currentQuestion = questions[currentQuestionIndex];

            shuffleArray(currentQuestion.choices);

            questionElement.innerHTML = currentQuestion.question;
            choicesContainer.innerHTML = '';

            currentQuestion.choices.forEach((choice, i) => {
                const li = document.createElement('li');
                const input = document.createElement('input');
                const label = document.createElement('label');

                input.type = currentQuestion.multiple ? 'checkbox' : 'radio';
                input.name = 'choice';
                input.value = choice.index;
                input.id = 'choice' + i;

                label.htmlFor = 'choice' + i;
                label.innerHTML = choice.text;  // textContentをinnerHTMLに変更

                li.appendChild(input);
                li.appendChild(label);
                choicesContainer.appendChild(li);
            });

            document.getElementById('result').textContent = "";
            document.getElementById('nextButton').style.display = 'none';
        }

        function checkAnswer() {
            const currentQuestion = questions[currentQuestionIndex];
            const selectedChoices = Array.from(document.querySelectorAll('input[name="choice"]:checked'))
                                        .map(checkbox => parseInt(checkbox.value))
                                        .sort();
            const resultElement = document.getElementById('result');
            
            if (selectedChoices.length > 0) {
                const isCorrect = currentQuestion.multiple
                    ? selectedChoices.toString() === currentQuestion.correctAnswer.sort().toString()
                    : selectedChoices.length === 1 && selectedChoices[0] === currentQuestion.correctAnswer[0];
                
                if (isCorrect) {
                    resultElement.innerHTML = "正解です！<br>" + currentQuestion.explanation;
                    resultElement.style.color = "green";
                    correctCount++; // 正解数をカウント
                } else {
                    resultElement.innerHTML = "残念、不正解です。<br>" + currentQuestion.explanation;
                    resultElement.style.color = "red";
                }
                document.getElementById('nextButton').style.display = 'inline';
            } else {
                resultElement.textContent = "回答を選択してください。";
                resultElement.style.color = "orange";
            }
        }

        function nextQuestion() {
            currentQuestionIndex++;
            
            if (currentQuestionIndex < questions.length) {
                showQuestion();
            } else {
                showFinalResult();
            }
        }

        function showFinalResult() {
            const quizContainer = document.querySelector('.quiz-container');
            quizContainer.innerHTML = `
                <h2>問題終了！</h2>
                <p>あなたの正解数は ${correctCount} / ${questions.length} です。</p>
                <button onclick="restartQuiz()">再挑戦する</button>
            `;
        }

        function restartQuiz() {
            correctCount = 0;
            currentQuestionIndex = 0;

            // クイズのUI全体を初期化
            const quizContainer = document.querySelector('.quiz-container');
            quizContainer.innerHTML = `
                <h2 id="question"></h2>
                <ul class="choices" id="choices"></ul>
                <button onclick="checkAnswer()">採点</button>
                <button onclick="nextQuestion()" id="nextButton" style="display: none;">次の問題へ</button>
                <div class="result" id="result"></div>
            `;

            // 初期化後に最初の問題を表示
            showQuestion();
        }        
    </script>
</body>
</html>