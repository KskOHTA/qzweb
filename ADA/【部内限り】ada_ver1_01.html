<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Azure Developer Associate問題集 01</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="quiz-container">

        <div id="quiz-data" style="display: none;">

<div class='question' data-multiple='false' data-question='問題1<br>Azure App Serviceのデプロイ スロット機能を使う目的は何ですか。' data-answer='2' data-explanation='■正解：<br>C:アプリケーションや機能の検証<br>■解説<br>Azure App Serviceのデプロイ スロット機能は、本番環境への直接デプロイを行わずに、新しいバージョンのアプリケーションや機能をテストおよび検証できるようにするために設計されています。この機能により、ステージング環境でアプリケーションの新しいバージョンをフルにテストし、問題がないことを確認した後に、ステージング環境と本番環境を瞬時に切り替える（スワップする）ことができます。これにより、ダウンタイムをほぼゼロに抑えつつ、アップデートや変更を本番環境に適用することが可能になります。<br>デプロイ スロットを使用する主な目的は、本番リリース前の包括的なテストを可能にし、リリースプロセスをより安全かつスムーズにすることにあります。また、万が一本番環境へのデプロイ後に問題が発見された場合でも、以前のバージョンに簡単にロールバックできるため、リスクを最小限に抑えることができます。'>
<div class='choice'  data-group='選択肢' >アプリケーションのスケーリング</div>
<div class='choice'  data-group='選択肢' >バックアップとリカバリー</div>
<div class='choice'  data-group='選択肢' >アプリケーションや機能の検証</div>
<div class='choice'  data-group='選択肢' >データベースの管理</div>
</div>

<div class='question' data-multiple='false' data-question='問題2<br>開発者がコードの変更を頻繁に共有リポジトリに統合し、自動ビルドとテストを行うプロセスを何と言いますか。' data-answer='2' data-explanation='■正解：<br>C:継続的インテグレーション (CI)<br>■解説<br>継続的インテグレーション (Continuous Integration、CI) は、開発プロセスにおいて開発者がコードの変更を頻繁に（多くの場合は一日に複数回）メインの共有リポジトリに統合し、そのたびに自動ビルドとテストを行うことで、ソフトウェアの品質を保つプロセスです。CIの主な目的は、ソフトウェア開発プロセスを効率化し、コードベースに対する変更が他の部分に悪影響を与えていないことを速やかに確認することにあります。これにより、バグの早期発見、修正の迅速化、ソフトウェアのリリースサイクルの加速が可能になります。<br>Azure App Serviceは、ウェブアプリケーションやAPIをホストするためのMicrosoftのクラウドサービスであり、CIと統合することで開発者はコードの変更を簡単にデプロイし、アプリケーションのビルドやテストを自動化することができます。Azure DevOps ServicesやGitHub Actionsといったツールを使ってCIプロセスを設定し、コードの変更がリポジトリにプッシュされるたびに自動的にビルドとテストが実行されるようにします。'>
<div class='choice'  data-group='選択肢' >自動デプロイメント</div>
<div class='choice'  data-group='選択肢' >ステージング環境</div>
<div class='choice'  data-group='選択肢' >継続的インテグレーション (CI)</div>
<div class='choice'  data-group='選択肢' >ロールバック</div>
</div>

<div class='question' data-multiple='false' data-question='問題3<br>Azure App Service on Linuxを使用するメリットは何ですか。' data-answer='3' data-explanation='■正解：<br>D:Linuxベースのアプリケーションのホスティングと運用<br>■解説<br>Azure App Service on Linuxは、Microsoftが提供するクラウドベースのサービスであり、特にLinuxベースのアプリケーションを簡単にホスティングし、運用できるように設計されています。このサービスを使用することで、WebアプリケーションやAPIなどのバックエンドサービスを迅速にデプロイし、世界中どこからでもアクセス可能な状態にすることができます。<br>App Service on Linuxの主な特徴は、以下の通りとなります。<br>・Linuxベースのサポート：このサービスは、Linux OS上で動作するアプリケーションに特化しています。これにより、開発者はLinux環境で慣れ親しんだ言語やツールを利用してアプリケーションを開発し、デプロイすることができます。<br>・コンテナのサポート：Dockerコンテナを使用してアプリケーションをパッケージ化し、デプロイすることが可能です。これにより、アプリケーションの移植性が向上し、開発環境と本番環境の間の差異を最小限に抑えることができます。<br>・自動スケーリング：アプリケーションのトラフィックが増加すると、Azure App Serviceは自動的にリソースをスケーリングして処理能力を向上させます。トラフィックが減少すると、リソースをスケールダウンしてコストを節約できます。<br>・統合開発環境との連携：Azure App Serviceは、Visual Studio CodeやGitHubなどの人気のある開発ツールと緊密に連携しています。これにより、コードの変更を簡単にデプロイし、継続的インテグレーションと継続的デリバリー（CI/CD）プロセスを実現できます。'>
<div class='choice'  data-group='選択肢' >Windows環境専用のアプリケーションサポート</div>
<div class='choice'  data-group='選択肢' >低コストでのインフラストラクチャ管理</div>
<div class='choice'  data-group='選択肢' >シームレスなコンテナーのデプロイメント</div>
<div class='choice'  data-group='選択肢' >Linuxベースのアプリケーションのホスティングと運用</div>
</div>

<div class='question' data-multiple='true' data-question='問題4<br>スケーラビリティと自動スケール機能が利用可能なAzure App Service プランはどれですか。（２つ選択）' data-answer='2,3' data-explanation='■正解：<br>C:Standard<br>D:Premium<br>■解説<br>Azure App Service プランは、Azure App Serviceでホストされるアプリケーションの実行環境を定義するための設定です。このプランは、Webアプリ、APIアプリ、モバイルアプリなど、さまざまなアプリケーションタイプのスケーリング、パフォーマンス、コストのバランスを取るために使用されます。<br>Azure App Service プランは、使用するリソース（CPU、メモリ、ストレージなど）の量と種類、地域の選択、スケーリングの設定、価格などを決定します。<br>StandardおよびPremiumプランは、より高度な機能とリソースを提供するため、スケールアウト（水平方向のスケーリング、つまりインスタンスの数を増やすこと）とスケールアップ（垂直方向のスケーリング、つまりインスタンスの性能を向上させること）の両方をサポートしています。これにより、アプリケーションのトラフィックが増加したときに追加のリソースを動的に割り当てることができ、自動スケール機能を使用してトラフィックの増減に応じて自動的にリソースを調整することが可能になります。'>
<div class='choice'  data-group='選択肢' >Free</div>
<div class='choice'  data-group='選択肢' >Shared</div>
<div class='choice'  data-group='選択肢' >Standard</div>
<div class='choice'  data-group='選択肢' >Premium</div>
<div class='choice'  data-group='選択肢' >Basic</div>
</div>

<div class='question' data-multiple='false' data-question='問題5<br>Azure App Serviceプランに関して正しいのはどれですか。' data-answer='0' data-explanation='■正解：<br>A:一つのApp Serviceプラン内で複数のアプリケーションをホストできる<br>■解説<br>Azure App Serviceプランでは、一つのプラン内に複数のWebアプリ、APIアプリ、モバイルアプリを含めることが可能です。これにより、複数のアプリケーションが同じリソース（CPU、メモリ、ディスクスペースなど）を共有し、コスト効率の良い運用が実現されます。<br>■その他の選択肢<br>・同一プラン内のすべてのアプリケーションは異なるリージョンにデプロイできる：同一プラン内のすべてのアプリケーションは同じリージョンでホストされる必要があります。異なるリージョンにデプロイするには、別のApp Serviceプランを作成する必要があります。<br>・各App Serviceプランは固有の物理サーバーに対応している：各App Serviceプランは、複数の物理サーバーのリソースを共有する可能性があります。固有の物理サーバーに対応しているわけではありません。<br>・App ServiceプランはLinuxベースのアプリケーションをサポートしない：App Serviceプランは、Linuxベースのアプリケーションをサポートしています。Azure App Serviceは、WindowsとLinuxの両方のオペレーティングシステム上でアプリケーションを実行するオプションを提供しています。'>
<div class='choice'  data-group='選択肢' >一つのApp Serviceプラン内で複数のアプリケーションをホストできる</div>
<div class='choice'  data-group='選択肢' >App ServiceプランはLinuxベースのアプリケーションをサポートしない</div>
<div class='choice'  data-group='選択肢' >同一プラン内のすべてのアプリケーションは異なるリージョンにデプロイできる</div>
<div class='choice'  data-group='選択肢' >各App Serviceプランは固有の物理サーバーに対応している</div>
</div>

<div class='question' data-multiple='false' data-question='問題6<br>Azure App Serviceでアプリ動作を監視し、問題が発生した場合にその原因を特定する機能はどれですか。' data-answer='1' data-explanation='■正解：<br>B:診断ログ<br>■解説<br>診断ログは、Azure App ServiceでホストされるWebアプリケーションの実行に関する詳細情報を提供する重要な機能です。これらのログを有効にすることで、アプリケーションの動作を監視し、問題が発生した場合にその原因を特定する手がかりを得ることができます。診断ログは、アプリケーションのパフォーマンス問題やエラーを解決する際に不可欠なリソースとなります。<br>Azure App Serviceでは、以下の主要な診断ログが提供されています。<br>・アプリケーションログ: アプリケーション自体が出力するカスタムログメッセージです。開発者は、アプリケーションコード内で特定のイベントや操作に対するログ出力を実装することができます。<br>・Webサーバーログ: HTTPリクエストに関する情報を記録するログです。これには、アクセスされたURL、リクエストメソッド、応答コード、リクエストの実行時間などが含まれます。<br>・詳細エラーログ: Webサーバーがエラー応答（HTTPステータスコード400以上）を返す際に詳細情報を記録するログです。<br>・失敗したリクエストトレース: サーバーが処理に失敗したHTTPリクエストのトレース情報を記録します。これにより、問題の原因を特定するための詳細な情報を得ることができます。'>
<div class='choice'  data-group='選択肢' >パフォーマンス監視</div>
<div class='choice'  data-group='選択肢' >診断ログ</div>
<div class='choice'  data-group='選択肢' >App Service 環境</div>
<div class='choice'  data-group='選択肢' >リソース利用状況の分析</div>
</div>

<div class='question' data-multiple='false' data-question='問題7<br>Azure App Serviceで自動スケーリングを利用することで、どのような状況に自動的に対応できるようになりますか。' data-answer='1' data-explanation='■正解：<br>B:アプリケーションのトラフィック増加<br>■解説<br>自動スケーリングは、Azure App Serviceなどのクラウドサービスで提供される機能であり、アプリケーションの負荷に基づいてリソースの割り当てを自動的に調整することを可能にします。この機能を利用することで、アプリケーションのパフォーマンスを維持しながら、不要なリソースの割り当てを避けることができます。自動スケーリングは、トラフィックの変動に柔軟に対応し、ユーザーに対して一貫した体験を提供するための重要なツールです。<br>自動スケーリングは、以下のような状況に対応することができます。<br>・トラフィックの増加：プロモーションやイベントなどによりアプリケーションへのアクセスが急増した場合、自動スケーリングによって追加のコンピューティングリソースが割り当てられ、増加したトラフィックを処理します。<br>・定期的なトラフィックの変動：曜日や時間帯によるアクセスの変動が予測できる場合、自動スケーリングはこれらのパターンに基づいてリソースを調整します。<br>・リソースの使用率：CPU使用率やメモリ使用量など、リソースの使用率が特定の閾値を超えた場合にスケールアウト（インスタンス数の増加）やスケールアップ（リソースの性能向上）を行います。'>
<div class='choice'  data-group='選択肢' >ユーザーからのフィードバックの自動収集</div>
<div class='choice'  data-group='選択肢' >アプリケーションのトラフィック増加</div>
<div class='choice'  data-group='選択肢' >サーバーハードウェアの物理的な故障</div>
<div class='choice'  data-group='選択肢' >アプリケーションのソースコード更新</div>
</div>

<div class='question' data-multiple='true' data-question='問題8<br>Azure App Serviceの自動スケーリングでは、どのメトリックを基にスケーリングの条件を設定できますか。（２つ選択）' data-answer='0,4' data-explanation='■正解：<br>A:メモリ使用率<br>E:CPU使用率<br>■解説<br>Azure App Serviceの自動スケーリング機能では、リソース使用率やトラフィックの増減など、さまざまなメトリックを基にスケーリングの条件を設定することができます。特に、メモリ使用率とCPU使用率は、アプリケーションのリソース消費を反映する重要なメトリックであり、これらの値に基づいて自動的にスケールアウト（インスタンス数の増加）またはスケールアップ（インスタンスの性能向上）を行うことができます。<br>App Serviceでは、以下のメトリックを基にスケールアウト・スケールアップすることができます。<br>・CPU使用率：アプリケーションが消費しているCPUリソースの割合です。CPU使用率が高いと、アプリケーションのパフォーマンスに影響を与える可能性があります。一定の閾値を超えた場合にスケールアウトやスケールアップを行うことで、負荷に応じた適切なリソース割り当てを実現します。<br>・メモリの割合：利用中のメモリ量に対する全体のメモリ容量の割合です。メモリ消費が高いと、アプリケーションがクラッシュする原因にもなり得ます。メモリ使用率に基づいて自動スケーリングを設定することで、アプリケーションが安定して稼働し続けるようにします。<br>・ディスクキューの長さ：ディスクI/O要求のキューの長さを示します。ディスクキューが長くなると、データの読み書きが遅れ、アプリケーションのパフォーマンスが低下する可能性があります。このメトリックを監視することで、I/O性能のボトルネックを検出し、適切なタイミングでスケーリングを行うことができます。<br>・HTTPキューの長さ：処理待ちのHTTPリクエストの数です。HTTPキューが長くなると、ユーザーがウェブページのロードなどで遅延を体験する可能性があります。リクエストの増加に対して適切にスケールアウトすることで、ユーザーエクスペリエンスを向上させます。<br>・受信データ：アプリケーションが受信するデータの量です。大量のデータを受信するアプリケーションは、追加のリソースが必要になる場合があります。受信データ量をメトリックとして使用することで、データの流入に応じてリソースを調整します。<br>・送信データ：アプリケーションから送信されるデータの量です。送信データ量が多い場合、ネットワークの帯域幅や処理能力に影響を与える可能性があります。送信データ量に基づいてスケーリングを行うことで、データの流出に対応し、アプリケーションのパフォーマンスを維持します。'>
<div class='choice'  data-group='選択肢' >メモリ使用率</div>
<div class='choice'  data-group='選択肢' >アプリのダウンロード数</div>
<div class='choice'  data-group='選択肢' >デプロイメントの頻度</div>
<div class='choice'  data-group='選択肢' >コード変更の行数</div>
<div class='choice'  data-group='選択肢' >CPU使用率</div>
</div>

<div class='question' data-multiple='false' data-question='問題9<br>Azure Functionsを使用する主な理由は何ですか。' data-answer='1' data-explanation='■正解：<br>B:サーバーレスコンピューティングによるコード実行<br>■解説<br>Azure Functionsは、Microsoft Azureのサーバーレスコンピュートサービスの一つであり、開発者がサーバーの管理やインフラストラクチャの設定を気にすることなく、コードの実行をトリガーに基づいて自動的に行うことができるプラットフォームです。サーバーレスとは、コード実行のためのサーバー管理やスケーリングをクラウドプロバイダーが自動で行うアーキテクチャスタイルを指し、開発者はアプリケーションのビジネスロジックに集中することができます。<br>Azure Functionsは、以下のような機能や特徴を有しています。<br>・イベント駆動：Azure Functionsは、HTTPリクエスト、タイマー、データベースの変更、キューメッセージなど、さまざまなイベントをトリガーとして関数の実行を開始します。<br>・言語の多様性：C#、Java、JavaScript、Pythonなど、多数のプログラミング言語に対応しており、開発者は得意な言語で関数を記述できます。<br>・スケーラビリティ：需要に応じて自動的にスケールアウトし、関数のインスタンス数を増減させることができます。トラフィックの増減に合わせてリソースを効率的に割り当て、コストを抑えることが可能です。<br>・経済的：実際に関数が実行されている時間にのみ課金されるため、リソースの無駄がなく、コストパフォーマンスに優れています。'>
<div class='choice'  data-group='選択肢' >マイクロサービスアーキテクチャの実装</div>
<div class='choice'  data-group='選択肢' >サーバーレスコンピューティングによるコード実行</div>
<div class='choice'  data-group='選択肢' >データベース管理システムの構築</div>
<div class='choice'  data-group='選択肢' >ビッグデータ分析</div>
</div>

<div class='question' data-multiple='false' data-question='問題10<br>Azure Functionsにおけるバインディングとは何ですか。' data-answer='0' data-explanation='■正解：<br>A:トリガーと関数の入力や出力となるデータソースを接続する機能<br>■解説<br>Azure Functionsでのバインディングは、関数の入力と出力を、コードを書くことなく、簡単に外部のデータソースやサービスに接続するための仕組みです。<br>トリガーと密接に関連しており、トリガーは、関数が実行されるきっかけを提供するのに対し、バインディングは、バインディングはそのトリガーに応じて、関数がどのようにデータを入力として受け取り、また処理結果をどのように出力するかを定義します。<br>例えば、ある関数がHTTPリクエストをトリガーとして、そのリクエストのデータを処理して結果をAzure Storageに保存する場合、入力バインディングをHTTPリクエストに、出力バインディングをAzure Storageに設定します。この設定は、関数の定義ファイルに記述され、開発者はこれらのサービスとのデータのやり取りをコード内で直接扱う必要がありません。'>
<div class='choice'  data-group='選択肢' >トリガーと関数の入力や出力となるデータソースを接続する機能</div>
<div class='choice'  data-group='選択肢' >ログやメトリックスを収集してモニタリングするための機能</div>
<div class='choice'  data-group='選択肢' >関数間の通信とデータの共有を管理するための機能</div>
<div class='choice'  data-group='選択肢' >データの変換やフォーマット変更を行うための機能</div>
</div>

<div class='question' data-multiple='false' data-question='問題11<br>ビジュアルデザイナーを使用して、複数のサービスやアプリケーション間でのワークフローやビジネスプロセスを視覚的に構築するサービスはどれですか。' data-answer='2' data-explanation='■正解：<br>C:Azure Logic Apps<br>■解説<br>Azure Logic Appsは、クラウド上でビジネスプロセスやエンタープライズ統合ワークフローを簡単にデザイン、デプロイ、管理できるAzureのサービスです。複数のアプリケーション、データソース、サービス間でのタスク自動化やデータの統合を、コーディングの必要なく視覚的なデザイナーを通じて構築できます。これにより、開発者や非開発者でも、複雑なプロセスを簡単に自動化できます。<br>Azure Logic Appsは、以下の機能を有しています。<br>・イベント駆動のワークフロー：特定のイベントや条件をトリガーとしてワークフローを開始することができます。たとえば、新しいメールの受信、データベースの更新、ソーシャルメディアのポストなどがトリガーになり得ます。<br>・豊富なコネクター：200以上の組み込みコネクターを提供しており、Salesforce、Office 365、Twitter、Dropbox、Googleサービスなど、多数の人気サービスと簡単に連携できます。<br>・視覚的デザイナー：Webベースの視覚的デザイナーを使用して、ドラッグ＆ドロップでワークフローを構築できます。複雑なロジックも視覚的に理解しやすい形でデザインできます。<br>・スケーラビリティと可用性：Azureのグローバルインフラストラクチャを活用して、大規模なワークフローの実行と管理を行うことができます。高いスケーラビリティと可用性を持っています。<br>・統合と自動化：異なるアプリケーション間でのデータの移動、変換、処理を自動化することで、ビジネスプロセスを効率化し、手作業によるエラーを減らします。'>
<div class='choice'  data-group='選択肢' >Azure Functions</div>
<div class='choice'  data-group='選択肢' >Azure Kubernetes Service</div>
<div class='choice'  data-group='選択肢' >Azure Logic Apps</div>
<div class='choice'  data-group='選択肢' >Azure Virtual Machines</div>
</div>

<div class='question' data-multiple='false' data-question='問題12<br>開発者がバックグラウンドタスクをスケジューリングするために使用できるサービスはどれですか。' data-answer='2' data-explanation='■正解：<br>C:WebJobs<br>■解説<br>Azure WebJobsは、Azure App Serviceの機能の一つであり、バックグラウンドタスクや長時間実行されるプロセスをスケジューリングし、実行するために使用されます。WebJobsを利用することで、Webアプリケーションのバックエンドで動作するさまざまなタスクを簡単に管理し、自動化できます。これにより、アプリケーションのメインの処理を妨げることなく、非同期で処理が行えます。<br>WebJobsの機能は、以下の通りです。<br>・スケジューリング：WebJobsを使用すると、特定の時間に実行されるタスクや、定期的に実行されるタスクを簡単にスケジュールできます。<br>・サポートされるプログラミング言語：.NET、Java、PHP、Node.js、Pythonなど、Azure App Serviceがサポートするさまざまなプログラミング言語でタスクを記述できます。<br>・統合オプション：Azure Queue Storage、Azure Blob Storageとの連携など、他のAzureサービスと簡単に統合できます。これにより、ストレージイベントに基づくタスクのトリガーなどが可能になります。<br>・実行方法：連続実行（アプリケーションと同じライフサイクルで常時実行）、トリガー実行（特定のアクションやスケジュールによって実行）、スケジュール実行（CRON式を使用した定期的な実行）など、さまざまな実行方法がサポートされています。<br>・監視とログ：Azureポータルを通じて、WebJobsの実行状況を監視し、ログ情報を確認できます。これにより、デバッグやパフォーマンスのチューニングが容易になります。'>
<div class='choice'  data-group='選択肢' >Azure Functions</div>
<div class='choice'  data-group='選択肢' >Azure App Service</div>
<div class='choice'  data-group='選択肢' >WebJobs</div>
<div class='choice'  data-group='選択肢' >Azure Logic Apps</div>
</div>

<div class='question' data-multiple='true' data-question='問題13<br>Azure Blob Storageのストレージアカウントのオプションとしてどれが提供されていますか。（２つ選択）' data-answer='0,2' data-explanation='■正解：<br>A:Standard<br>C:Premium<br>■解説<br>Azure Blob Storageは、Microsoft Azureが提供するクラウドストレージサービスの一つであり、大量の非構造化データを格納するためのソリューションです。主にテキストやバイナリデータなどの非構造化データを格納するために設計されており、ウェブサイトのコンテンツ、バックアップデータ、ビッグデータ分析、静的ファイルのホスティングなど、幅広い用途に利用されます。Azure Blob Storageは、世界中のデータセンターからアクセス可能で、データの耐久性とスケーラビリティを提供します。<br>Azure Blob Storageを使用するには、ストレージアカウントを作成する必要があり、以下のオプションが提供されています。<br>・Standard<br>特徴：汎用的なストレージアカウントで、HDDに基づくストレージを提供します。Blob Storageだけでなく、ファイル、キュー、テーブルのストレージにも利用でき、一般的なシナリオに適しています。<br>用途：多くのアプリケーションやワークロードに適しており、特にコスト効率を重視する用途に最適です。<br>・Premium<br>特徴：SSDに基づくストレージを提供し、高いI/Oパフォーマンスと低いレイテンシーを実現します。主に、アクセス頻度が高いデータやパフォーマンスが重要なシナリオに適しています。<br>用途：高速なアクセスが必要なウェブサイトのコンテンツ、インタラクティブなビデオストリーミング、データベースストレージなど、パフォーマンスを重視するアプリケーションに最適です。'>
<div class='choice'  data-group='選択肢' >Standard</div>
<div class='choice'  data-group='選択肢' >Basic</div>
<div class='choice'  data-group='選択肢' >Premium</div>
<div class='choice'  data-group='選択肢' >Ultra</div>
<div class='choice'  data-group='選択肢' >Enhanced</div>
</div>

<div class='question' data-multiple='false' data-question='問題14<br>Azure Blob Storageにおいて、頻繁にアクセスされるデータを格納するのに適したデータアクセス層はどれですか。' data-answer='2' data-explanation='■正解：<br>C:ホット<br>■解説<br>Azure Blob Storageでは、保存されるデータのアクセス頻度やライフサイクルに応じて、データアクセス層を選択できます。頻繁にアクセスされるデータを格納するのに適したアクセス層は「ホット」層です。<br>Azure Blob Storageで利用できるデータアクセス層は以下の通りです。<br>・ホット：頻繁にアクセスされるデータに最適で、アクセスコストが低く設定されていますが、ストレージコストは比較的高めです。リアルタイムでのデータアクセスが必要なシナリオや、アクティブに使用されるデータの保存に適しています。<br>・クール：ある程度の頻度でアクセスされるデータに適しており、ホット層に比べてストレージコストは低く設定されていますが、アクセスコストはやや高くなります。少なくとも30日間はデータが保存されることが期待される場合や、頻繁にはアクセスされないが、必要に応じて比較的迅速にアクセスする必要があるデータに適しています。<br>・コールド：この層は、データが最低でも90日間保存されることを想定しており、クール アクセス層と比較して、ストレージコストはより低く、アクセスコストは高くなります。この層は、アクセスされる可能性が低いが、必要に応じて保存しておく必要があるデータに最適です。例えば、長期間のアーカイブやバックアップなどが該当します。<br>・アーカイブ：長期間アクセスされないデータの保存に最適で、最もコストが低く設定されています。データの回復には時間がかかりますが、法的、規制上の要件などで長期間データを保存する必要がある場合に適しています。'>
<div class='choice'  data-group='選択肢' >クール</div>
<div class='choice'  data-group='選択肢' >コールド</div>
<div class='choice'  data-group='選択肢' >ホット</div>
<div class='choice'  data-group='選択肢' >アーカイブ</div>
</div>

<div class='question' data-multiple='false' data-question='問題15<br>Azure Blob Storageは、どのリソースとして利用可能ですか。' data-answer='3' data-explanation='■正解：<br>D:上記の選択肢すべて<br>■解説<br>Azure Blob Storageを利用する際には、以下の階層構造でリソースが整理されます。<br>・ストレージ アカウント：Azureのストレージサービスを利用するための基本的なアカウントです。ストレージアカウント内には、Blob Storageの他に、ファイル、キュー、テーブルストレージなど、さまざまな種類のデータを保存することができます。<br>・ストレージ アカウント内のコンテナ：Blob Storage内でデータを整理するための単位です。フォルダのような役割を果たし、関連するBlobをグループ化して管理するために使用されます。コンテナは、ストレージアカウント内で作成し、それぞれに一意の名前を割り当てます。<br>・コンテナ内の BLOB：BLOB（Binary Large OBject）は、テキストやバイナリデータなど、非構造化データの実際のコンテンツを格納するためのオブジェクトです。BLOBには、ブロックBlob、追加Blob、ページBlobの3種類があり、用途に応じて適切なタイプを選択します。'>
<div class='choice'  data-group='選択肢' >ストレージ アカウント</div>
<div class='choice'  data-group='選択肢' >ストレージ アカウント内のコンテナー</div>
<div class='choice'  data-group='選択肢' >コンテナー内の BLOB</div>
<div class='choice'  data-group='選択肢' >上記の選択肢すべて</div>
</div>

<div class='question' data-multiple='true' data-question='問題16<br>Azure Blob StorageでサポートされているBLOBはどれですか。（３つ選択）' data-answer='1,2,3' data-explanation='■正解：<br>B:ブロックBLOB<br>C:追加BLOB<br>D:ページBLOB<br>■解説<br>Azure StorageでサポートされているBLOBの種類は以下の通りです。<br>・ブロックBLOB (Block Blob)：テキストやバイナリデータの保存に最適です。大きなファイルを扱う場合に便利で、ファイルは複数のブロックに分割され、個別に管理されます。主に、ドキュメント、画像、ビデオファイルなどの静的コンテンツのストレージに使用されます。<br>・追加BLOB (Append Blob)：主にログファイルのように、データが順次追加されるシナリオに適しています。追加BLOBは、ブロックBLOBと似ていますが、データを末尾に追加することに特化しています。<br>・ページBLOB (Page Blob)：ランダムアクセスが必要な大きなファイルに最適です。ページBLOBは、主にVHD (Virtual Hard Disk) ファイルのように、頻繁に読み書き操作が行われるシナリオで使用されます。'>
<div class='choice'  data-group='選択肢' >オブジェクトBLOB</div>
<div class='choice'  data-group='選択肢' >ブロックBLOB</div>
<div class='choice'  data-group='選択肢' >追加BLOB</div>
<div class='choice'  data-group='選択肢' >ページBLOB</div>
<div class='choice'  data-group='選択肢' >非構造化BLOB</div>
</div>

<div class='question' data-multiple='false' data-question='問題17<br>Azure Blob Storageにおいて、リハイドレートとは何ですか。' data-answer='3' data-explanation='■正解：<br>D:アーカイブ層のデータをホットもしくはクール層に移動する<br>■解説<br>Azure Blob Storageにおけるリハイドレートとは、アーカイブ層に保存されているデータを、よりアクセス性が高いホット層またはクール層に移動させるプロセスのことを指します。このプロセスを通じて、長期保存用にアーカイブされていたデータが、必要に応じてより頻繁にアクセスするための層にリハイドレートされます。<br>アーカイブ層は、長期間アクセスされないデータの保存に最適なコスト効率の良い選択肢ですが、データを読み出すことはできません。そのため、アーカイブされたデータが再び頻繁にアクセスする必要が生じた場合、リハイドレートを通じてデータをホット層やクール層に移動させることで、アクセスすることが可能となります。<br>リハイドレートのプロセスでは、ユーザーはアーカイブされたBlobの移動先としてホット層またはクール層を指定でき、この移動プロセスの完了後には、指定された層の特性（コストとアクセス性のバランス）に基づいてデータが管理されます。リハイドレートには時間がかかることがあり、移動が完了するまでの間、データは読み取り可能な状態になりません。'>
<div class='choice'  data-group='選択肢' >ホット層のデータをアーカイブ層に移動する</div>
<div class='choice'  data-group='選択肢' >アーカイブ層のデータのバックアップを定期的に行う</div>
<div class='choice'  data-group='選択肢' >アーカイブ層のデータを一定期間後に自動的に削除する</div>
<div class='choice'  data-group='選択肢' >アーカイブ層のデータをホットもしくはクール層に移動する</div>
</div>

        </div>

        <h2 id="question"></h2>
        <div id="imageContainer" style="display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 20px;">
            <img class="questionImage" src="" alt="Question Image" style="max-width: 100%; display: none;">
            <img class="questionImage" src="" alt="Question Image" style="max-width: 100%; display: none;">
            <img class="questionImage" src="" alt="Question Image" style="max-width: 100%; display: none;">
            <img class="questionImage" src="" alt="Question Image" style="max-width: 100%; display: none;">
        </div>
        <ul class="choices" id="choices"></ul>
        <button onclick="checkAnswer()">採点</button>
        <button onclick="nextQuestion()" id="nextButton" style="display: none;">次の問題へ</button>
        <div class="result" id="result"></div>
    </div>

    <script>
        let currentQuestionIndex = 0;
        let correctCount = 0;
        const questions = [];

        document.addEventListener('DOMContentLoaded', () => {
            const questionElements = document.querySelectorAll('#quiz-data .question');
            questions.push(...Array.from(questionElements).map(questionElement => ({
                question: questionElement.getAttribute('data-question').replace(/\\n/g, '<br>'),
                choices: Array.from(questionElement.querySelectorAll('.choice')).map((choice, index) => ({
                    text: choice.innerHTML.replace(/\\n/g, '<br>'),
                    group: choice.getAttribute('data-group'),
                    index: index
                })),
                correctAnswer: questionElement.getAttribute('data-answer').split(',').map(Number),
                explanation: questionElement.getAttribute('data-explanation').replace(/\\n/g, '<br>'),
                images: questionElement.getAttribute('data-images') ? questionElement.getAttribute('data-images').split(',') : [],
                multiple: questionElement.getAttribute('data-multiple') === 'true'
            })));
            showQuestion();
        });

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function showQuestion() {
            const questionElement = document.getElementById('question');
            const choicesContainer = document.getElementById('choices');
            const imageContainer = document.getElementById('imageContainer');
            const currentQuestion = questions[currentQuestionIndex];

            shuffleArray(currentQuestion.choices);

            questionElement.innerHTML = currentQuestion.question;

            const images = imageContainer.querySelectorAll('.questionImage');
            images.forEach((img, index) => {
                if (currentQuestion.images[index]) {
                    img.src = currentQuestion.images[index];
                    img.style.display = 'block';
                } else {
                    img.style.display = 'none';
                }
            });

            choicesContainer.innerHTML = '';
            const groups = [...new Set(currentQuestion.choices.map(choice => choice.group))];

            groups.forEach(group => {
                const groupContainer = document.createElement('div');
                groupContainer.className = 'group-container';

                const groupTitle = document.createElement('h3');
                groupTitle.innerHTML = `グループ: ${group}`;
                groupContainer.appendChild(groupTitle);

                currentQuestion.choices.filter(choice => choice.group === group).forEach((choice, i) => {
                    const li = document.createElement('li');
                    const input = document.createElement('input');
                    const label = document.createElement('label');

                    input.type = currentQuestion.multiple ? 'checkbox' : 'radio';
                    input.name = `choice_${group}`;
                    input.value = choice.index;
                    input.id = `choice_${group}_${i}`;

                    label.htmlFor = `choice_${group}_${i}`;
                    label.innerHTML = choice.text;

                    li.appendChild(input);
                    li.appendChild(label);
                    groupContainer.appendChild(li);
                });

                choicesContainer.appendChild(groupContainer);
            });

            document.getElementById('result').textContent = "";
            document.getElementById('nextButton').style.display = 'none';
        }

        function checkAnswer() {
            const currentQuestion = questions[currentQuestionIndex];
            const selectedChoices = [];
            const groups = [...new Set(currentQuestion.choices.map(choice => choice.group))];

            groups.forEach(group => {
                const selected = Array.from(document.querySelectorAll(`input[name="choice_${group}"]:checked`))
                                      .map(checkbox => parseInt(checkbox.value));
                selectedChoices.push(...selected);
            });

            selectedChoices.sort();

            const resultElement = document.getElementById('result');

            if (selectedChoices.length > 0) {
                const isCorrect = currentQuestion.multiple
                    ? selectedChoices.toString() === currentQuestion.correctAnswer.sort().toString()
                    : selectedChoices.length === 1 && selectedChoices[0] === currentQuestion.correctAnswer[0];

                if (isCorrect) {
                    resultElement.innerHTML = "正解です！<br>" + currentQuestion.explanation;
                    resultElement.style.color = "green";
                    correctCount++;
                } else {
                    resultElement.innerHTML = "残念、不正解です。<br>" + currentQuestion.explanation;
                    resultElement.style.color = "red";
                }
                document.getElementById('nextButton').style.display = 'inline';
            } else {
                resultElement.textContent = "回答を選択してください。";
                resultElement.style.color = "orange";
            }
        }

        function nextQuestion() {
            currentQuestionIndex++;

            if (currentQuestionIndex < questions.length) {
                showQuestion();
            } else {
                showFinalResult();
            }
        }

        function showFinalResult() {
            const quizContainer = document.querySelector('.quiz-container');
            quizContainer.innerHTML = `
                <h2>問題終了！</h2>
                <p>あなたの正解数は ${correctCount} / ${questions.length} です。</p>
                <button onclick="restartQuiz()">再挑戦する</button>
            `;
        }

        function restartQuiz() {
            correctCount = 0;
            currentQuestionIndex = 0;

            const quizContainer = document.querySelector('.quiz-container');
            quizContainer.innerHTML = `
                <h2 id="question"></h2>
                <div id="imageContainer" style="display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 20px;">
                    <img class="questionImage" src="" alt="Question Image" style="max-width: 100%; display: none;">
                    <img class="questionImage" src="" alt="Question Image" style="max-width: 100%; display: none;">
                    <img class="questionImage" src="" alt="Question Image" style="max-width: 100%; display: none;">
                    <img class="questionImage" src="" alt="Question Image" style="max-width: 100%; display: none;">
                </div>
                <ul class="choices" id="choices"></ul>
                <button onclick="checkAnswer()">採点</button>
                <button onclick="nextQuestion()" id="nextButton" style="display: none;">次の問題へ</button>
                <div class="result" id="result"></div>
            `;

            showQuestion();
        }
    </script>
</body>
</html>
