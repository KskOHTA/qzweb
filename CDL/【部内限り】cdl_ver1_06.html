<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cloud Digital Leader問題集 06</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="quiz-container">
        <div id="quiz-data" style="display: none;">
<div class='question' data-multiple='FALSE' data-question='問題20<br>ある企業が業務アプリケーションをオンプレミスからクラウドに移行しようとしています。<br>この場合、業務や人件費にどのような影響がありますか？' data-answer='2' data-explanation='解説<br>正解は「オンプレミスのインフラ管理コストが削減されます」です。<br>この問題では、オンプレミスからクラウドへの移行が業務や人件費にどのような影響をもたらすかについて理解しなければなりません。オンプレミスとクラウドの違い、特にインフラ管理やコストについて知識が必要です。また、影響は増減の二つに分けられ、どちらの影響が出るのかについても考えるべきです。それぞれの選択肢が具体的に何を示しているのかを読み取るセンスも必要です。<br>基本的な概念や原則：<br>オンプレミスインフラ管理コスト：物理的なハードウェアの購入、設置、運用、更新などに関連する費用です。クラウド移行により、これらのコストは大幅に削減される可能性があります。<br>クラウドコンピューティング：ハードウェアリソースをネットワーク経由で提供する技術です。事前に大規模なハードウェア投資をする必要がなく、使用した分だけを支払う方式が一般的です。<br>クラウドハードウェア管理コスト：クラウドプロバイダーがハードウェアの管理とメンテナンスを担当するため、これらのコストは企業には発生しません。<br>クラウドソフトウェアライセンスコスト：クラウドソフトウェア利用のためのライセンス料金です。具体的なコストは選択するソフトウェアやプランによりますが、オンプレミスの場合と比較して削減されるとは限りません。<br>オンプレミスハードウェア保守：物理的なハードウェアの寿命や故障に対処するためのコストです。クラウド移行により、このコストは発生しなくなります。<br>正解についての説明：<br>（選択肢）<br>・オンプレミスのインフラ管理コストが削減されます<br>この選択肢が正解の理由は以下の通りです。<br>オンプレミスのインフラ管理には、物理的なハードウェアの維持管理やソフトウェアの更新・パッチ適用、電力や冷却などのオペレーション費用が含まれます。これらは、企業の人件費や業務コストに大きな影響を与えます。<br>しかし、業務アプリケーションをクラウドに移行することで、これらのコストが大幅に削減されます。クラウドプロバイダーがインフラの物理的な管理および更新を担当し、消費されたリソースのみを課金するため、企業は必要なインフラを即座に取得し、消費したリソースのみに対して課金されます。これにより、コストをより予測可能にし、企業の財務状況を改善することができます。<br>したがって、この選択肢は正解です。<br>不正解の選択肢についての説明：<br>選択肢：オンプレミスのハードウェア保守コストが増加します<br>この選択肢が正しくない理由は以下の通りです。<br>クラウドへの移行により、オンプレミスのハードウェア保守の必要性は低下します。<br>したがって、逆にオンプレミスのハードウェア保守コストが増加するとは考えにくいです。<br>一方、オンプレミスのインフラ管理コストが削減されるのは、物理的なインフラ管理がクラウドサービスプロバイダに移行するためです。<br>選択肢：クラウドソフトウェアのライセンスコストが削減されます<br>この選択肢が正しくない理由は以下の通りです。<br>クラウドソフトウェアのライセンスコストは、オンプレミスからクラウドへの移行によって自動的に削減されるわけではありません。各ソフトウェアのライセンス契約や利用量によります。<br>一方で、オンプレミスのインフラ管理コストは物理的なメンテナンスが不要なため確実に削減されます。<br>選択肢：クラウドハードウェア管理コストが増加します<br>この選択肢が正しくない理由は以下の通りです。<br>クラウドサービスでは物理的なハードウェア管理はクラウドプロバイダ側が行うため、クラウドへ移行したからと言ってクラウドハードウェア管理コストが増加することはありません。正解の選択肢にあるように、独自のハードウェア管理に関連するコストは削減されます。'>
<div class='choice'> クラウドソフトウェアのライセンスコストが削減されます</div>
<div class='choice'> クラウドハードウェア管理コストが増加します</div>
<div class='choice'> オンプレミスのインフラ管理コストが削減されます</div>
<div class='choice'> オンプレミスのハードウェア保守コストが増加します</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題21<br>マルチクラウドアプリケーションデプロイメント用の一貫したプラットフォームを提供し、他のGoogle Cloudサービスを組織環境に拡張するGoogle Cloudサービスはどれですか？' data-answer='1' data-explanation='解説<br>正解は「Anthos」です。<br>この問題では、マルチクラウドアプリケーションデプロイメントに適したプラットフォームを提供し、さらにGoogle Cloudサービスを組織の環境に拡張する能力を持つサービスについて尋ねています。各選択肢がこの特徴を満たすかどうかを理解し、詳しく比較検討することが大切です。選択肢のうち、マルチクラウド対応かつ組織の環境にGoogle Cloudサービスを拡張可能なフレームワークを提供しているものを選ぶべきです。<br>基本的な概念や原則：<br>Anthos：Google Cloudのオープンクラウドサービスで、マルチクラウドとハイブリッド環境を実現します。異なるクラウドプロバイダーやオンプレミス環境でも一貫したプラットフォームを提供し、アプリケーションの展開と管理を容易にします。<br>マルチクラウド：複数のクラウドサービスプロバイダーのサービスを組み合わせて使用することです。一貫した操作体験と、各プロバイダーの強みを活用することができます。<br>ハイブリッドクラウド：パブリッククラウドとプライベートクラウド（またはオンプレミス環境）を組み合わせて使用することです。複雑なビジネス要件を満たしつつ、柔軟性とスケーラビリティを実現します。<br>Google Kubernetes Engine：Googleが提供するマネージドKubernetesサービスで、高度なスケーリングと運用機能を持ちます。ただし、Anthosと比較すると、マルチクラウドやハイブリッドクラウド対応の機能は限定的です。<br>Virtual Public Cloud（VPC）：Google Cloudの仮想ネットワーキング環境です。ネットワークリソース（サブネット、ルート、ファイアウォールのルール等）を作成し、管理します。<br>Compute Engine：Google Cloudの仮想マシンを提供するサービスです。ただし、マルチクラウドやハイブリッドクラウドを直接サポートする機能は提供していません。<br>正解についての説明：<br>（選択肢）<br>・Anthos<br>この選択肢が正解の理由は以下の通りです。<br>AnthosはGoogle Cloudが提供するマルチクラウドとハイブリッド環境を支えるプラットフォームです。開発と運用の一貫性を保つことで、異なる環境間でのポリシーとセキュリティの管理を単純化可能にします。これは、マルチクラウドアプリケーションデプロイメント用の一貫したプラットフォームを必要とする場合に特に必要です。<br>さらに、Anthosは他のGoogle Cloudサービスを顧客のオンプレミス環境や他のパブリッククラウドに拡張する機能も提供します。データセンター、エッジロケーション、そして他のクラウドプロバイダーにわたって一貫したエクスペリエンスを提供するため、開発者の生産性を高め、オペレーションチームの効率を向上させます。<br>従って、マルチクラウドアプリケーションデプロイメントとGoogle Cloudサービスの組織環境との拡張性を必要とする場合、Anthosは最適な選択肢です。<br>不正解の選択肢についての説明：<br>選択肢：Google Kubernetes Engine<br>この選択肢が正しくない理由は以下の通りです。<br>Google Kubernetes EngineはGoogle Cloudのコンテナオーケストレーションサービスですが、それ自体はマルチクラウドデプロイメントや他のGoogle Cloudサービスの組織環境への拡張は直接提供しません。反対にAnthosは一貫したプラットフォームを提供し、マルチクラウド環境でのアプリケーションデプロイメントを可能にします。<br>選択肢：Virtual Public Cloud<br>この選択肢が正しくない理由は以下の通りです。<br>Virtual Public CloudはGoogle Cloudのサービスではなく、存在しないため正解にはなり得ません。<br>それに対して、Anthosは各種クラウドの一貫したプラットフォームの提供や他のGoogle Cloudサービスの組織環境への拡張を可能にするサービスです。<br>選択肢：Compute Engine<br>この選択肢が正しくない理由は以下の通りです。<br>Compute Engineは、単に仮想マシンを提供するサービスであり、マルチクラウドアプリケーションデプロイメント用の一貫したプラットフォームを提供し、別のGoogle Cloudサービスを組織環境に拡張する能力はありません。<br>それに対して、Anthosはクロスクラウド管理と操作を可能にします。'>
<div class='choice'> Google Kubernetes Engine</div>
<div class='choice'> Anthos</div>
<div class='choice'> Virtual Public Cloud</div>
<div class='choice'> Compute Engine</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題22<br>あなたは、映像スタジオ向けにレンダリングソフトウェアを提供するSaaS（Software as a Service）企業のプログラムマネージャーです。あなたのチームは、シーンのレンダリングを自由にスケジューリングし、いつでも中断して後で再開できる機能を必要としています。個々のシーンのレンダリングは12時間以内で完了し、すべてのシーンの完了時間に関するサービスレベル契約（SLA）はありません。結果はグローバルなCloud Storageのバケットに保存されます。コンピュートリソースは単一の地理的ロケーションに縛られません。このソフトウェアは、Google Cloud上でコストを最適化した方法で実行する必要があります。<br>あなたはこの要件を満たすためには、どうすればよいですか？' data-answer='3' data-explanation='解説<br>正解は「プリエンプティブルインスタンスを使用して、Compute Engine上にアプリケーションをデプロイします」です。<br>この問題では、あなたがソフトウェアを提供している映像スタジオのレンダリングの処理やその保存先、コンピュートリソースの地理的条件やコストを最適化する必要性など、その具体的なビジネス要件と課題を把握することが求められています。この問題でのキーポイントは、レンダリングの自由なスケジューリングと中断・再開の可能性、地理的制約が無いこと、そしてコストの最適化です。これらがヒントとなり、目的に適したGoogle Cloud上での実装方法を選択します。また、サービスレベル契約（SLA）の有無も考慮して、プリエンプティブルインスタンスの利用が適しているかどうか判断することが重要です。<br>基本的な概念や原則：<br>プリエンプティブルインスタンス：コンピューティングの需要が高まると中断されますが、通常のインスタンスよりも大幅にコストが低いCompute Engineのインスタンスタイプです。内容によっては、ワークロードの中断と再開が可能なため、大幅なコスト削減を実現できます。<br>アンマネージドインスタンスグループ：手動で各インスタンスを管理する必要があるCompute Engineのインスタンスグループです。自動修復や自動スケーリングなどの機能が提供されていません。<br>Compute Engine予約：特定のマシンタイプの使用料を前払いすることで、割引を受けられるCompute Engineの機能です。ただし、特定のマシンタイプの使用を保証するものではなく、仮想マシンが必要な数常に稼働している場合にのみコスト効果があります。<br>vCPUとインスタンス数のバランス：コンピューティング需要とコストを最適化するために、個々の仮想マシンのvCPUの数とインスタンスの数のバランスを適切に取ることが重要です。多くのvCPUを持つ数台のインスタンスより、少ないvCPUを持つ多くのインスタンスの方が柔軟性があり、必要に応じてスケールアップやスケールダウンが容易です。<br>Cloud Storage：高い耐久性とスケーラビリティを提供するGoogle Cloudのオブジェクトストレージサービスです。データはグローバルに分散され、どこからでもアクセス可能です。<br>サービスレベル契約（SLA）：サービスプロバイダーと顧客間で定義される、サービスの性能基準やサービス品質を規定した契約です。この問題のコンテキストでは、SLAが存在しないということは、特定の時間内に全てのレンダリングを完了するという厳格な必要性がないことを意味します。<br>正解についての説明：<br>（選択肢）<br>・プリエンプティブルインスタンスを使用して、Compute Engine上にアプリケーションをデプロイします<br>この選択肢が正解の理由は以下の通りです。<br>まず、プリエンプティブルインスタンスを使用することにより、コストの最適化を達成できます。プリエンプティブルインスタンスはGoogle Cloudのリソースとして、通常のインスタンスよりも格段に安価で、しかしその寿命は最大で24時間と制限されています。レンダリング作業は長時間かつ中断可能であるため、これらの制限は必要条件を満たします。<br>さらに、プリエンプティブルインスタンスはデマンドが低いときに自動的に割り当てられ、不要なときには自動的にシャットダウンするため、コスト効率が非常に高いです。<br>また、プリエンプティブルインスタンスはCompute Engine上で運用され、Compute Engineは地理的な制約なくグローバルに展開できるため、単一の地理的ロケーションに依存しないという要件も満たします。<br>また、プリエンプティブルインスタンスはいつでも中断して後で再開できるという、あなたのチームのニーズに完全に一致する特性も持ち合わせています。<br>不正解の選択肢についての説明：<br>選択肢：アンマネージドインスタンスグループを使用して、Compute Engine上にアプリケーションをデプロイします<br>この選択肢が正しくない理由は以下の通りです。<br>アンマネージドインスタンスグループを使うと手動でスケールを調整する必要があります。<br>また、プリエンプティブルインスタンスに比べるとコスト削減効果が低いです。レンダリングの場合、いつでも中断、再開が可能であるという要件に対してプリエンプティブルインスタンスが最適です。<br>選択肢：使用するCompute Engineインスタンスの最小の予約を作成します<br>この選択肢が正しくない理由は以下の通りです。<br>Compute Engineインスタンスの最小の予約は、料金が削減される場合でも、予約した数だけのインスタンスが発生し、中断や再開が自由にできません。また要件としてコスト最適化が重要であり、プリエンプティブルインスタンスが最もコストを抑える解決策です。<br>選択肢：より多くのvCPUでより少ないインスタンスを起動する代わりに、より少ないvCPUでより多くのインスタンスを起動します<br>この選択肢が正しくない理由は以下の通りです。<br>より少ないvCPUでより多くのインスタンスを起動する戦略は、必ずしもコスト最適化を達成するわけではありません。特に、今回のシナリオで問われているような中断可能であり地理的に特定されない柔軟な環境では、プリエンプティブルインスタンスを用いることでリソースの調達コストを大幅に下げることができます。'>
<div class='choice'> より多くのvCPUでより少ないインスタンスを起動する代わりに、より少ないvCPUでより多くのインスタンスを起動します</div>
<div class='choice'> アンマネージドインスタンスグループを使用して、Compute Engine上にアプリケーションをデプロイします</div>
<div class='choice'> 使用するCompute Engineインスタンスの最小の予約を作成します</div>
<div class='choice'> プリエンプティブルインスタンスを使用して、Compute Engine上にアプリケーションをデプロイします</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題23<br>ある組織が、すべてのアプリケーションプログラミングインタフェース（API）の管理にApigeeを使いたいと考えています。<br>Apigeeによって可能になることはどれですか？' data-answer='1' data-explanation='解説<br>正解は「APIパフォーマンスの測定と追跡」です。<br>この問題では、ApigeeというAPI管理ツールが何を可能にするかを問われているため、Apigeeの特性と機能を理解し、それらがどのようにアプリケーションプログラミングインターフェース（API）の管理に役立つかを把握することが重要です。一部の選択肢がApigeeの直接的な能力ではなく、その結果として得られるものかもしれないため、それらの選択肢には注意が必要です。<br>基本的な概念や原則：<br>Apigee：Google Cloudが提供するフルマネージドAPIプラットフォームです。APIの開発、保護、分析、スケーリングを効果的に行うことができます。<br>API管理：開発され、デプロイされたAPIの追跡、制御、分析及び適切な利用を確保するプロセスです。これにはパフォーマンスの追跡や測定も含まれます。<br>APIパフォーマンス測定：APIのレスポンスタイム、成功率、並行リクエスト数などの指標を追跡し、APIの品質と利用可能性を確認する行程です。<br>APIのプライバシー強化：APIを通じてアクセス可能なデータのプライバシーを強化する行程です。しかし、これにはアプリケーションの設計やセキュリティポリシーの適用等が必要であり、Apigee単体では実現できません。<br>APIのマーケティングと販売：APIの経済的な価値を最大化するための行程です。しかし、ApigeeはAPIの販売やマーケティングまでは手掛けません。<br>正解についての説明：<br>（選択肢）<br>・APIパフォーマンスの測定と追跡<br>この選択肢が正解の理由は以下の通りです。<br>まず、ApigeeはGoogle CloudのフルライフサイクルAPI管理プラットフォームであり、APIの設計、保護、デプロイ、監視、分析に使われることで定評があります。特に、ApigeeはAPIパフォーマンスの測定と追跡という具体的な要件を満たす能力を提供します。これにより、開発者と運用チームはAPIのパフォーマンスをリアルタイムで監視し、APIの使用状況、応答時間、エラーレートなどの重要な指標に基づいて、問題の特定や対処を行うことができます。<br>また、これらの指標を通じて、APIの視覚的なダッシュボードを作成し、パフォーマンスやエラーのトレンドを特定でき、これにより意思決定を裏付け、改良や最適化のための洞察をもたらします。<br>従って、APIパフォーマンスの測定と追跡は、Apigeeを利用したAPI管理の主要な側面であり、正解です。<br>不正解の選択肢についての説明：<br>選択肢：アプリケーションのプライバシー強化<br>この選択肢が正しくない理由は以下の通りです。<br>ApigeeはAPIの管理ツールで、APIパフォーマンスの測定と追跡が可能ですが、アプリケーションのプライバシー強化を直接的に行う機能は含んでいません。プライバシー強化は個別に実装する必要があります。<br>選択肢：アプリケーション開発速度の分析<br>この選択肢が正しくない理由は以下の通りです。<br>ApigeeはAPIのライフサイクルを管理するためのプラットフォームであり、APIのパフォーマンス測定や追跡などが可能です。<br>一方で、アプリケーション開発速度の分析は開発過程に関する情報が必要であり、それはApigeeの機能範囲外です。<br>選択肢：APIのマーケティングと販売<br>この選択肢が正しくない理由は以下の通りです。<br>ApigeeはAPIの開発、管理、分析等を行うためのプラットフォームであり、APIのパフォーマンス追跡や測定が可能です。<br>しかし、APIのマーケティングや販売のための機能は提供していません。そのため、APIのマーケティングや販売の実現には、別途対応が必要です。'>
<div class='choice'> APIのマーケティングと販売</div>
<div class='choice'> APIパフォーマンスの測定と追跡</div>
<div class='choice'> アプリケーション開発速度の分析</div>
<div class='choice'> アプリケーションのプライバシー強化</div>
</div>
<div class='question' data-multiple='true' data-question='問題24<br>ある組織がオンプレミス環境をクラウドに移行することを決定しました。移行にあたって、どのリソースコンポーネントに所有権を割り当てる必要があるかを決定する必要があります。<br>パブリッククラウドプロバイダーが所有する2つの機能はどれですか？（2つ選択）' data-answer='0, 2' data-explanation='解説<br>正解は以下の通りです。<br>・ハードウェアメンテナンス<br>・ハードウェアの容量管理<br>この問題では、パブリッククラウドプロバイダーが所有するロールと、利用者である組織が所有するロールを理解することが必要です。パブリッククラウド環境では、プロバイダーがハードウェアや一部のインフラストラクチャを管理します。一方、アプリケーションレベルのセキュリティや自動化といった内容は利用者の責任になります。この視点から選択肢を探り、パブリッククラウドプロバイダーが所有すると考えられるものを選ぶようにしましょう。<br>基本的な概念や原則：<br>ハードウェアメンテナンス：物理的なインフラストラクチャの修理や交換、アップグレードなどを含みます。パブリッククラウドプロバイダーは、自身の提供するサービスの物理的インフラストラクチャを維持管理します。<br>ハードウェアの容量管理：物理的なインフラストラクチャのリソース利用のバランシングと最適化を含みます。これにはストレージやネットワーク、コンピューティングリソースの割当や調整が含まれます。これもパブリッククラウドプロバイダーの役割です。<br>インフラストラクチャ：物理的および仮想リソース（サーバー、ストレージ、ネットワークなど）の集合体です。これらは通常、ユーザーが管理します。<br>インフラ配備の自動化：インフラストラクチャのプロビジョニングと配置を自動化するプロセスです。これは通常、組織またはユーザーが管理します。<br>アプリケーションのセキュリティ問題の修正：アプリケーションのセキュリティ問題や脆弱性を修正・管理することです。これは通常、ユーザーまたは開発者の責任です。<br>正解についての説明：<br>（選択肢）<br>・ハードウェアメンテナンス<br>・ハードウェアの容量管理<br>この選択肢が正解の理由は以下の通りです。<br>まず、"ハードウェアメンテナンス"はパブリッククラウドプロバイダーが所有する機能の一つです。パブリッククラウドサービスの特性として、ユーザーが物理的なインフラストラクチャーについて手間をかける必要がないことが挙げられます。具体的には、古いハードウェアの交換や故障したハードウェアの修理といった管理業務はクラウドプロバイダーが行います。<br>次に、"ハードウェアの容量管理"もまたパブリッククラウドプロバイダーの所有機能です。インフラストラクチャーの規模を自由にスケーリングできるのがクラウドサービスの大きなメリットで、これによりユーザーは必要な時に必要なだけのリソースを確保することができます。このハードウェアの容量管理は、チームが手動で行うのではなく、クラウドプロバイダーが行うため、ユーザーは自分たちのビジネスに集中することが可能になります。<br>不正解の選択肢についての説明：<br>選択肢：インフラストラクチャー<br>この選択肢が正しくない理由は以下の通りです。<br>インフラストラクチャーは広範な概念で、具体的な機能やコンポーネントを指すものではありません。<br>一方、正解の選択肢である"ハードウェアメンテナンス"や"ハードウェアの容量管理"は具体的な機能であり、明確にパブリッククラウドプロバイダーが所有する項目です。<br>選択肢：インフラ配備の自動化<br>この選択肢が正しくない理由は以下の通りです。<br>パブリッククラウドプロバイダーはハードウェアメンテナンスとハードウェアの容量管理を所有しますが、インフラ配備の自動化は顧客の責任範囲内です。そのためパブリッククラウドプロバイダーが保有する機能ではありません。<br>選択肢：アプリケーションのセキュリティ問題の修正<br>この選択肢が正しくない理由は以下の通りです。<br>パブリッククラウドプロバイダーはハードウェアメンテナンスや容量管理などのインフラストラクチャに関わる部分の所有権を持ちますが、アプリケーションのセキュリティ問題の修正はクラウドを使用する組織自身が所有するべき責任範囲です。'>
<div class='choice'> ハードウェアの容量管理</div>
<div class='choice'> アプリケーションのセキュリティ問題の修正</div>
<div class='choice'> ハードウェアメンテナンス</div>
<div class='choice'> インフラストラクチャー</div>
<div class='choice'> インフラ配備の自動化</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題25<br>あなたの組織は、オンプレミス環境をGoogle Cloudに移行したいと考えています。オンプレミス環境はコンテナと仮想マシンインスタンスで構成されています。コンテナイメージと仮想マシンディスクの移行に役立つGoogle Cloudサービスはどれですか？' data-answer='2' data-explanation='解説<br>正解は「Artifact RegistryとCloud Storage」です。<br>この問題では、オンプレミス環境をGoogle Cloudに移行する際に役立つサービスについて問われています。特に、コンテナイメージと仮想マシンディスクの移行が主題です。選択肢を見たときに、それぞれがどのような役割を果たし、具体的にどのような内容やデータの移行に適しているのか言及するサービスを理解することが必要です。また、正解となるサービスはコンテナイメージと仮想マシンディスクの移行の両方をカバーできるものであるべきです。<br>基本的な概念や原則：<br>Artifact Registry：コンテナイメージや他のアーティファクトを保存し、管理するGoogle Cloudのサービスです。存在するコンテナ化されたアプリケーションのイメージを安全に移行、保存するのに使用します。<br>Cloud Storage：大量のデータを保存し、したいことに応じて適切なストレージオプションを選択できるGoogle Cloudのサービスです。オンプレミス環境からクラウドへのデータ移行に役立ちます。<br>Compute Engine：大量のインスタンスを動かすためのGoogle Cloudのインフラストラクチャサービスですが、直接のデータ移行サービスではありません。<br>Filestore：Google Cloudの完全マネージドの高スループット、低レイテンシのNetwork Attached Storage（NAS）サービスですが、直接のデータ移行サービスではありません。<br>Dataflow：大規模なバッチとストリームの処理を行うGoogle Cloudのサービスですが、直接のデータ移行サービスではありません。<br>BigQuery：Google Cloudのフルマネージド型のデータウェアハウスサービスですが、直接のデータ移行サービスではありません。<br>Pub/Sub：グローバルなリアルタイムメッセージングサービスですが、直接のデータ移行サービスではありません。<br>正解についての説明：<br>（選択肢）<br>・Artifact RegistryとCloud Storage<br>この選択肢が正解の理由は以下の通りです。<br>まず、Artifact Registryはソフトウェアパッケージのバージョン管理と配布を行うためのフルマネージドサービスで、コンテナイメージの格納に適しています。オンプレミス環境からGoogle Cloudに移行する際に、すでに作成されているコンテナイメージをArtifact Registryに転送し、Google Cloudからそれらのイメージを利用することで移行をスムーズに行うことができます。<br>また、Cloud Storageは大規模なデータの格納に適しており、高い耐久性とスケーラビリティを持っています。仮想マシンディスクのデータをCloud Storageに転送することで、そのデータを必要に応じてGoogle Cloud上の仮想マシンで利用できます。これにより、データの移行とディスクイメージの格納に必要な手間や時間を大幅に節約できます。<br>したがって、Artifact RegistryとCloud Storageは、コンテナと仮想マシンインスタンスから構成されるオンプレミス環境をGoogle Cloudに移行する際に、それぞれコンテナイメージと仮想マシンディスクの移行に役立つサービスです。<br>不正解の選択肢についての説明：<br>選択肢：Compute EngineとFilestore<br>この選択肢が正しくない理由は以下の通りです。<br>Compute EngineとFilestoreは仮想マシンとファイルシステムのサービスであり、コンテナイメージと仮想マシンディスクの移行には利用しません。<br>それに対して、Artifact Registryはコンテナイメージの管理に、Cloud Storageは大容量のバイナリデータ（仮想マシンディスク等）の保管に適しています。<br>選択肢：DataflowとBigQuery<br>この選択肢が正しくない理由は以下の通りです。<br>DataflowとBigQueryはデータ分析やETLタスクに使用されますが、オンプレミス環境のコンテナイメージや仮想マシンディスクの移行には適していません。<br>一方、Artifact Registryはコンテナイメージの管理と配布に使用し、Cloud Storageは一般的なファイルストレージとして使用可能で、ディスクの移行に有効です。<br>選択肢：Pub/SubとCloud Storage<br>この選択肢が正しくない理由は以下の通りです。<br>Pub/Subはリアルタイムメッセージングサービスで、オンプレミス環境にあるコンテナイメージや仮想マシンディスクの移行には役立たないため不適切です。<br>それに対して、Artifact Registryはコンテナイメージの管理・転送に、Cloud Storageは仮想マシンディスクの転送に適しています。'>
<div class='choice'> Pub/SubとCloud Storage</div>
<div class='choice'> Compute EngineとFilestore</div>
<div class='choice'> Artifact RegistryとCloud Storage</div>
<div class='choice'> DataflowとBigQuery</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題26<br>あなたの組織は、異なるGoogle Cloudプロジェクトで多くのワークロードを実行し、それぞれが同じ請求アカウントにリンクされています。各プロジェクトのワークロードのコストは月によって異なりますが、すべてのプロジェクトの全体的な合計コストは比較的安定しています。あなたの組織はコストを最適化する必要があります。<br>この要件を満たすためには、どうすればよいですか？' data-answer='0' data-explanation='解説<br>正解は「確約利用割引の共有を有効にして、合計使用量のコミットメントを作成します」です。<br>この問題では、複数のGoogle Cloudプロジェクトのコスト最適化について問われています。各プロジェクトのコストが月ごとに変動する一方、全体のコストは安定していることから、全体的な視点でのコスト管理が求められています。選択肢を検討する際には、個々のプロジェクトに焦点を当てるのではなく、全体の利用状況を考慮したコスト管理策を選んでください。<br>基本的な概念や原則：<br>確約利用割引：Google Cloudのリソース利用に対して1年または3年間の使用料の予約を行うことで、そのリソースの料金を割り引いて提供するという制度です。この制度を活用すると、予定されているリソース利用に対するコストを抑えられます。<br>プロジェクト：Google Cloudでリソースを組織化、管理するための基本的な単位です。プロジェクトを作成することで、アプリケーション、データ、設定、ユーザーとそのアクセス管理などを一元管理することができます。<br>課金アカウント：Google Cloudの使用料を管理するためのアカウントです。用途や責任者等に応じて複数の課金アカウントを作成し、それぞれを異なるプロジェクトにリンクすることも可能です。<br>統合プロジェクト：複数のワークロードやリソースを一つのプロジェクトに集約することです。しかし、全てを一つのプロジェクトに集約すると一元管理が難しくなる場合もあります。<br>正解についての説明：<br>（選択肢）<br>・確約利用割引の共有を有効にして、合計使用量のコミットメントを作成します<br>この選択肢が正解の理由は以下の通りです。<br>Google Cloudの確約利用割引は、特定のプロジェクトで一定期間（1年または3年）連続してリソースを使用することを事前に約束することで、そのリソースの使用料を大幅に割引にするサービスです。これによりコスト削減を達成することができます。<br>さらに、確約利用割引の共有を有効にすると、オンデマンドの使用時間を差し引いた全体の使用量に対して割引が適用されるようになります。これにより異なるプロジェクト間でリソース使用が変動する状況でも、全体として安定したコストの削減を実現することが出来ます。<br>以上の理由から、複数のプロジェクトで実行されるワークロードのコストを最適化するためには、確約利用割引の共有を有効にし、合計使用量のコミットメントを作成することが効果的です。<br>不正解の選択肢についての説明：<br>選択肢：プロジェクトごとに、通常の最低額のコミットメントを購入します<br>この選択肢が正しくない理由は以下の通りです。<br>通常の最低額のコミットメントをプロジェクトごとに購入すると、各プロジェクトのワークロードのコストの変動性を吸収できず、効率的なコスト最適化が難しくなります。<br>それに対して、確約利用割引の共有を有効にし、合計使用量へのコミットメントを作ることで、合計コストが安定している全体の利用量に対して割引を効果的に適用できます。<br>選択肢：プロジェクトごとに課金アカウントを作成し、各プロジェクトを異なる課金アカウントにリンクします<br>この選択肢が正しくない理由は以下の通りです。<br>プロジェクトごとに課金アカウントを作成し、異なる課金アカウントにリンクすると、各プロジェクトのコストは分散されますが、全体のコスト最適化にはつながらないためです。<br>一方、確約利用割引の共有を有効にしコミットメントを作成することで、全体的な使用量に基づいた割引が適用され、全体のコスト最適化につながります。<br>選択肢：すべての異なるプロジェクトのワークロードを1つの統合プロジェクトに移動します<br>この選択肢が正しくない理由は以下の通りです。<br>すべてのプロジェクトを1つに統合すると、管理が煩雑になり、コストを最適化する原則とは一致しません。<br>それに対して、確約利用割引の共有を有効にしコミットメントを作ることで、安定した合計コストを割引率のある利用料金に変えることができ、最適化につながります。'>
<div class='choice'> 確約利用割引の共有を有効にして、合計使用量のコミットメントを作成します</div>
<div class='choice'> プロジェクトごとに課金アカウントを作成し、各プロジェクトを異なる課金アカウントにリンクします</div>
<div class='choice'> すべての異なるプロジェクトのワークロードを1つの統合プロジェクトに移動します</div>
<div class='choice'> プロジェクトごとに、通常の最低額のコミットメントを購入します</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題27<br>ある企業が、顧客のニーズに対応するため、クラウド上でアプリケーションを最新化することを決定しました。<br>このビジネス上の決断を促した理由として、もっともらしいものはどれですか？' data-answer='3' data-explanation='解説<br>正解は「オンプレミスのアプリケーションは、アップデートやデプロイに数カ月かかります」です。<br>この問題では、企業がクラウド上でアプリケーションを最新化することを決定した理由を特定することが求められています。選択肢の中から最もらしくビジネス上の理由を選ぶためには、クラウド移行の一般的な動機を理解しておくことが重要です。これら一般的な動機には、効率性、スケーラビリティ、速度、コスト削減などが挙げられます。不適切な選択肢を排除しながら、これらの原則に沿った選択肢を選ぶことで、正解に近づくことができます。<br>基本的な概念や原則：<br>オンプレミス：物理的なデータセンターやサーバーなど、企業が直接管理し所有するインフラストラクチャのことです。アップデートやデプロイの速度はハードウェアやソフトウェアの制限により変わります。<br>クラウドベースのアプリケーション：ネットワークを介してアクセスする形式で、オンデマンドでスケーリング、アップデート、デプロイが可能なアプリケーションのことです。<br>オートマティックスケーリング：負荷に基づいて自動的にリソースの数を増減させるクラウドコンピューティングの特性です。クラウドではオンプレミスよりも容易に実装することができます。<br>従量課金制：利用したリソースの量に応じて料金が発生する、クラウドサービスの一般的な課金モデルです。コスト効率を高めることができます。<br>資本支出（CapEx）：固定資産の購入や改善に使われる長期投資のことです。オンプレミス環境では初期設備投資が必要になることが多いです。<br>ソースコードの自動変更：開発者の介入無しにソースコードが変わるという状況は非常に異常です。ソースコードの変更は正しいコントロールと管理下で行われるべきです。<br>正解についての説明：<br>（選択肢）<br>・オンプレミスのアプリケーションは、アップデートやデプロイに数カ月かかります<br>この選択肢が正解の理由は以下の通りです。<br>オンプレミスでのアプリケーション管理は多くの時間と労力を必要とします。特に、アプリケーションのアップデートやデプロイに数カ月間かかるということ実は、ビジネスにとって大きな問題です。この遅延は、企業が市場の変化に迅速に対応する機会を逃す原因となり、競合他社に後れを取る可能性があります。そのため、既存のオンプレミスアプリケーションをクラウド上で最新化することを決定するのは理にかなっています。クラウド上でのアプリケーション管理は、必要なリソースをすばやく、柔軟にスケールアップ・ダウンでき、アプリケーションのデプロイとアップデートも劇的に速くなります。これにより、企業は顧客のニーズに迅速に対応し、競争力を維持することが可能になります。<br>不正解の選択肢についての説明：<br>選択肢：オンプレミスのアプリケーションは、需要に合わせてオートスケールします<br>この選択肢が正しくない理由は以下の通りです。<br>オンプレミスのアプリケーションが需要に合わせてオートスケールできる場合、それはすでに十分な拡張性と柔軟性を持つことを示しています。これはクラウド移行を促す要因ではなく、むしろオンプレミス環境を維持する理由です。<br>選択肢：従量課金モデルから資本支出モデルへの変更を望んでいます<br>この選択肢が正しくない理由は以下の通りです。<br>クラウドへの移行を選択する主な動機は、効率性やスピードの改善、スケーラビリティ等です。<br>しかし、従量課金モデルから資本支出モデルへの変更は、むしろクラウドからオンプレミスへの移行を示唆するような選択肢であり、問題の意図とは逆行しています。<br>選択肢：ソースコードは、開発者の介入なしに勝手に変更されます<br>この選択肢が正しくない理由は以下の通りです。<br>まず、この選択肢はクラウド移行の理由としては適切ではなく、開発者の介入なしにソースコードが変更されるという状況は、適切なバージョン管理やセキュリティ管理が行われていない可能性を示します。<br>一方、正解の選択肢は、クラウドへの移行によりアプリケーションの更新やデプロイ時間を短縮できるという、ビジネス価値を明確に示しています。'>
<div class='choice'> 従量課金モデルから資本支出モデルへの変更を望んでいます</div>
<div class='choice'> オンプレミスのアプリケーションは、需要に合わせてオートスケールします</div>
<div class='choice'> ソースコードは、開発者の介入なしに勝手に変更されます</div>
<div class='choice'> オンプレミスのアプリケーションは、アップデートやデプロイに数カ月かかります</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題28<br>ある組織は、インフラをモダナイズする余裕はありませんが、ビジネスパートナーがホストするモデムプラットフォームでレガシーシステムのデータを処理したいと考えています。<br>データにアクセスできるようにするために、どのようなソリューションを選べばよいですか？' data-answer='0' data-explanation='解説<br>正解は「アプリケーションプログラミングインターフェース」です。<br>この問題では、組織が自社のインフラをモダナイズできない状況でも、ビジネスパートナーがホストするプラットフォームでレガシーシステムのデータを処理したいという要望を実現する適切なソリューションを選ぶ必要があります。選択肢を検討する際には、外部のプラットフォームと現行のレガシーシステムとの間でデータをやり取りするための方法を提供するソリューションに焦点を当てることが肝心です。<br>基本的な概念や原則：<br>アプリケーションプログラミングインターフェース（API）：ソフトウェアの機能を他のアプリケーションから利用するための仕組みです。レガシーシステムのデータにアクセスするための一般的な手法として利用されます。<br>レガシーシステム：古い技術または手法に基づいて構築されたが、なお現在も活用されているシステムです。モダナイゼーションの対象となることが多いです。<br>Compute Engine：Google Cloudのインフラストラクチャサービスで、仮想マシンを提供します。しかし、レガシーシステムのデータアクセスには直接的には関係ありません。<br>Anthos：Google Cloudのハイブリッドクラウドとマルチクラウドプラットフォームです。アプリケーションのモダナイゼーションと管理を支援しますが、レガシーシステムのデータアクセスには直接的には関係ありません。<br>Google Kubernetes Engine（GKE）：Google Cloudのコンテナ管理サービスで、Kubernetes環境を提供します。しかし、レガシーシステムのデータアクセスには直接的には関係ありません。<br>正解についての説明：<br>（選択肢）<br>・アプリケーションプログラミングインターフェース<br>この選択肢が正解の理由は以下の通りです。<br>アプリケーションプログラミングインターフェース（API）を利用することは、レガシーシステムのデータにアクセスし、それをビジネスパートナーがホストするモダンプラットフォームで使うための最適な手段です。APIは、異なるシステム間でデータを安全に共有するための橋渡し役となるため、既存のインフラを大きく変更することなくデータにアクセスする方法を提供します。これは組織がインフラをモダナイズする余裕がない状況に特に適しています。<br>また、APIはプログラム可能なインターフェースの提供を通じてシステム間の連携を可能にします。これによりビジネスパートナーがホストするモダンプラットフォームにおけるデータの活用を容易にし、組織全体の効率と生産性を向上させることができます。<br>以上の理由から、レガシーシステムのデータにアクセスし、それをビジネスパートナーのモダンプラットフォームで処理するためのソリューションとして、APIの利用が最適といえます。<br>不正解の選択肢についての説明：<br>選択肢：Compute Engine<br>この選択肢が正しくない理由は以下の通りです。<br>Compute Engineは仮想マシンを提供するサービスであり、インフラをモダナイズするために用いられます。<br>しかし、問題の要件はインフラモダナイゼーションではなく、外部のモデムプラットフォームから既存のレガシーシステムのデータへのアクセスを可能にすることです。この目的を達成するためにはアプリケーションプログラミングインターフェースの利用が適しています。<br>選択肢：Anthos<br>この選択肢が正しくない理由は以下の通りです。<br>Anthosは、ハイブリッド及びマルチクラウド環境でのアプリケーションデプロイメントと管理を容易にするプラットフォームですが、特定のレガシーシステムのデータに直接アクセスする機能は提供していません。<br>一方、APIはシステム間のデータ通信を可能にするため、レガシーシステムのデータにアクセスするのに適しています。<br>選択肢：Google Kubernetes Engine<br>この選択肢が正しくない理由は以下の通りです。<br>Google Kubernetes Engineはコンテナ化されたアプリケーションの実行を助けるプラットフォームであり、直接的にレガシーシステムのデータにアクセスする機能を提供するものではありません。<br>一方、APIはレガシーシステムのデータを取得または操作する授受の通信チャネルで、必要なデータにアクセスする最良の選択肢です。'>
<div class='choice'> アプリケーションプログラミングインターフェース</div>
<div class='choice'> Google Kubernetes Engine</div>
<div class='choice'> Compute Engine</div>
<div class='choice'> Anthos</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題29<br>ある組織は、オンプレミスのインフラから移行しようとしています。その代わりに、クラウド上でバーチャルにデータの作成、アクセス、共有を行いたいと考えています。<br>その組織は何を検討すべきですか？' data-answer='3' data-explanation='解説<br>正解は「データをクラウドに移行する際の組み込みセキュリティ」です。<br>この問題では、組織がオンプレミスのインフラからクラウドへの移行を検討していることを理解することが重要です。その移行プロセスで一番重要な要素は、クラウドへ移行する際のデータセキュリティをどのように確保していくかという点です。選択肢を見る際は、データのセキュリティを保証する選択肢が最も適切な選択となることを覚えておいてください。<br>基本的な概念や原則：<br>組み込みセキュリティ：Google Cloudなどのクラウドサービスは通常、各種サービスのセキュリティとプライバシーの対策を組み込んでいます。これはデータの暗号化、アクセス管理、権限管理などを含むことが多いです。<br>データのクラウド移行：オンプレミス環境からクラウド環境へのデータ移行は、組織にとって複雑なプロジェクトとなることが多いです。これにはデータの暗号化、移行速度、ダウンタイムの最小化、コスト管理など、多くの要素を考慮する必要があります。<br>境界セキュリティ：物理的なネットワーク境界を保護するためのセキュリティ手段です。クラウド環境では通常、このレイヤーのセキュリティはクラウドプロバイダーが提供します。<br>資本支出モデル：資産の購入や運用を通じて発生するコストの管理モデルです。クラウド移行では、オペレーティング支出モデル（つまり、使った分だけ支払うモデル）が一般的です。<br>正解についての説明：<br>（選択肢）<br>・データをクラウドに移行する際の組み込みセキュリティ<br>この選択肢が正解の理由は以下の通りです。<br>データをクラウドに移行する際に最も重要な検討事項の一つは組み込みセキュリティです。クラウド上でデータを作成、アクセス、共有するためには、データの機密性、完全性、利用可能性を保証するための適切なセキュリティメカニズムが必要です。クラウドプロバイダは、データ暗号化、アクセス制御、セキュリティ監査ログ、セキュリティイベントの通知など、多数の組み込みセキュリティ機能を提供しています。これらの機能を用いてデータを護りつつ、データをクラウドに移行し、そこで管理することが、データのセキュリティを確保しつつ、オンプレミスのインフラから移行する組織にとって重要な考慮事項です。<br>不正解の選択肢についての説明：<br>選択肢：境界セキュリティをデータ暗号化キーに置き換えること<br>この選択肢が正しくない理由は以下の通りです。<br>境界セキュリティをデータ暗号化キーに置き換えるという選択肢は、セキュリティ措置を一部置き換えるだけで、組織がクラウド上で安全にデータを処理するための全体的な視点を提供していません。<br>それに対して、組み込みセキュリティの検討は、データ移行全体のセキュリティを網羅するため、全体的な視点を提供します。<br>選択肢：資本支出モデルによるコスト管理の最適化<br>この選択肢が正しくない理由は以下の通りです。<br>組織がクラウド上でデータの作成、アクセス、共有を行う場合、主な検討事項はデータのセキュリティとなります。資本支出モデルによるコスト管理の最適化は重要ですが、データをクラウドに移行する際の資本支出モデルが最優先ではありません。データの守りとデータブレーチのリスクを最小化することが最も重要です。<br>選択肢：データをクラウドに移行する際のオンプレミスハードウェア容量の増加<br>この選択肢が正しくない理由は以下の通りです。<br>クラウドへの移行を考えている組織が、オンプレミスのハードウェア容量の増加を検討する理由がありません。むしろ、オンプレミスのハードウェアは縮小または完全に排除される傾向があります。正しい選択肢では、クラウド移行時にデータのセキュリティを重視しています。これは、クラウド移行の際にはセキュリティが一層重要になるからです。'>
<div class='choice'> 境界セキュリティをデータ暗号化キーに置き換えること</div>
<div class='choice'> データをクラウドに移行する際のオンプレミスハードウェア容量の増加</div>
<div class='choice'> 資本支出モデルによるコスト管理の最適化</div>
<div class='choice'> データをクラウドに移行する際の組み込みセキュリティ</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題30<br>ある大手小売企業は、eコマースウェブサイトに従来のテクノロジーを使用しています。トラフィックのピーク時には、リソースが十分に活用されなかったり、過剰にプロビジョニングされたりすることが多いです。彼らはクラウドテクノロジーへの移行を決定しました。<br>クラウドテクノロジーのどのような側面が、彼らのeコマース事業に利益をもたらしますか？' data-answer='2' data-explanation='解説<br>正解は「アジャイルなインフラによって、必要なときに必要な分だけ利用料を支払うことができます」です。<br>この問題では、クラウドテクノロジーが解決できる問題と、小売企業がクラウド移行により得られる具体的な利益にフォーカスすることが求められています。具体的には、企業が現在抱える問題であるリソースの適切な活用とプロビジョニングの課題、そしてこれを解決するためのクラウドテクノロジーの特徴を見極めることが重要です。選択肢を見るときには、その選択肢がこれらの課題を直接解決するものであるか、または間接的にもたらす利益かを注意深く見てください。<br>基本的な概念や原則：<br>アジャイルなインフラ：迅速にスケールアップおよびスケールダウンが可能なクラウドテクノロジーの特長です。需要に応じてリソースを増減させることでコスト効率を向上させます。<br>総所有コスト（TCO）：製品やサービスを保有することに伴うすべてのコストを考慮した評価です。初期導入コストだけでなく、運用コストも含まれます。<br>無制限のストレージ：Cloud Storageサービスの特長の一つで、物理的なストレージに縛られずにデータを保存することができます。しかしながら、使用した分だけ課金されるため無意識に大量のデータを保存するとコストが増大する可能性があります。<br>責任分担モデル：クラウド利用におけるセキュリティの責任が、クラウドプロバイダーと利用者間で分担される原則です。ただし、トラフィックの監視や管理は利用者側の責任範囲に含まれます。<br>正解についての説明：<br>（選択肢）<br>・アジャイルなインフラによって、必要なときに必要な分だけ利用料を支払うことができます<br>この選択肢が正解の理由は以下の通りです。<br>まず、クラウドテクノロジーの特性として、使用したリソースに対してのみ課金される"Pay-as-you-go"という特性があります。<br>従って、アジャイルなインフラを用意することで、使用しない時間に関してリソースのコストを発生させずに、利用した分だけの料金を支払うことができます。これにより、ピーク時にリソースを増加させ、外れ値の期間ではその量を減らすことができます。<br>また、システム全体の利用率を最大化し、過剰なプロビジョニングを避け、コスト効率を向上させるために、リソースをリアルタイムにスケーリングすることができます。このようなことが可能なのはクラウドテクノロジーのおかげです。<br>したがって、クラウドテクノロジーのアジャイルなインフラは、企業のeコマース事業にとって大いに利益をもたらす要素です。<br>不正解の選択肢についての説明：<br>選択肢：総所有コストがより予測可能であるため営業支出の予測精度が向上します<br>この選択肢が正しくない理由は以下の通りです。<br>クラウドテクノロジーでは利用した分だけ課金されるため、予測可能な総所有コストを実現するのは難しく、営業支出の予測精度が向上するとは一概には言えません。<br>一方、アジャイルなインフラでは、必要なときに必要なリソースを動的に確保可能なため、ピーク時の過剰なプロビジョニングの問題を解決します。<br>選択肢：無制限のストレージによって、ウェブサイトがダウンタイムに見舞われることがなくなります<br>この選択肢が正しくない理由は以下の通りです。<br>無制限のストレージがウェブサイトのダウンタイムを防ぐとは限りません。ストレージはデータ保存の側面を担当しますが、ダウンタイムの原因はサーバーの負荷やネットワークの問題など多岐に渡ります。<br>一方、アジャイルなインフラは必要に応じてリソースをスケーリングでき、ピークトラフィックに対応する能力があります。<br>選択肢：責任分担によって、クラウドプロバイダーがトラフィックのピーク時に可視性を高めてくれます<br>この選択肢が正しくない理由は以下の通りです。<br>責任分担では、トラフィックのピーク時に可視性を高めるとは限らないためです。実際、責任分担とはクラウドセキュリティをクラウドプロバイダーとエンドユーザーが共有する原則を指します。これに対して正答のアジャイルなインフラは、実際の使用量に応じてリソースと費用を調整することができ、トラフィックのピーク時の問題に対処可能です。'>
<div class='choice'> 責任分担によって、クラウドプロバイダーがトラフィックのピーク時に可視性を高めてくれます</div>
<div class='choice'> 総所有コストがより予測可能であるため営業支出の予測精度が向上します</div>
<div class='choice'> アジャイルなインフラによって、必要なときに必要な分だけ利用料を支払うことができます</div>
<div class='choice'> 無制限のストレージによって、ウェブサイトがダウンタイムに見舞われることがなくなります</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題31<br>あなたの組織では、リリースのスピードが上がるにつれて、VMベースのアプリケーションのアップグレードにおいて、OSの起動時間のためにローリングアップデートの実行に時間がかかるようになっています。あなたはアプリケーションのデプロイを高速化する必要があります。<br>この要件を満たすために、あなたは何をすべきですか？' data-answer='3' data-explanation='解説<br>正解は「アプリケーションをコンテナに変換します」です。<br>この問題では、既存のVMベースのアプリケーションのアップデートに時間がかかっており、この更新プロセスを高速化する必要があるという課題が提示されています。注目すべき点は、問題がOSの起動時間による遅れに焦点を当てていることです。そして、アプリケーションのデプロイを高速化するための適切な方法を探すことが求められています。選択肢を評価する際には、デプロイ時間を最小限にするための解決策を見つけることが重要です。<br>基本的な概念や原則：<br>コンテナ：軽量で移植性の高いソフトウェアパッケージです。アプリケーションとその依存関係を一緒にパッケージ化することで、開発からテスト、本番環境に至るまで一貫した動作を確保します。<br>ローリングアップデート：新しいバージョンのアプリケーションを徐々にデプロイし、ダウンタイムを最小限に抑えながらアップデートする手法です。<br>OSの起動時間：VM上のオペレーティングシステムが起動するまでに掛かる時間です。VMの性能や設定により異なり、アプリケーションのデプロイ速度に影響を与えます。<br>Cloud移行：アプリケーションやデータ、インフラストラクチャをクラウド環境に移行することです。柔軟性、スケーラビリティ、コスト効率を向上させますが、移行には時間とリソースが必要です。<br>自動化：手動の作業やプロセスを自動化することです。一貫性と効率性を向上させますが、アプリケーションの起動速度を改善する直接的な手段ではありません。<br>正解についての説明：<br>（選択肢）<br>・アプリケーションをコンテナに変換します<br>この選択肢が正解の理由は以下の通りです。<br>まず、コンテナは仮想マシン（VM）と比べて起動がはるかに速く、数秒以内に起動します。そのため、アップグレードの際のローリングアップデート実行時間を大幅に短縮することができます。<br>また、OSの起動時間による遅延はコンテナ化により解消されます、なぜならコンテナはOSを含んだ全体像をキャプチャし、その状態をすぐに再現できます。<br>さらに、コンテナ技術を用いることで、アプリケーションのデプロイメントを容易になり、バージョン管理がしやすくなります。これは、アプリケーションの構成をコードとして管理できるため、一貫性や再現性を保てます。<br>したがって、これらの理由から、アプリケーションのデプロイを高速化する要件を満たすためには、アプリケーションをコンテナに変換することが最善の選択と言えます。<br>不正解の選択肢についての説明：<br>選択肢：VMをクラウドに移行し、リソースを追加します<br>この選択肢が正しくない理由は以下の通りです。<br>VMをクラウドに移行し、リソースを追加するという解決策はローリングアップデートの遅さの根本原因、すなわちOSの起動時間を短縮するものではありません。それと対照的に、アプリケーションをコンテナに変換すると、OSの起動が不要なのでデプロイを高速化することができます。<br>選択肢：VMのリソースを増やします<br>この選択肢が正しくない理由は以下の通りです。<br>問題の目的はアプリケーションのデプロイを高速化することであり、VMのリソースを増やす行為自体がその目的を達成するものではありません。<br>対照的に、アプリケーションをコンテナに変換することで、OSの起動時間を気にせずにローリングアップデートが可能になるため、デプロイ時間を大幅に短縮できます。<br>選択肢：アップグレードロールアウトを自動化します<br>この選択肢が正しくない理由は以下の通りです。<br>アップグレードロールアウトを自動化すると、確かに手作業が減りますがOSの起動時間にかかる問題は解消しません。<br>一方、アプリケーションをコンテナ化することで起動時間が大幅に削減され、デプロイが高速化できます。'>
<div class='choice'> VMをクラウドに移行し、リソースを追加します</div>
<div class='choice'> アップグレードロールアウトを自動化します</div>
<div class='choice'> VMのリソースを増やします</div>
<div class='choice'> アプリケーションをコンテナに変換します</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題32<br>ある企業が、年間を通じてユーザーの好みに合わせてパーソナライズできるアプリケーションを開発したいと考えています。<br>既存のオンプレミスアプリケーションをモダナイズするのではなく、クラウドネイティブアプリケーションを構築するメリットとして正しいものはどれですか？' data-answer='2' data-explanation='解説<br>正解は「開発者はアジャイルな方法で新機能を立ち上げることができます」です。<br>この問題では、クラウドネイティブアプリケーションの構築に関するメリットを理解することが重要です。既存のオンプレミスアプリケーションをモダナイズするのではなく、クラウド環境で新たにアプリケーションを構築する目的や恩恵について考察する必要があります。選択肢を検討する際には、クラウドネイティブアプリケーション構築が開発者やIT管理者にどのような利点をもたらすかを把握することがキーとなります。<br>基本的な概念や原則：<br>アジャイル開発：開発のプロセスを小さなイテレーションに分割し、フィードバックを吸収しながら製品の改善を進める開発手法です。新機能の迅速なリリースと改善を可能にします。<br>クラウドネイティブアプリケーション：クラウドの特性を充分に活用するように設計されたアプリケーションです。可用性、拡張性、運用効率などを向上させるために、コンテナ化、マイクロサービス、CI/CDなどの手法を利用します。<br>ソースコードの依存性：開発者が使用するライブラリやフレームワークがどの程度特定のプラットフォームに依存するかを表す概念です。依存性が高いと、そのプラットフォーム外での運用が難しくなる可能性があります。<br>アプリケーションアーキテクチャの移行：既存のアプリケーションを別のプラットフォームや環境に移行する作業です。アーキテクチャの改変やアップデートが必要な場合が多いです。<br>資本支出の計画：事業運営のために必要な設備投資や人件費など、長期的な投資計画のことです。クラウドサービスの採用は、この計画をフレキシブルにし、運用コストを削減する可能性があります。<br>正解についての説明：<br>（選択肢）<br>・開発者はアジャイルな方法で新機能を立ち上げることができます<br>この選択肢が正解の理由は以下の通りです。<br>まず、クラウドネイティブアプリケーションは、開発、運用、保守が容易で、高速に更新やデプロイが可能です。この特性により開発者はアジャイルな方法で新機能を立ち上げることができます。これは、必要に応じて素早く機能追加や修正、改善を行い、ユーザーの好みに合わせたパーソナライズを年間を通じて行うアプリケーション開発に適しています。<br>また、クラウドネイティブアプリケーションはスケーラビリティにも優れています。需要が増えた場合や特定の期間にピークがある場合でも、リソースをダイナミックに増減させてパフォーマンスを維持することができます。このため、ユーザー体験の低下を防ぐことができます。これらの理由から、既存のオンプレミスアプリケーションをモダナイズするのではなく、クラウドネイティブアプリケーションの構築が推奨されます。<br>不正解の選択肢についての説明：<br>選択肢：開発者はすべてのソースコードをクラウドプロバイダーに依存することができます<br>この選択肢が正しくない理由は以下の通りです。<br>クラウドネイティブアプリケーションの開発において、開発者が全てのソースコードをクラウドプロバイダーに依存させるメリットはありません。これはソースコードの所有権と移植性を制限し、ベンダーロックインのリスクを増加させます。<br>正解の選択肢のように、クラウドネイティブアプリケーションのメリットは、アジャイルな開発プロセスを可能にする点にあります。<br>選択肢：IT管理者は、アップデートを必要とせずに既存のアプリケーションアーキテクチャを移行できます<br>この選択肢が正しくない理由は以下の通りです。<br>IT管理者がアップデートなしに既存のアプリケーションアーキテクチャを移行できるというのは誤りです。クラウドネイティブアプリケーションは元々クラウド向けに設計されるため、既存アーキテクチャの単純移行ではその利点を享受できません。<br>それに対して、アジャイルな方法で新機能立ち上げられるのはクラウドネイティブのメリットです。<br>選択肢：IT管理者は資本支出をより正確に計画できます<br>この選択肢が正しくない理由は以下の通りです。<br>クラウドネイティブアプリケーションの構築はIT管理者が資本支出をより正確に計画できることとは直接関係がありません。正解は"開発者はアジャイルな方法で新機能を立ち上げることができます"で、これはクラウドネイティブアプリケーションの特性を反映しています。'>
<div class='choice'> IT管理者は資本支出をより正確に計画できます</div>
<div class='choice'> 開発者はすべてのソースコードをクラウドプロバイダーに依存することができます</div>
<div class='choice'> 開発者はアジャイルな方法で新機能を立ち上げることができます</div>
<div class='choice'> IT管理者は、アップデートを必要とせずに既存のアプリケーションアーキテクチャを移行できます</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題33<br>あなたの組織はモバイルアプリを開発しており、そのために完全な機能を備えたクラウドベースのコンピュートプラットフォームを選択したいと考えています。<br>どのGoogle Cloudサービスまたは機能を使用すべきですか？' data-answer='0' data-explanation='解説<br>正解は「Firebase」です。<br>この問題では、モバイルアプリ開発に適したクラウドベースのコンピュートプラットフォームを選択することが目的です。モバイルアプリ開発ではバックエンド処理だけではなく、ユーザ認証、リアルタイムデータベース、クラウドメッセージングなど多岐に渡る機能が求められます。選択肢を見るとき、それら全ての機能を提供するサービスを選びます。ただし、ただ機能が揃っていればいいわけではなく、モバイルアプリ開発特有のニーズを満たす能力も重要です。<br>基本的な概念や原則：<br>Firebase：モバイルアプリ開発に必要な多くの機能を提供するGoogle Cloudの完全クラウドベースのプラットフォームです。認証、データベース、ストレージ、アナリティクスなどのサービスが含まれています。<br>Google Kubernetes Engine：コンテナ化されたアプリケーションを実行するためのサービスです。従来のモバイルアプリ開発とは異なり、Microservicesアーキテクチャの開発に特化しています。<br>Cloud Functions：イベント駆動型のコードの実行を提供する、フルマネージドのサービスレスコンピュートプラットフォームです。あまりにも規模が大きすぎるモバイルアプリ開発には適していません。<br>App Engine：フルマネージドのサーバレスアプリケーションプラットフォームです。モバイルアプリの開発には適していますが、Firebaseのような豊富な機能と統合性は提供していません。<br>正解についての説明：<br>（選択肢）<br>・Firebase<br>この選択肢が正解の理由は以下の通りです。<br>まず、Firebaseはモバイルアプリケーションの開発、運用、成長を支援するためのGoogle Cloudの一部です。Firebaseは、開発から分析、エンゲージメント向上まで、モバイルアプリケーションのライフサイクル全体を補完する一連の機能とサービスを提供します。これにより、モバイルアプリケーションの開発、テスト、リリース、モニタリングを効率よく行うことができます。これらの機能は全てクラウドベースで提供され、開発者が集中するべきビジネスロジックにフォーカスすることを可能にします。<br>また、Firebaseはリアルタイムデータベースや認証などのバックエンド機能を提供しています。これらの強力な機能を活用することで、モバイルアプリケーションを効率的に開発し、高品質なユーザー体験を提供することができます。<br>したがって、モバイルアプリケーションの開発にFirebaseを使用することは、非常に有効な選択と言えます。<br>不正解の選択肢についての説明：<br>選択肢：Google Kubernetes Engine<br>この選択肢が正しくない理由は以下の通りです。<br>Google Kubernetes Engineはコンテナのデプロイ、スケーリング、管理をするためのサービスですが、モバイルアプリ開発のためのフル機能クラウドベースプラットフォームではありません。<br>一方、Firebaseはモバイルアプリ開発に特化した多数の機能を提供しています。<br>選択肢：Cloud Functions<br>この選択肢が正しくない理由は以下の通りです。<br>Cloud Functionsはサーバレス環境でコードを実行するためのサービスですが、モバイルアプリ開発に要求される"完全な機能を備えた"プラットフォームとしては不十分です。<br>一方、Firebaseはバックエンドサービス、認証、Analytics、メッセージングなど、モバイルアプリ開発に必要な全ての機能を統合したプラットフォームです。<br>選択肢：App Engine<br>この選択肢が正しくない理由は以下の通りです。<br>App Engineはクラウドベースのコンピュートプラットフォームであり、アプリケーション開発と部署に使用できますが、モバイルアプリ開発は特殊なニーズを満たすには限定的な機能しか提供しません。<br>一方で、Firebaseはモバイルアプリ開発に必要な完全な機能セットを提供し、リアルタイムデータベース、認証、クラッシュレポーティングなどを含む大量のAPIとSDKを提供します。'>
<div class='choice'> Firebase</div>
<div class='choice'> App Engine</div>
<div class='choice'> Cloud Functions</div>
<div class='choice'> Google Kubernetes Engine</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題34<br>ある組織は、アプリケーションインフラストラクチャを管理することなく、オートスケールのウェブアプリケーションを構築したいと考えています。<br>どのGoogle Cloudサービスを使うべきですか？' data-answer='2' data-explanation='解説<br>正解は「App Engine」です。<br>この問題では、アプリケーションインフラストラクチャの管理を必要とせず、オートスケールのウェブアプリケーションを構築したいという組織のニーズを満たすGoogle Cloudサービスを選択する問題です。選択肢から最適なサービスを選ぶ際は、各サービスがどのような機能とメリットを提供するのかを考え、その中で組織のニーズに最も適したものを選ぶことが求められます。<br>基本的な概念や原則：<br>App Engine：Google Cloudのフルマネージドなサービスで、デベロッパーがアプリケーションの開発、ホスティング、スケーリングに集中できます。インフラストラクチャの管理が不要で、自動スケーリングが可能です。<br>Anthos：Google Cloudのオープンなプラットフォームで、アプリケーションを一貫してビルド、デプロイ、管理することができます。主にハイブリッドクラウドやマルチクラウド環境をターゲットとしています。<br>Apigee：Google CloudのAPI管理プラットフォームです。APIの開発、セキュリティ、分析、オペレーションを支援します。<br>AutoML：Google Cloudの機械学習モデルを生成するサービスです。専門的な機械学習の知識がなくても使用が可能です。<br>正解についての説明：<br>（選択肢）<br>・App Engine<br>この選択肢が正解の理由は以下の通りです。<br>まず、Google CloudのApp Engineは完全にマネージドなPlatform as a Service（PaaS）であるため、インフラストラクチャを管理する負担を完全に排除します。管理負荷が無いことは、開発チームがアプリケーションのビジネスロジックの開発に集中することが可能になるという大きなメリットがあります。<br>また、PaaSの特性として、App Engineは開発、デプロイ、スケールの各フェーズでの自動化をサポートしています。<br>さらに、App Engineはオートスケーリング機能を備えています。このため、ウェブアプリケーションの利用者数が増えたり減ったりする状況に対応することができます。自動でスケーリングする機能は、リソースの最適化及びコスト効率を保つために重要です。<br>したがって、インフラストラクチャの管理なしで、オートスケールのウェブアプリケーションを構築したいという要件を満たすためには、App Engineの利用が適切です。<br>不正解の選択肢についての説明：<br>選択肢：Anthos<br>この選択肢が正しくない理由は以下の通りです。<br>Anthosはマルチクラウドやオンプレミスの環境を一元的に管理するためのサービスであり、アプリケーションインフラストラクチャの管理をせずにオートスケールのウェブアプリケーションを構築する目的には適合しません。<br>一方、App EngineはフルマネージドなPaaSで、アプリケーションのスケーリングを自動化する機能を提供しています。<br>選択肢：Apigee<br>この選択肢が正しくない理由は以下の通りです。<br>ApigeeはAPIマネージメントツールであり、ウェブアプリケーションを直接構築、スケーリングする機能は提供していません。<br>それに対して、App Engineは自動的にスケーリングされるウェブアプリケーションの構築と運用を可能にするサービスで、組織の要件に適合します。<br>選択肢：AutoML<br>この選択肢が正しくない理由は以下の通りです。<br>AutoMLは機械学習モデルを作成・学習させるためのサービスであり、オートスケーリングのウェブアプリケーションを構築するという目的には適していません。<br>それに対して、App Engineはバックエンドやインフラストラクチャの管理なしに、オートスケーリングのウェブアプリケーションを構築可能です。'>
<div class='choice'> Apigee</div>
<div class='choice'> AutoML</div>
<div class='choice'> App Engine</div>
<div class='choice'> Anthos</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題35<br>あなたの組織は、Google Cloud上でコンテナベースのアプリケーションを実行したいと考えています。このアプリケーションは複雑化することが予想されます。コンテナ間のトラフィックをきめ細かく制御するセキュリティニーズがあります。また、アプリケーションのスケーリングポリシーをきめ細かく制御する運用ニーズもあります。<br>この要件を満たすために、どのGoogle Cloudサービスまたは機能を使用すべきですか？' data-answer='3' data-explanation='解説<br>正解は「Google Kubernetes Engineクラスター」です。<br>この問題では、アプリケーションのスケーリングポリシーとコンテナ間のトラフィックを緻密に制御することが求められています。これらの要求は、複雑なマイクロサービスの管理能力を要求しており、特定のクラウドサービスの機能を理解し、それらの機能が特定のニーズにどのように対応できるかを判断する必要があります。選択肢を見ると、それぞれのサービス機能に基づいて適切な選択をすることが求められます。<br>基本的な概念や原則：<br>Google Kubernetes Engine（GKE）：マネージドなKubernetesサービスで、コンテナ化されたアプリケーションのデプロイ、管理、スケーリングを行うことができます。複雑なワークロードの実行や、トラフィックやスケーリングポリシーの細かな制御に対応しています。<br>App Engine：フルマネージドのサービスで、開発から運用までのアプリケーションライフサイクルをGoogle Cloudが自動的にハンドリングします。より簡易なアプリケーションや、インフラ管理を少なくしたい場合に適しています。<br>Cloud Run：サーバレス環境でコンテナを実行するサービスです。開発からデプロイまでを簡単に行うことができますが、GKEと比較すると細かな制御が限定的です。<br>Compute Engine：仮想マシンを提供するサービスです。幅広いカスタマイズが可能ですが、コンテナ管理のための機能は限定的です。<br>正解についての説明：<br>（選択肢）<br>・Google Kubernetes Engineクラスター<br>この選択肢が正解の理由は以下の通りです。<br>Google Kubernetes Engine（GKE）は、複雑さを増していくコンテナベースのアプリケーションを管理して実行するための強力なプラットフォームを提供します。セキュリティニーズに対しては、GKEのネットワークポリシーを使用することで、コンテナ間のトラフィックをきめ細かく制御することができます。ネットワークポリシーは、特定のポッド群を分離し、それらが他のポッド群とどのように通信できるかを制御します。これにより、セキュリティニーズを満たします。<br>また、運用ニーズに対しては、GKEの自動スケーリング機能を使用することで、アプリケーションのスケーリングポリシーをきめ細かく制御することができます。これにより、アプリケーションに必要なリソースが自動で調整され、パフォーマンスが最適化されます。これにより、運用ニーズも満たします。<br>したがって、GKEクラスターは本問題の要件を満たす最良の選択肢です。<br>不正解の選択肢についての説明：<br>選択肢：App Engine<br>この選択肢が正しくない理由は以下の通りです。<br>App Engineはアプリケーションのデプロイとスケーリングを容易にするPaaSですが、コンテナ間のトラフィック管理やスケーリングポリシーのきめ細かい制御については提供していません。<br>それに対し、Google Kubernetes Engineはコンテナオーケストレーションのためのサービスで、これらの要件を満たします。<br>選択肢：Cloud Run<br>この選択肢が正しくない理由は以下の通りです。<br>Cloud Runは、コンテナを即座に実行するもので、きめ細かな制御やトラフィック制御は不可能です。しかしながら、Google Kubernetes Engineはコンテナ間のトラフィック制御やスケーリングポリシーの制御が可能であり、問題の要件を満たします。<br>選択肢：Compute Engine仮想マシン<br>この選択肢が正しくない理由は以下の通りです。<br>Compute Engine仮想マシンは単体のVMであり、複雑なアプリケーションの管理やコンテナ間のトラフィック制御などを直接行う機能は提供していません。<br>一方、Google Kubernetes Engineは複数のコンテナの運用を効率化し、高度なスケーリングやセキュリティ設定を可能にします。'>
<div class='choice'> Cloud Run</div>
<div class='choice'> Compute Engine仮想マシン</div>
<div class='choice'> App Engine</div>
<div class='choice'> Google Kubernetes Engineクラスター</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題36<br>あなたの組織は、Google Cloudの仮想マシンベースのワークロード割引の利用を最適化したいと考えています。今後3年間、常時200CPUを使用する予定ですが、最大300CPUのスパイクが約30％の頻度で発生すると予測しています。何を選択すべきですか？' data-answer='3' data-explanation='解説<br>正解は「200CPUの3年間確約利用割引」です。<br>この問題では、Google Cloudの仮想マシンベースのワークロード割引の利用を最適化する方法を選択する必要があります。常時200CPUを使用し、スパイクで最大300CPUが必要となる状況を考慮することが求められています。それに加えて、スパイクが発生する頻度を解釈し、各選択肢のランニングコストを評価する必要があります。常時使用するCPU数とスパイク時のCPU数の差異と費用の最適化を駆使して選択肢を評価してください。<br>基本的な概念や原則：<br>確約利用割引：Google Cloudの一部サービス（例：Compute EngineのVMインスタンス）について、予め一定期間の利用を確約することで割引価格を適用できる制度です。割引率は利用期間（1年vs.3年）とリージョンによります。<br>CPU：コンピュータの中央処理装置のことです。仮想マシンの性能を決定する重要な部品であり、仮想マシンの料金計算にも影響します。<br>スパイク：負荷が急激に増加することを指します。スパイクが発生すると、システムのリソースが一時的に逼迫し、パフォーマンスが低下する恐れがあります。<br>従量課金：使用したリソースの量に応じて料金が発生する課金方式です。使用料金はリアルタイムで変動し、予測が難しい場合があります。<br>正解についての説明：<br>（選択肢）<br>・200CPUの3年間確約利用割引<br>この選択肢が正解の理由は以下の通りです。<br>Google Cloudの確約利用割引は、一定の使用量を前もって約束することで大幅な割引を得るプログラムです。このケースでは、常時200CPUを使用する予定とのことなので、これに対応する200CPUの3年間確約利用割引を選択することで、この部分の利用に対しては最低限の費用で済むようになります。この選択肢が適切な理由は、200CPUの使用が確定しており、組織が長期的（3年間）にわたってこれを維持する意向をもっているためです。<br>それに対して、スパイクで追加のCPUが必要な場合は頻度が30％と低いため、これに対する長期割引は比較的効率的でなく、スパイク発生時のオンデマンド課金で対応するのが合理的です。<br>不正解の選択肢についての説明：<br>選択肢：200CPUの1年間確約利用割引<br>この選択肢が正しくない理由は以下の通りです。<br>まず、使用予定の期間が3年であるため、1年間の確約利用割引では予定期間全体のコスト削減が最適化できません。<br>さらに、長期間にわたる利用の場合には、より長い期間の確約利用割引が提供する割引率の方が大きくなります。<br>選択肢：300CPUの3年間確約利用割引<br>この選択肢が正しくない理由は以下の通りです。<br>300CPUの3年間確約利用割引を選択すると、必要な分以上のコストが発生します。スパイクは30％の頻度でのみ発生し、常時必要なCPU数は200であるため、200CPUの3年間確約利用割引を選択することが、リソースの利用を最適化するのに適切です。<br>選択肢：通常の従量課金<br>この選択肢が正しくない理由は以下の通りです。<br>通常の従量課金は、使用した分だけ課金されるので、常時使用する200CPU分については、3年間確約利用割引を適用する方がコスト削減になります。スパイク時の追加CPU使用に対しては、従量課金を適用しても全体のコストは最適化されます。'>
<div class='choice'> 200CPUの1年間確約利用割引</div>
<div class='choice'> 300CPUの3年間確約利用割引</div>
<div class='choice'> 通常の従量課金</div>
<div class='choice'> 200CPUの3年間確約利用割引</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題37<br>あなたの組織は、Google Cloudの仮想マシン上でアプリケーションを実行しています。このアプリケーションは、受信したイメージを処理します。このアクティビティは、各イメージの結果を作成するのに数時間かかります。このアプリケーションのワークロードは通常、一定のベースラインレベルにとどまりますが、一定の間隔でワークロードが急増します。<br>あなたの組織は、このアプリケーションの実行コストを管理する必要があります。<br>この要件を満たすためには、どうすればよいですか？' data-answer='0' data-explanation='解説<br>正解は「仮想マシンの継続利用割引を活用します」です。<br>この問題では、既存のアプリケーションが仮想マシン上で実行され、ワークロードが一定期間ごとに急増するシナリオへの対応策を尋ねています。重要な点は、コストを管理しながらこの急増するワークロードに対応するための最適なソリューションを選ぶことです。選択肢を検討する際には、それぞれの選択肢が提供するメリットやデメリットの理解と、それが組織のワークロードとコスト管理の要件とどう合致するかを評価することがポイントとなります。<br>基本的な概念や原則：<br>継続利用割引：Google Compute Engineでは、一定期間（月間）にわたり一貫して使用される仮想マシンを対象に自動的に割引を適用する機能です。予約や手続きなしで利用でき、使えば使うほど割引率が増えます。<br>確約利用割引：あらかじめ1年または3年の期間で特定のリソースを予約・購入し、その分のコストを大幅に割引する一方で、一度購入すると変更やキャンセルができない契約形式です。主に一定のベースライン負荷がある場合に有効です。<br>プリエンプティブVMインスタンス：Google Compute Engineのスポットインスタンス的な機能で、通常の価格の大幅に割引された価格で仮想マシンを利用できます。ただし、他の使用者がそれを必要としたり、24時間が経過するとインスタンスは停止されます。主に短期間内で完結する非クリティカルなワークロードに適しています。<br>正解についての説明：<br>（選択肢）<br>・仮想マシンの継続利用割引を活用します<br>この選択肢が正解の理由は以下の通りです。<br>Google Cloudの継続利用割引（Committed Use Discounts）は、特定の一連の仮想マシン（VM）を一定期間（1年または3年）より長く稼働させることで適用される割引価格を提供します。この仕組みは、プロジェクトの消費コストを大幅に節約する強力な手法で、VMの利用時間が高い場合に特に有効です。文中のアプリケーションは、ワークロードがほとんど一定のレベルにとどまり、数時間かけてイメージを処理するため、このような長期的な使用パターンに適しています。<br>また、急増期間でもVMが稼働し続けることが想定されるため、その期間でも継続利用割引を利用できます。<br>したがって、この全体的な運用パターンを考えると、継続利用割引はコストを管理する上で効果的な選択肢です。<br>不正解の選択肢についての説明：<br>選択肢：ベースライン負荷に対して確約利用割引を購入します<br>この選択肢が正しくない理由は以下の通りです。<br>確約利用割引は予め一定期間使用することを契約し、一定以上の稼働時間が保証された場合に適用される割引制度です。<br>しかし、ワークロードが一定間隔で急増するという状況では割引を最大限活用できません。<br>一方、継続利用割引は常に使用される仮想マシンに自動で適用されるので、このシナリオに適しています。<br>選択肢：予想されるスパイク負荷に対して確約利用割引を購入します<br>この選択肢が正しくない理由は以下の通りです。<br>確約利用割引は長期的、かつ一定の使用量を見込む場合に有効ですが、ワークロードが一定間隔で急増する場合には適していません。継続利用割引の方がランダムな利用パターンでも自動的に割引が適用されるため、コストを効率的に管理できます。<br>選択肢：プリエンプティブVMインスタンス上でワークロードを実行します<br>この選択肢が正しくない理由は以下の通りです。<br>プリエンプティブVMインスタンスはコスト効率が高い反面、最大24時間しか稼働しない制限があり、またGoogleのリソース需要によりいつでも停止されるリスクを持つため、数時間かけて処理を行う本アプリケーションのワークロードには不適切です。<br>それに対して、継続利用割引は一定の使用率以上で適用されるため、コストを抑えつつ安定度は保持できます。'>
<div class='choice'> 仮想マシンの継続利用割引を活用します</div>
<div class='choice'> プリエンプティブVMインスタンス上でワークロードを実行します</div>
<div class='choice'> ベースライン負荷に対して確約利用割引を購入します</div>
<div class='choice'> 予想されるスパイク負荷に対して確約利用割引を購入します</div>
</div>
<div class='question' data-multiple='FALSE' data-question='問題38<br>あるホテルがレガシーシステムをモダナイズし、顧客がモバイルアプリから予約できるようにしたいと考えています。<br>アプリケーションプログラミングインターフェース（API）を使うメリットは次のうちどれですか？' data-answer='1' data-explanation='解説<br>正解は「レガシーシステムを書き直す必要がなくなります」です。<br>この問題では、レガシーシステムのモダナイゼーションという目的と、API使用の利点をつなげることが重要です。ホテルがレガシーシステムを変更せずに、顧客の新たな要求を満たす方法を考えなければなりません。なぜなら、選択肢はすべてAPIの使用に関連していますが、その中で最も適切なものは既存のシステムに大きな変更を加えることなく新しいサービスを提供できるものです。従って、どの選択肢がレガシーシステムに最小限の変更をもたらし、さらに新しい機能を提供できるかを見つけることが重要です。<br>基本的な概念や原則：<br>API（Application Programming Interface）：ソフトウェア間のインターフェースで、一方のソフトウェアがもう一方のソフトウェアの機能やデータにアクセスするための方法を定義しています。APIを活用すれば、異なるシステム間でデータや機能を共有できます。<br>レガシーシステム：既存の、しばしば古い技術に基づくITシステムです。新たな技術の導入や変更が困難な場合がありますが、APIを利用して既存システムと新しいシステムを接続することができます。<br>モダナイゼーション：既存のシステムやプロセスを最新の技術や方法にアップデートすることを指します。APIの導入は、システムモダナイゼーションの一部となり得ます。<br>クラウドネイティブ：クラウド特有の利点を最大限に活用するために設計されたアプリケーションとサービスのことを指します。レガシーシステムをAPIで包むだけでは、必ずしもクラウドネイティブに変わったではありません。<br>正解についての説明：<br>（選択肢）<br>・レガシーシステムを書き直す必要がなくなります<br>この選択肢が正解の理由は以下の通りです。<br>アプリケーションプログラミングインターフェース（API）の使用は、レガシーシステムと新しいモバイルアプリとの間に相互作用するためのブリッジを提供します。APIは、モバイルアプリとレガシーシステムとの間で情報が共有されるように作用し、従ってレガシーシステムのコードを書き直す必要がなくなります。これにより、時間と費用を大量に消費する可能性のある大規模な再開発を避けることができます。<br>さらに、APIは疎結合性を提供します。これにより、システムの各部分は独立して進化し、改善することができ、その結果、柔軟性と持続可能性が向上します。<br>したがって、APIの利用は、予約システムのモダナイゼーションにとって素晴らしい選択です。<br>不正解の選択肢についての説明：<br>選択肢：エンドユーザーアプリケーションを開発する必要がなくなります<br>この選択肢が正しくない理由は以下の通りです。<br>APIによるインターフェースは、既存システムと新規開発アプリケーションとの間の連携を容易にするものであり、アプリケーション自体の開発が不要になるわけではありません。<br>逆に、顧客がモバイルアプリから予約できるようにするためには、エンドユーザーアプリケーションの開発が必要です。<br>選択肢：レガシーシステムを廃止できます<br>この選択肢が正しくない理由は以下の通りです。<br>APIの利用はレガシーシステムの廃止を意味しません。APIを使用することにより、レガシーシステムと新規システム（この場合はモバイルアプリ）が連携し、既存システムを書き直すことなく新機能を追加することが可能になります。<br>選択肢：システムをクラウドネイティブに変えることができます<br>この選択肢が正しくない理由は以下の通りです。<br>APIを導入する主なメリットの一つはシステムのクラウドネイティブ化ではなく、既存のレガシーシステムを書き直さずにその機能を新しいアプリケーションから利用できるようにすることです。クラウドネイティブ化はシステム全体の設計や運用を見直す必要があり、単純にAPIを追加するだけでは達成できません。'>
<div class='choice'> システムをクラウドネイティブに変えることができます</div>
<div class='choice'> レガシーシステムを書き直す必要がなくなります</div>
<div class='choice'> レガシーシステムを廃止できます</div>
<div class='choice'> エンドユーザーアプリケーションを開発する必要がなくなります</div>
</div>
            <!-- 他の問題も同様に追加 -->
        </div>

        <h2 id="question"></h2>
        <ul class="choices" id="choices"></ul>
        <button onclick="checkAnswer()">採点</button>
        <button onclick="nextQuestion()" id="nextButton" style="display: none;">次の問題へ</button>
        <div class="result" id="result"></div>
    </div>

    <script>
        let currentQuestionIndex = 0;
        let correctCount = 0;
        const questions = [];

        document.addEventListener('DOMContentLoaded', () => {
            const questionElements = document.querySelectorAll('#quiz-data .question');
            questions.push(...Array.from(questionElements).map(questionElement => ({
                question: questionElement.getAttribute('data-question').replace(/\\n/g, '<br>'),
                choices: Array.from(questionElement.querySelectorAll('.choice')).map((choice, index) => ({
                    text: choice.textContent,
                    index: index
                })),
                correctAnswer: questionElement.getAttribute('data-answer').split(',').map(Number),
                explanation: questionElement.getAttribute('data-explanation').replace(/\\n/g, '<br>'),
                multiple: questionElement.getAttribute('data-multiple') === 'true'
            })));
            showQuestion();
        });

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function showQuestion() {
            const questionElement = document.getElementById('question');
            const choicesContainer = document.getElementById('choices');
            const currentQuestion = questions[currentQuestionIndex];

            shuffleArray(currentQuestion.choices);

            questionElement.innerHTML = currentQuestion.question;
            choicesContainer.innerHTML = '';

            currentQuestion.choices.forEach((choice, i) => {
                const li = document.createElement('li');
                const input = document.createElement('input');
                const label = document.createElement('label');

                input.type = currentQuestion.multiple ? 'checkbox' : 'radio';
                input.name = 'choice';
                input.value = choice.index;
                input.id = 'choice' + i;

                label.htmlFor = 'choice' + i;
                label.textContent = choice.text;

                li.appendChild(input);
                li.appendChild(label);
                choicesContainer.appendChild(li);
            });

            document.getElementById('result').textContent = "";
            document.getElementById('nextButton').style.display = 'none';
        }

        function checkAnswer() {
            const currentQuestion = questions[currentQuestionIndex];
            const selectedChoices = Array.from(document.querySelectorAll('input[name="choice"]:checked'))
                                        .map(checkbox => parseInt(checkbox.value))
                                        .sort();
            const resultElement = document.getElementById('result');
            
            if (selectedChoices.length > 0) {
                const isCorrect = currentQuestion.multiple
                    ? selectedChoices.toString() === currentQuestion.correctAnswer.sort().toString()
                    : selectedChoices.length === 1 && selectedChoices[0] === currentQuestion.correctAnswer[0];
                
                if (isCorrect) {
                    resultElement.innerHTML = "正解です！<br>" + currentQuestion.explanation;
                    resultElement.style.color = "green";
                    correctCount++; // 正解数をカウント
                } else {
                    resultElement.innerHTML = "残念、不正解です。<br>" + currentQuestion.explanation;
                    resultElement.style.color = "red";
                }
                document.getElementById('nextButton').style.display = 'inline';
            } else {
                resultElement.textContent = "回答を選択してください。";
                resultElement.style.color = "orange";
            }
        }

        function nextQuestion() {
            currentQuestionIndex++;
            
            if (currentQuestionIndex < questions.length) {
                showQuestion();
            } else {
                showFinalResult();
            }
        }

        function showFinalResult() {
            const quizContainer = document.querySelector('.quiz-container');
            quizContainer.innerHTML = `
                <h2>問題終了！</h2>
                <p>あなたの正解数は ${correctCount} / ${questions.length} です。</p>
                <button onclick="restartQuiz()">再挑戦する</button>
            `;
        }

        function restartQuiz() {
            correctCount = 0;
            currentQuestionIndex = 0;

            // クイズのUI全体を初期化
            const quizContainer = document.querySelector('.quiz-container');
            quizContainer.innerHTML = `
                <h2 id="question"></h2>
                <ul class="choices" id="choices"></ul>
                <button onclick="checkAnswer()">採点</button>
                <button onclick="nextQuestion()" id="nextButton" style="display: none;">次の問題へ</button>
                <div class="result" id="result"></div>
            `;

            // 初期化後に最初の問題を表示
            showQuestion();
        }        
    </script>
</body>
</html>
